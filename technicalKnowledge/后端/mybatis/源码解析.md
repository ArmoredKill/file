# 整体架构

Mybatis的整体架构分为三层：基础支持层、核心处理层和接口层。

![image-20230222161749343](mybatis 整体架构.png)

[Mybatis源码结构](MyBatis源码结构.xmind)

## 解析模块

My Batis 在初始化过程中处理 mybatis-config配置文件以及映射文件时，使用的是 DOM 解析方式，井结合使用 XPath 解析 XML 配置文件。XPath 使用路径表达式来选取 XML 文档中指定的节点或者节点集合，与常见的 URL 路径 有些类似。下表展示了 XPath 中常用的表达式：

| 表达式   | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| nodename | 选取指定节点的所有子节点                                     |
| /        | 从根节点选取指定节点                                         |
| //       | 根据指定的表达式，在整个文档中选取匹配的节点                 |
| .        | 选取当前节点                                                 |
| ..       | 选取当前节点的父节点                                         |
| @        | 选取属性                                                     |
| *        | 匹配任何元素的节点                                           |
| @*       | 匹配任何属性节点                                             |
| node()   | 匹配任何类型的节点                                           |
| text()   | 匹配文本节点                                                 |
| \|       | 选取若干个路径                                               |
| []       | 指定某个条件，用于查找某个特定的节点或者包含某个指定值的节点 |

下面提供一个简单的示例程序：

```java
public static void main(String[] args) throws Exception{
    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();

    // 开启验证
    // 设置解析器在解析文档的时候校验文档
    documentBuilderFactory.setValidating(true);
    // 是否支持命名空间
    documentBuilderFactory.setNamespaceAware(false);
    documentBuilderFactory.setIgnoringComments(true);
    documentBuilderFactory.setIgnoringElementContentWhitespace(false);
    documentBuilderFactory.setCoalescing(false);
    documentBuilderFactory.setExpandEntityReferences(true);

    // 创建
    DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();
    builder.setErrorHandler(new ErrorHandler() {
        @Override
        public void warning(SAXParseException exception) throws SAXException {
            System.out.println("warning:" + exception.getMessage());
        }

        @Override
        public void error(SAXParseException exception) throws SAXException {
            System.out.println("error::" + exception.getMessage());
        }

        @Override
        public void fatalError(SAXParseException exception) throws SAXException {
            System.out.println("fatalError::" + exception.getMessage());
        }
    });

    // 将文档加载到Document
    Document doc = builder.parse("mybatis-example/src/main/java/org/example/test/inventory.xml");
    // 创建 XPathFactory
    XPathFactory factory = XPathFactory.newInstance();
    // 创建 XPath 对象
    XPath xPath = factory.newXPath();
    // 编译 XPath 表达式
    XPathExpression expr = xPath.compile("//book[author='Neal Stephenson']/title/text()");
    // 通过 XPath 表达式得到结采，第一个参数指定了 XPath 表达式进行查询的上下文节点，也就是在指定
    // 节点下查找符合 XPath 的节点。 本例中的上下文节点是整个文档；第二个参数指定了 XPath 表达式
    // 的返回类型。
    Object result = expr.evaluate(doc, XPathConstants.NODESET);
    System.out.println("查询作者为 Neal Stephenson 的图书的标题：");
    NodeList nodes= (NodeList) result;
    // 强制类型转换
    for (int i = 0; i < nodes.getLength() ; i++) {
        System.out.println(nodes.item(i).getNodeValue());
    }

    System.out.println("查询1997年之后的图书的标题：");
    nodes = (NodeList)xPath.evaluate( " //book[@year>1997] /title/text ()", doc , XPathConstants.NODESET);
    for(int i  = 0; i < nodes.getLength();i++){
        System. out.println(nodes.item(i).getNodeValue());
    }

    System.out.println("查询 1997 年之后的图书的属性和标题：");
    nodes = (NodeList)xPath.evaluate("//book [@year>1997] /@*|//book [@year>1997] /title/text()", doc , XPathConstants. NODESET);
    for (int i  = 0; i < nodes.getLength(); i++) {
        System. out. println (nodes.item(i).getNodeValue());
    }
}
```

XPathExpression.evaluate（）方法的第二参数，它指定了 XP础 表达式查找的结果类型， 在 XPathConstants 类中提供了 nodeset、 boolean、 number、 string 和 Node 五种类型。 如果XPath表达式只使用一次， 可以跳过编译步骤直接调用 XPath 对象的 evaluate()。方法进行查询。但是如果同一个 XPath 表达式要重复执行多次，则建议先进行编译，然后进行查询，这样性能会好一点。

###  XPathParser

MyBatis 提供的 XPathParser 类封装了前面涉及的 XPath、 Document 和 EntityResolver。XPathParser 中各个字段的含义和功能如下所示：

```java
// Document对象
private final Document document;
// 是否开启验证
private boolean validation;
// 用于加载本地的DTD文件
private EntityResolver entityResolver;
// Mbatis-config.xml 中<propteries>标签定义的键位对集合
private Properties variables;
// XPath对象
private XPath xpath;
```

默认情况下，对 XML 文档进行验证时，会根据 XML 文档开始位置指定的网址加载对应的 DTD 文 件或 XSD 文件 。如果解析 mybatis-config.xml 配置文件，默认联网加载 http://mybatis.org/dtd/mybatis-3-config.dtd 这个DTD 文档，当网络比较慢时会导致验证过程缓慢。在实践中往往会提前设置 EntityResolver 接口对象加载本地的 DTD 文件，从而避免联网加载DTD 文件。

XMLMapperEntityResolver 是 MyBatis 提供的 EntityResoIver 接口的实现类。EntityResolver接口的核心是 resolveEntity()方法， XMLMapperEntityResolver 的实现如下所示：

```java
// 指定mybatis-config.xm文件和映射文件对反的DTD的SystemId 
private static final String IBATIS_CONFIG_SYSTEM = "ibatis-3-config.dtd";
private static final String IBATIS_MAPPER_SYSTEM = "ibatis-3-mapper.dtd";
private static final String MYBATIS_CONFIG_SYSTEM = "mybatis-3-config.dtd";
private static final String MYBATIS_MAPPER_SYSTEM = "mybatis-3-mapper.dtd";

// 指定mybatis-config.xm 文件和映射文件对应的 DTD 文件的具体位置
private static final String MYBATIS_CONFIG_DTD = "org/apache/ibatis/builder/xml/mybatis-3-config.dtd";
private static final String MYBATIS_MAPPER_DTD = "org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd";

public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
  try {
    if (systemId != null) {
      String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);
      // 查找systemId指定的DTD文档，并调用 getinputSource()方法读取DTD文档
      if (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) {
        return getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);
      } else if (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM)
          || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) {
        return getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);
      }
    }
    return null;
  } catch (Exception e) {
    throw new SAXException(e.toString());
  }
}
```

在 XPathParser.createDocument()方法中封装了前面介绍的创建Document对象的过程并触发了加载XML文挡的 过程，具体实现如下：

```java
private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) {
  this.validation = validation;
  this.entityResolver = entityResolver;
  this.variables = variables;
  XPathFactory factory = XPathFactory.newInstance();
  this.xpath = factory.newXPath();
}

private Document createDocument(InputSource inputSource) {
    // 调用 createDocument()方法之前一定要先调用 commonConstructor 
    try {
        // 创建DocumentBuilderFactory对象
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setValidating(validation);

        factory.setNamespaceAware(false);
        factory.setIgnoringComments(true);
        factory.setIgnoringElementContentWhitespace(false);
        factory.setCoalescing(false);
        factory.setExpandEntityReferences(true);
        
        // 创建DocumentBuilder对象并进行自己置
        DocumentBuilder builder = factory.newDocumentBuilder();
        // 设置EntityResolver接口对象
        builder.setEntityResolver(entityResolver);
        builder.setErrorHandler(new ErrorHandler() {
            @Override
            public void error(SAXParseException exception) throws SAXException {
                throw exception;
            }

            @Override
            public void fatalError(SAXParseException exception) throws SAXException {
                throw exception;
            }

            @Override
            public void warning(SAXParseException exception) throws SAXException {
                // NOP
            }
        });
        // 加载 XML 文件
        return builder.parse(inputSource);
    } catch (Exception e) {
        throw new BuilderException("Error creating document instance.  Cause: " + e, e);
    }
}
```

XPathParser 中提供了一系列的 eval*()方法用于解析 boolean、 short、 long、 int、 String、 Node 等类型的信息，它通过调用前面介绍的 XPath.evaluate()方法查找指定路径的节点或属性，并进行相应的类型装换 。XPatharser.eva!String()方法，其中会调用PropertyParser. parse()方法处理节点中相应的默认值。 具体实现如下： 

```java
public String evalString(Object root, String expression) {
  String result = (String) evaluate(expression, root, XPathConstants.STRING);
  result = PropertyParser.parse(result, variables);
  return result;
}

private Object evaluate(String expression, Object root, QName returnType) {
    try {
        return xpath.evaluate(expression, root, returnType);
    } catch (Exception e) {
        throw new BuilderException("Error evaluating XPath.  Cause: " + e, e);
    }
}
```

### PropertyParser

在 ProperyParser中指定了是否开启使用默认值的功能以及默认的分隔符，相关字段如下所示。 

```java

private static final String KEY_PREFIX = "org.apache.ibatis.parsing.PropertyParser.";
// 在 mybatis-config.xml中<properties>节点下自己置是否开启默认值功能的对应配置项 
public static final String KEY_ENABLE_DEFAULT_VALUE = KEY_PREFIX + "enable-default-value";
// 配置占位符与默认值之间的默认分隔符的对应配置项
public static final String KEY_DEFAULT_VALUE_SEPARATOR = KEY_PREFIX + "default-value-separator";
// 默认情况下，关闭默认值的功能 
private static final String ENABLE_DEFAULT_VALUE = "false";
// 默认分隔符是冒号
private static final String DEFAULT_VALUE_SEPARATOR = ":";
```

Property Parser. parse()方法中会创建GenericTokenParser解析器，井将默认值的处理委托给GenericTokenParser.parse()方法，实现如下：

```java
public static String parse(String string, Properties variables) {
  VariableTokenHandler handler = new VariableTokenHandler(variables);
  // 创建GenericTokenParser 对象，并指定其处理的占位符格式为"${}"
  GenericTokenParser parser = new GenericTokenParser("${", "}", handler);
  return parser.parse(string);
}
```

### GenericTokenParser

GenericTokenParser 是一个通用的宇占位符解析器，其宇段的含义如下：

```java
// 占位符的开始标识
private final String openToken;
// 占位符的结束标记
private final String closeToken;
// TokenHandler接口的实现会按照一定的逻辑解析占位符
private final TokenHandler handler;
```

GenericTokenParser . parse()方法的逻辑并不复杂，它会顺序查找 openToken 和 closeToken, 解析得到占位符的字面值，并将其交给 TokenHandler 处理， 然后将解析结果重新拼装成字符串并返回。该方法的实现如下：

```java
public String parse(String text) {
  // 校验text是否为空
  if (text == null || text.isEmpty()) {
    return "";
  }
  // 查找开始标记
  int start = text.indexOf(openToken);
  if (start == -1) {
    return text;
  }
  char[] src = text.toCharArray();
  int offset = 0;
  // 记录解析后的字符串
  final StringBuilder builder = new StringBuilder();
  // 用来记录一个占位符的字面值
  StringBuilder expression = null;
  do {
    if (start > 0 && src[start - 1] == '\\') {
      // 遇到转义的开始标记，则直接将前面的字符串以及开始标记追加到 builder 中.
      builder.append(src, offset, start - offset - 1).append(openToken);
      offset = start + openToken.length();
    } else {
      // 查找到开始标记，且未转义
      if (expression == null) {
        expression = new StringBuilder();
      } else {
        expression.setLength(0);
      }
      // 将前面的字符串追加到 builder 中 
      builder.append(src, offset, start - offset);
      // 修改 offset 的位置 
      offset = start + openToken.length();
      // 从 offset 向后继续查找结束标记 
      int end = text.indexOf(closeToken, offset);
      while (end > -1) {
        if (end > offset && src[end - 1] == '\\') {
          // 处理转义的结束标记 
          expression.append(src, offset, end - offset - 1).append(closeToken);
          offset = end + closeToken.length();
          end = text.indexOf(closeToken, offset);
        } else {
          // 将开始标记和结束标记之间的字符串追加到 expression 中保存 
          expression.append(src, offset, end - offset);
          break;
        }
      }
      if (end == -1) {
        // 未找到结束标记
        builder.append(src, start, src.length - start);
        offset = src.length;
      } else {
        // 将占位符的字面值交给TokenHandler处理，并将处理结果追加到builder中保存。
        // 最终拼凑出解析后的完整内容
        builder.append(handler.handleToken(expression.toString()));
        offset = end + closeToken.length();
      }
    }
    // 移动 start 
    start = text.indexOf(openToken, offset);
  } while (start > -1);
  if (offset < src.length) {
    builder.append(src, offset, src.length - offset);
  }
  return builder.toString();
}
```

### VariableTokenHandler

占位符由 TokenHandler 接口的实现进行解析， TokenHandler 接口总共有四个实现：

![image-20230227152340043](TokenHandler 接口实现.png)

通过对 PropertyParser. parse()方法的介绍，我们知道 PropertyParser 是使用 VariableTokenHandler 与 GenericTokenParser 配合完成占位符解析的。VariableTokenHandler 是 PropertyParser中的一个私有静态内部类，其字段的含义如下：

```java
// <Properties>节点下定义的键位对，用于替换占位符
private final Properties variables;
// 支持占位符中使用默认值的功能
private final boolean enableDefaultValue;
// 占位符和默认值之间的分隔符
private final String defaultValueSeparator;
```

VariableTokenHandler 实现了 TokenHandler 接口中的 handleToken()方法，该实现首先会按照 defaultValueSeparator 宇段指定的分隔符对整个占位符切分， 得到占位符的名称和默认值，然后 按照切分得到的占位符名称查找对应的值， 如果在＜properties＞节点下未定义相应的键值对，则 将切分得到的默认值作为解析结果返回。

```java
public String handleToken(String content) {
    // 检测不为空
    if (variables != null) {
      String key = content;
      // 测是否支持占位符中使用默认键的功能
      if (enableDefaultValue) {
        final int separatorIndex = content.indexOf(defaultValueSeparator);
        String defaultValue = null;
        if (separatorIndex >= 0) {
          // 获取占位符的名称
          key = content.substring(0, separatorIndex);
          // 获取默认值
          defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());
        }
        if (defaultValue != null) {
          // 在 variables 集合中查找指定的占位符 
          return variables.getProperty(key, defaultValue);
        }
      }
      // 不支持默认值的功能， 则直接查找variables 集合
      if (variables.containsKey(key)) {
        return variables.getProperty(key);
      }
    }
    // 为空时，原样返回
    return "${" + content + "}";
  }
}
```

需要注意的是， GenericTokenParser 不仅仅用于这里的默认值解析，还会用于后面对动态SQL 语句的解析。很明显， GenericTokenParser 只是查找到指定的占位符， 而具体的解析行为会根据其持有的 TokenHandler 实现的不同而有所不同。

XPathParser.evalNode()方法返回值类型是 XNode，它对org.w3c.dom.Node 对象做了封装和解析，其各个字段的含义如下： 

```java
// org.w3c.dorn.Node 对象
private final Node node;
// Node 节点名称
private final String name;
// 节点的内容
private final String body;
// 节点属性集合 
private final Properties attributes;
// rnybatis-config.xrnl 配置文件中<properties>节点下定义的键位对 
private final Properties variables;
// 前面介绍的XPathParser对象，该XNode对象由此XPathParser对象生成
private final XPathParser xpathParser;
```

XNode 的构 造函数中会调用其 parseAttributes()方法和 parseBody()方法解析，org.w3c.dom.Node 对象中的信息，初始化 attributes 集合和 body 字段，具体初始化过程如下：

```java
private Properties parseAttributes(Node n) {
    Properties attributes = new Properties();
    // 获取节点的属性集合
    NamedNodeMap attributeNodes = n.getAttributes();
    if (attributeNodes != null) {
        for (int i = 0; i < attributeNodes.getLength(); i++) {
            Node attribute = attributeNodes.item(i);
            // 使用 PropertyParser 处理每个属性中的占位符
            String value = PropertyParser.parse(attribute.getNodeValue(), variables);
            attributes.put(attribute.getNodeName(), value);
        }
    }
    return attributes;
}

private String parseBody(Node node) {
    String data = getBodyData(node);
    // 前节点不是文本节点
    if (data == null) {
        // 处理子节点
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            data = getBodyData(child);
            if (data != null) {
                break;
            }
        }
    }
    return data;
}

private String getBodyData(Node child) {
    // 只处理文本内容
    if (child.getNodeType() == Node.CDATA_SECTION_NODE || child.getNodeType() == Node.TEXT_NODE) {
        String data = ((CharacterData) child).getData();
        // 使用 PropertyParser 处理文本节点中的占位符
        data = PropertyParser.parse(data, variables);
        return data;
    }
    return null;
}
```

XNode 中提供了多种 get＊()方法获取所需的节点信息，这些信息主要来自上面介绍的attribute 集合、 body 宇段、 node字段。可以使用 XNode.eval＊()方法结合 XPath 查询需要的信息， eval*()系列方法是通过调用其封装的 XPathParser 对象的 eval＊()方法实现的。这里要注意的是， eval＊()系列方法的上下 文节点是当前的XNode.node，也就是查找该节点下的符合 XPath 表达式的信息。

## 反射模块

MyBatis提供了专门的反射模块，该模块位于 org.apache.ibatis.reflection 包中，它对常见的反射操作做了进一步封装，提供了更加简洁方便的反射 API。

### Rflector

Reflector是MyBatis中反射模块的基础，每个Reflector对象都对应一个类，在 Reflector中缓存了反射操作需要使用的类的元信息。Reflector中各个字段的含义如下：

```java
// 获取方法句柄
private static final MethodHandle isRecordMethodHandle = getIsRecordMethodHandle();
// 应的 Class 类型
private final Class<?> type;
// 可读属性的名称集合，可读属性就是存在相应 getter 方法的属性，初始值为空数纽
private final String[] readablePropertyNames;
// 可写属性的名称集合，可写属性就是存在相应 setter 方法的属性，初始值为空数纽
private final String[] writablePropertyNames;
//记录了属性相应的setter方法，key 是属性名称，value是Invoker对象，它是对setter方法对应Method对象的封装
private final Map<String, Invoker> setMethods = new HashMap<>();
// 属性相应的 getter 方法集合，key是属性名称，value也是Invoker对象
private final Map<String, Invoker> getMethods = new HashMap<>();
// 记录了属性相应的 setter 方法的参数值类型， key 是属性名称， value 是 setter 方法的参数类型
private final Map<String, Class<?>> setTypes = new HashMap<>();
// 记录了属性相应的 getter 方法的返回位类型， key 是属性名称， value 是 getter 方法的返回位类型
private final Map<String, Class<?>> getTypes = new HashMap<>();
// 记录了默认构造方法
private Constructor<?> defaultConstructor;
// 记录了所有属性名称的集合
private Map<String, String> caseInsensitivePropertyMap = new HashMap<>();
```

在 Reflector 的构造方法中会解析指定的 Class 对象，并填充上述集合，具体实现如下：

```java
public Reflector(Class<?> clazz) {
  // 始化 type 字段
  type = clazz;
  // 查找 clazz 的默认构造方法（元参构造方法）， 具体实现是通过反射遍历所有构造方法，
  addDefaultConstructor(clazz);
  Method[] classMethods = getClassMethods(clazz);
  if (isRecord(type)) {
    addRecordGetMethods(classMethods);
  } else {
    // 处理clazz中的getter方法，填充 getMethods 集合和 getTypes 集合
    addGetMethods(classMethods);
    // 处理clazz中的setter方法，填充setMethods集合和setTypes集合
    addSetMethods(classMethods);
    // 处理没有getter/setter方法的字段
    addFields(clazz);
  }
  // 根据 getMethods/setMethods 集合，初始化可读／写属性的名称集合
  readablePropertyNames = getMethods.keySet().toArray(new String[0]);
  writablePropertyNames = setMethods.keySet().toArray(new String[0]);
  // 初始化 caseinsensitivePropertyMap 集合，其中记录了所有大写格式的属性名称
  for (String propName : readablePropertyNames) {
    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
  }
  for (String propName : writablePropertyNames) {
    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
  }
}
```

Reflector.addGetMethods()方法主要负责解析类中定义的 getter 方法， Reflector.addSetMethods()方法负责解析类中定义的 se忧er 方法，两者的逻辑类似，这里以 addGetMethods()方法为例进行介绍。Reflector.addGetMethods()方法有如下三个核心步骤。

1. 首先，调用Reflector.getClassMethods()方法获取当前类以及其父类中定义的所有方法的唯一签名以及相应的Method 对象。

```java
private Method[] getClassMethods(Class<?> clazz) {
  // 用于记录指定类中定义的全部方法的唯一签名以及对应的 Method 对象
  Map<String, Method> uniqueMethods = new HashMap<>();
  Class<?> currentClass = clazz;
  while (currentClass != null && currentClass != Object.class) {
    // 记录 currentClass 这个类中定义的全部方法
    addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());
    // 记录接口中定义的方法
    Class<?>[] interfaces = currentClass.getInterfaces();
    for (Class<?> anInterface : interfaces) {
      addUniqueMethods(uniqueMethods, anInterface.getMethods());
    }
    // 取父类，继续 while 循环
    currentClass = currentClass.getSuperclass();
  }
  Collection<Method> methods = uniqueMethods.values();
  // 换成 Methods 数组返回
  return methods.toArray(new Method[0]);
}
```

在Reflector.addUniqueMethods()方法中会为每个方法生成唯 一签名，井记录到uniqueMethods 集合中，具体实现如下：

```java
private void addUniqueMethods(Map<String, Method> uniqueMethods, Method[] methods) {
  for (Method currentMethod : methods) {
    if (!currentMethod.isBridge()) {
      // 通过 Reflector.getSignature()方法得到的方法签名是：返回值类型＃方法名称：参
      // 数类型列表。 例如， Reflector.getSignature(Method）方法的唯一签名是： 
      // java.lang.String#getSignature: ] ava.lang.reflect.Method
      // 通过 Reflector.getSignature()方法得到的方法签名是全局唯一的，可以作为该方法的唯一标识
      String signature = getSignature(currentMethod);
      // 检测是否在子类中已经添加过该方法，如果在子类中已经添加过，则表示子类覆盖了该方法， 
      // 无须再向uniqueMethods集合中添加该方法了 
      if (!uniqueMethods.containsKey(signature)) {
        uniqueMethods.put(signature, currentMethod);
      }
    }
  }
}
```

2. 按照 JavaBean 的规范，从 Reflector.getClassMethods()方法返回的 Method 中查找该类中定义的 getter 方法，将其记录到 conflictingGetters 集合中。 conflictingGetters 集合（HashMap<String， List<Method＞()类型） 的 key 为属性名称， value 是该属性对应的 getter 方法集合。 

3. 当子类覆盖了父类的getter方法且返回值发生变化时，在步骤 l 中就会产生两个签名不同的方法。 例如现有类 A 及其子类 SubA, A 类中定义了 getNames()方法，其返回值类型是List<String＞ ， 而在其子类 SubA 中， 覆写了其getNames()方法且将返回值修改成 ArrayList<String>类型，这种覆写在 Java 语言中是合法的。最终得到的两个方法签名分别是 java.util.List#getNames和java.util.ArrayList#getNames，在Reflector.addUniqueMethods()方法中会被认为是两个不同的方法并添加到 uniqueMethods 集合中。但是在某些情况下，只需要子类覆盖的的方法，所以需要调用Reflector.resolveGetterConflicts()方法对这种覆写进行处理，同时会将处理得到的 getter 方法记录到 getMethods 集合，并将其返回值类型填充到 getTypes 集合。 Reflector.resolveGetterConflicts()方法的具体实现如下： 

   ```java
     /**
      *
      * 解决Getter冲突
      * 根据JavaBeans的规范，检验POJO是否按照规范，且取出最优的getter/setter方法，没有找到的话，会抛出异常。
      */
   private void resolveGetterConflicts(Map<String, List<Method>> conflictingGetters) {
     // 遍历 conflictingGetters 集合
     for (Entry<String, List<Method>> entry : conflictingGetters.entrySet()) {
       Method winner = null;
       String propName = entry.getKey();
       boolean isAmbiguous = false;
       for (Method candidate : entry.getValue()) {
         if (winner == null) {
           winner = candidate;
           continue;
         }
         Class<?> winnerType = winner.getReturnType();
         Class<?> candidateType = candidate.getReturnType();
         if (candidateType.equals(winnerType)) {
           if (!boolean.class.equals(candidateType)) {
             // 当返回值不为boolean的iser方法又有getter时，会被抛出异常
             isAmbiguous = true;
             break;
           } else if (candidate.getName().startsWith("is")) {
             // 属于is...
             winner = candidate;
           }
         } else if (candidateType.isAssignableFrom(winnerType)) {
           // 属于继承关系
         } else if (winnerType.isAssignableFrom(candidateType)) {
           // 属于继承关系
           winner = candidate;
         } else {
           //当发现属性存在一个getter和一个iser的时候，两个方法返回值类型不一样，也没有继承关系，就会抛出异常
           isAmbiguous = true;
           break;
         }
       }
       addGetMethod(propName, winner, isAmbiguous);
     }
   }
   
   private void addGetMethod(String name, Method method, boolean isAmbiguous) {
       MethodInvoker invoker = isAmbiguous ? new AmbiguousMethodInvoker(method, MessageFormat.format(
           "Illegal overloaded getter method with ambiguous type for property ''{0}'' in class ''{1}''. This breaks the JavaBeans specification and can cause unpredictable results.",
           name, method.getDeclaringClass().getName())) : new MethodInvoker(method);
       // 将属性名以及对应的 Methodinvoker 对象添加Ji] getMethods 集合中，
       getMethods.put(name, invoker);
       // 获取~回佳的 Type,
       Type returnType = TypeParameterResolver.resolveReturnType(method, type);
       // 将属性名称及其 getter 方法的返回位类型添加到 getTypes 集合中保存，
       getTypes.put(name, typeToClass(returnType));
   }
   ```

Reflector.addGetMethods()方法的三个核心步骤的具体实现：

```java
public Reflector(Class<?> clazz) {
    type = clazz;
    addDefaultConstructor(clazz);
    // 步骤 l： 获取指定类以及其父类和接口中定义的方法
    Method[] classMethods = getClassMethods(clazz);
    if (isRecord(type)) {
        addRecordGetMethods(classMethods);
    } else {
        addGetMethods(classMethods);
        addSetMethods(classMethods);
        addFields(clazz);
    }
    readablePropertyNames = getMethods.keySet().toArray(new String[0]);
    writablePropertyNames = setMethods.keySet().toArray(new String[0]);
    for (String propName : readablePropertyNames) {
        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
    for (String propName : writablePropertyNames) {
        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
}

private void addGetMethods(Method[] methods) {
  // conflictingGetters 集合的 key 为属性名称， value 是相应 getter 方法集合，因为子类可能覆盖父 
  // 类的 getter 方法，所以同一属性名称可能会存在多个 getter 方法
  Map<String, List<Method>> conflictingGetters = new HashMap<>();
  // 步骤 2：按照 JavaBean 规范查找 getter 方法，并记录到 conflictingGetters 集合中
  Arrays.stream(methods).filter(
      // JavaBean 中 getter 方法的方法名长度大于 3 且必须以”get”开头
      m -> m.getParameterTypes().length == 0 && PropertyNamer.isGetter(m.getName()))
      .forEach(
      // 按照 JavaBean 的规范，获取对应的属性名称,将属性名与 getter 方法的反射关系记录在 conflictingGetters 集合中 
      m -> addMethodConflict(conflictingGetters,PropertyNamer.methodToProperty(m.getName()), m));
  // 步骤 3：对 conflictingGetters 集合进行处理
  resolveGetterConflicts(conflictingGetters);
}
```

Reflector.addFields()方法会处理类中定义的所有字段 ， 并且将处理后的字段信息添加到setMethods 集合、setTypes 集合、 getMethods 集合以及 getTypes 集合中，这一点与上述的Reflector.addGetMethods（）方法是一致的 。 Reflector.addFields()方法的具体实现如下： 

```java
private void addFields(Class<?> clazz) {
  // 获取 clazz 中定义的全部字段
  Field[] fields = clazz.getDeclaredFields();
  for (Field field : fields) {
    // 当 setMethods 集合不包含同名属性时，将其记录到 setMethods 集合和 setTypes 集合
    if (!setMethods.containsKey(field.getName())) {
      // 删除了final的检查，因为JDK1.5允许通过反射修改final字段。final静态只能由类加载器设置
      // 过滤掉final和static修饰的字段
      int modifiers = field.getModifiers();
      if (!(Modifier.isFinal(modifiers) && Modifier.isStatic(modifiers))) {
        // addSetField()方法的主要功能是填充setMethods集合和setypes集合,与addGetMethod()方法类似
        addSetField(field);
      }
    }
    //  getMethods 集合中不包含同名属性时，将其记录到 getMethods 集合和 getTypes 集合 
    if (!getMethods.containsKey(field.getName())) {
      addGetField(field);
    }
  }
  if (clazz.getSuperclass() != null) {
    // 处理父类中定义的字段 
    addFields(clazz.getSuperclass());
  }
}
```

还有一点需要注意的是， add * Method()方法和 add*Field()方法在向上述集合添加元素时，会将 getter/setter 方法对应的 Method 对象以及字段对应的 Field 对象统一封装成 Invoker 对象。 Invoker 接口的定义如下所示。

```java
public interface Invoker {
  // 调用获取指定字段的值或执行指定的方法
  Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException;
  // 回属性相应的类型
  Class<?> getType();
}
```

GetFieldlnvoker/SetFieldlnvoker通过field字段封装了对应的 Field 对象，两者的 invoke()方 法是通过调用 Field.get()/set()方法实现的。 Methodlnvoker 通过 method 宇段封装了对应方法的 Method 对象，其 invoke()方法是通过调用 Method.invoke()方法实现。

### ReflectorFactory 

ReflectorFactory 接口主要实现了对 Reflector 对象的创建和缓存，该接口定义如下： 

```java
public interface ReflectorFactory {
  
  // 测该 ReflectorFactory 对象是否会缓存 Reflector 对象 
  boolean isClassCacheEnabled();

  // 置是否缓存 Reflector 对象
  void setClassCacheEnabled(boolean classCacheEnabled);

  // 建指定 Class 对应的 Reflector 对象
  Reflector findForClass(Class<?> type);
}
```

![image-20230228101905455](ReflectorFactory 类实现图.png)

DefaultReflectorFactory 中字段的含义如下： 

```java
// 该字段决定是否开启对Reflector对象的缓存
private boolean classCacheEnabled = true;
// 使用 ConcurrentMap 集合实现对 Reflector 对象的缓存 
private final ConcurrentMap<Class<?>, Reflector> reflectorMap = new ConcurrentHashMap<>();
```

DefaultReflectorFactory提供的 findForClass()方法实现会为指定的 Class 创建 Reflector对象， 并将 Reflector 对象缓存到 reflectorMap 中， 具体代码如下： 

```java
public Reflector findForClass(Class<?> type) {
  // 检测是否开启缓存
  if (classCacheEnabled) {
    // 创建 Reflector 对象，放入 ConcurrentMap 中缓存 
    return MapUtil.computeIfAbsent(reflectorMap, type, Reflector::new);
  } else {
    return new Reflector(type);
  }
}
```

**可自定义，用于对类进行加密**。

### TypeParameterResolver

Type 是所有类型的父接口，它有四个子接口和一个实现类：

![image-20230228105052610](Type 相关实现接口.png)

- Class比较常见，它表示的是原始类型。Class类的对象表示NM中的一个类或接口，每个Java类在NM里都表现为一个Class对象。在程序中可以通过“类名.class”、“对象.getClass()”或是 "Class.forName("类名")"等方式获取Class对象。数组也被映射为Class对象，所有元素类型相同且维数相同的数组都共享同一个Class对象。

- ParameterizedType表示的是参数化类型，例如List<String＞、Map<Integer,String＞、Service<User＞这种带有泛型的类型。ParameterizedType接口中常用的方法有三个，分别是： 

  - Type getRawType（）一一返回参数化类型中的原始类型，例如List<String＞的原始类型为List。
  - Type[] getActualTypeArguments（）一一获取参数化类型的类型变量或是实际类型列表，例如Map<Integer,String＞的实际泛型列表Integer和String。需要注意的是，该列表的元素类型都是Type，也就是说，可能存在多层嵌套的情况。
  - Type getOwnerType（）一一返回是类型所属的类型，例如存在A<T>类，其中定义了内部类lnnerA<l＞，则InnerA<l＞所属的类型为A<T＞，如果是顶层类型则返回null。这种关系比较常见的示例是Map<K,V＞接口与Map.En盯＜K,V＞接口，Map<K,V>接口是Map.Entry＜K,V＞接口的所有者。

- TypeVariable表示的是类型变量，它用来反映在NM编译该泛型前的信息。例如List<T>中的T就是类型变量，它在编译时需被转换为一个具体的类型后才能正常使用。该接口中常用的方法有三个，分别是：

  - Type[] getBounds（）一一获取类型变量的上边界，如果未明确声明上边界则默认为Object。例如class Test<K extends Person＞中K的上界就是Person。

  - DgetGenericDeclaration（）一一获取声明该类型变量的原始类型，例如class Test<K extends Person＞中的原始类型是Test。 

  - String getNameO一一获取在源码中定义时的名字，上例中为K。

- GenericArrayType表示的是数组类型且组成元素是ParameterizedType或TypeVariable. 例如 List<String＞[]或 T[]。该接口只有 Type getGenericComponentType()一个方法，它返回数组的组成元素。
- WildcardType表示的是通配符泛型，例如:extends Number和？super Integer。WildcardType接口有两个方法，分别是： 
  - Type[] getUpperBounds()一一返回泛型变量的上界。 
  - Type[] getLowerBounds()一一返回泛型变量的下界。

TypeParameterResolver的身影，它是一个工具类，提供了一系列静态方法来解析指定类中的宇段、方法返回值或方法参数的类型。TypeParameterResolver中通过 resolveFieldType()方法、resolveReturnType()方法、 resolveParamTypes()方法分别解析宇段类型、方法返回值类型和方法参数列表中各个参数的类型。这三个方法的逻辑基本类似，这里以 resolveFieldType()方法为例进行介绍：

```java
public static Type resolveFieldType(Field field, Type srcType) {
  // 字段的声明类型
  Type fieldType = field.getGenericType();
  // 获取字段定义所在的类的 Class对象 
  Class<?> declaringClass = field.getDeclaringClass();
  // 调用 resolveType()方法进行后续处理
  return resolveType(fieldType, srcType, declaringClass);
}
```

上述三个方法都会调用 resolveType()方法， 该方法会根据其第一个参数的类型， 即字段、方法返回值或方法参数的类型，选择合适的方法进行解析。第二个参数表示查找该字段、返回值或方法参数的起始位置。第三个参数则表示该字段、 方法定义所在的类。 TypeParameterResolver.resolveType()方法代码如下：

```java
private static Type resolveType(Type type, Type srcType, Class<?> declaringClass) {
  if (type instanceof TypeVariable) {
    // TypeVariable 类型
    return resolveTypeVar((TypeVariable<?>) type, srcType, declaringClass);
  } else if (type instanceof ParameterizedType) {
    // ParameterizedType 类型
    return resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);
  } else if (type instanceof GenericArrayType) {
    // GenericArrayType 类型
    return resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);
  } else {
    return type;
  }
}
```

字段声明的类型Map<K,V＞是Parameterized Type类型， resolveType()方法会调用resolveParameterizedType()方法进行解析。resolveParameterizedType（）方法的参数： 

- 第一个参数是待解析的 ParameterizedType 类型； 
- 第二个参数是解析操作的起始类型：
- 第三个参数为定义该字段或方法的类的 Class 对象。

TypeParameterResolver.resolveParameterizedType()方法代码如下：

```java
private static ParameterizedType resolveParameterizedType(ParameterizedType parameterizedType, Type srcType,
    Class<?> declaringClass) {
  // 得到原始类型对应的 Class 对象 
  Class<?> rawType = (Class<?>) parameterizedType.getRawType();
  // 型交量为 K 和 V
  Type[] typeArgs = parameterizedType.getActualTypeArguments();
  // 保存解析后的结果
  Type[] args = new Type[typeArgs.length];
  for (int i = 0; i < typeArgs.length; i++) {
    // 解析K和V
    if (typeArgs[i] instanceof TypeVariable) {
      // 解析类型变量
      args[i] = resolveTypeVar((TypeVariable<?>) typeArgs[i], srcType, declaringClass);
    } else if (typeArgs[i] instanceof ParameterizedType) {
      // 如果嵌套了 ParameterizedType，则调用 resolveParameterizedType （）方法进行处理
      args[i] = resolveParameterizedType((ParameterizedType) typeArgs[i], srcType, declaringClass);
    } else if (typeArgs[i] instanceof WildcardType) {
      // 如采嵌套了 WildcardType，则调用 resolveWildcardType （）方法进行处理
      args[i] = resolveWildcardType((WildcardType) typeArgs[i], srcType, declaringClass);
    } else {
      args[i] = typeArgs[i];
    }
  }
  // 将解析结果封装成 TypeParameterResolver 中定义的 ParameterizedType 实现并返回，本例中 args 
  // 数组中的元素都是 Long.class
  return new ParameterizedTypeImpl(rawType, null, args);
}
```

TypeParameterResolver.resolveTypeVar()方法负责解析 TypeVariable，一个参数是类型变量 K 对应的 TypeVariable 对象，第二个参数依然是 TypeText.SubA<Long＞对应的 ParameterizedType 对象，第三个参数是 ClassA （声明 map 字段的类）对应的 Class 对象。 TypeParameterResolver.resolveTypeVar()方法的具体实现如下：

```java
private static Type resolveTypeVar(TypeVariable<?> typeVar, Type srcType, Class<?> declaringClass) {
  Type result;
  Class<?> clazz;
  if (srcType instanceof Class) {
    clazz = (Class<?>) srcType;
  } else if (srcType instanceof ParameterizedType) {
    ParameterizedType parameterizedType = (ParameterizedType) srcType;
    clazz = (Class<?>) parameterizedType.getRawType();
  } else {
    throw new IllegalArgumentException(
        "The 2nd arg must be Class or ParameterizedType, but was: " + srcType.getClass());
  }

  if (clazz == declaringClass) {
    // 获取上界 
    Type[] bounds = typeVar.getBounds();
    if (bounds.length > 0) {
      return bounds[0];
    }
    return Object.class;
  }

  // 获取声明的父类类型。
  Type superclass = clazz.getGenericSuperclass();
  // 通过扫描父类进行后续解析，这是递归的入口
  result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superclass);
  if (result != null) {
    return result;
  }

  Type[] superInterfaces = clazz.getGenericInterfaces();
  for (Type superInterface : superInterfaces) {
    result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superInterface);
    if (result != null) {
      return result;
    }
  }
  // 若在整个继承结构中都没有解析成功，则返回 Object.class
  return Object.class;
}
```

scanSuperTypes()方法，该方法会递归整个继承结构井完成类型变量的解析。在该示例之中， 第一个参数是 K 对应的 TypeVariable 对象， 第二个参数是 TypeText.SubA<Long>对应的 ParameterizedType 对象， 第三个参数是 ClassA（声明 map 字段的类）对应的 Class 对象，第四个参数是 SubClassA 对应的 Class 对象，第五个参数是 Class<T,T>对应的 ParameterizedType对象。 scanSuperTypes()方法的具体实现如下： 

```java
private static Type scanSuperTypes(TypeVariable<?> typeVar, Type srcType, Class<?> declaringClass, Class<?> clazz,
    Type superclass) {
  if (superclass instanceof ParameterizedType) {
    ParameterizedType parentAsType = (ParameterizedType) superclass;
    // 查看原始的class
    Class<?> parentAsClass = (Class<?>) parentAsType.getRawType();
    // 原始类型中定义的变量
    TypeVariable<?>[] parentTypeVars = parentAsClass.getTypeParameters();
    if (srcType instanceof ParameterizedType) {
      parentAsType = translateParentTypeVars((ParameterizedType) srcType, clazz, parentAsType);
    }
    if (declaringClass == parentAsClass) {
      for (int i = 0; i < parentTypeVars.length; i++) {
        if (typeVar.equals(parentTypeVars[i])) {
          return parentAsType.getActualTypeArguments()[i];
        }
      }
    }
    if (declaringClass.isAssignableFrom(parentAsClass)) {
      // 继续解析父类，直到解析到定义该字段的类
      return resolveTypeVar(typeVar, parentAsType, declaringClass);
    }
  } else if (superclass instanceof Class && declaringClass.isAssignableFrom((Class<?>) superclass)) {
    // 声明的父类不再含有类型变量且不是定义该字段的类，则继续解析 
    return resolveTypeVar(typeVar, superclass, declaringClass);
  }
  return null;
}
```

scanSuperTypes()方法解析类型变量的核心逻辑。

![scanSuperTypes()方法逻辑解析](scanSuperTypes()方法逻辑解析.png)

resolveGenericArrayType()方法法，该方法负责解析 GenericArrayType 类型的变量，它会根据数组元素的类型选择合适的 resolve＊()方法进行解析， 具体实现如下： 

```java
private static Type resolveGenericArrayType(GenericArrayType genericArrayType, Type srcType,
    Class<?> declaringClass) {
  Type componentType = genericArrayType.getGenericComponentType();
  Type resolvedComponentType = null;
  // 根据数纽元素类型选择合适的方法进行解析
  if (componentType instanceof TypeVariable) {
    resolvedComponentType = resolveTypeVar((TypeVariable<?>) componentType, srcType, declaringClass);
  } else if (componentType instanceof GenericArrayType) {
    // 逆归调用 resolveGenericArrayType （） 方法
    resolvedComponentType = resolveGenericArrayType((GenericArrayType) componentType, srcType, declaringClass);
  } else if (componentType instanceof ParameterizedType) {
    resolvedComponentType = resolveParameterizedType((ParameterizedType) componentType, srcType, declaringClass);
  }
  // 根据解析后的数纽项类型构造返回类型
  if (resolvedComponentType instanceof Class) {
    return Array.newInstance((Class<?>) resolvedComponentType, 0).getClass();
  } else {
    return new GenericArrayTypeImpl(resolvedComponentType);
  }
}
```

当存在复杂的继承关系以及泛型定义时， TypeParameterResolver 可以帮助我们解析字段、 方法参数或方法返回值的类型，这是前面介绍的 Reflector 类的基础。

### ObjectFactory

该该接口提供了多个 create()方法的重载， 通过这些 create()方法可以创建指定类型的对象。 ObjectFactory 接口的定义如下：

```java
public interface ObjectFactory {

  /**
   * 设置配置信息
   *
   * @param properties
   *          configuration properties
   */
  default void setProperties(Properties properties) {
    // NOP
  }

  /**
   * 无参构造器创建指定类的对象
   *
   * @param <T>
   *          the generic type
   * @param type
   *          Object type
   *
   * @return the t
   */
  <T> T create(Class<T> type);

  /**
   * 根据参数列表，从指定类型中选择合适的构造器创建对象
   *
   * @param <T>
   *          the generic type
   * @param type
   *          Object type
   * @param constructorArgTypes
   *          Constructor argument types
   * @param constructorArgs
   *          Constructor argument values
   *
   * @return the t
   */
  <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs);

  /**
   * 检测指定类型是否为集合类型，主妥处理 java.util.Collection 及其子类
   *
   * @param <T>
   *          the generic type
   * @param type
   *          Object type
   *
   * @return whether it is a collection or not
   *
   * @since 3.1.0
   */
  <T> boolean isCollection(Class<T> type);

}
```

DefaultObjectFactory是MyBatis提供的 ObjectFactory接口的唯一实现，它是一个反射工厂， 其 create()方法通过调用 instantiateClass()方法实现。 DefaultObjectFactory.instantiateClass()方法会 根据传入的参数列表选择合适的构造函数实例化对象，具体实现如下：

```java
private <T> T instantiateClass(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
  try {
    Constructor<T> constructor;
    // 通过无参构造函数创建对象
    if (constructorArgTypes == null || constructorArgs == null) {
      constructor = type.getDeclaredConstructor();
      try {
        return constructor.newInstance();
      } catch (IllegalAccessException e) {
        if (Reflector.canControlMemberAccessible()) {
          constructor.setAccessible(true);
          return constructor.newInstance();
        } else {
          throw e;
        }
      }
    }
    // 根据指定的参数列表查找构造函数，并实例化对象
    constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(new Class[0]));
    try {
      return constructor.newInstance(constructorArgs.toArray(new Object[0]));
    } catch (IllegalAccessException e) {
      if (Reflector.canControlMemberAccessible()) {
        constructor.setAccessible(true);
        return constructor.newInstance(constructorArgs.toArray(new Object[0]));
      } else {
        throw e;
      }
    }
  } catch (Exception e) {
    String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList).stream()
        .map(Class::getSimpleName).collect(Collectors.joining(","));
    String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList).stream()
        .map(String::valueOf).collect(Collectors.joining(","));
    throw new ReflectionException("Error instantiating " + type + " with invalid types (" + argTypes + ") or values ("
        + argValues + "). Cause: " + e, e);
  }
}
```

### Property 工具集 

#### PropertyTokenizer

有如下映射规则：

```xml
<resultMap id="rrn4testProTool" type= "User"> 
    <id column= ”id” property= ” id”/> 
    <result property= ”orders[0].iterns[0].name” column= ”item1”/> 
    <result property=”orders[O].items[1].name” column= ”item2”/> 
    ......
</resultMap>
```

在上例中，“orders[O].items[O].name”这种由“．”和“［］”组成的表达式是由 PropertyTokenizer进行解析的。 PropertyTokenizer 中各宇段的含义如下：

```java
// 当前表达式的名称
private String name;
// 当前表达式的索引名
private final String indexedName;
// 索引下标
private String index;
// 子表达式
private final String children;
```

在PropertyTokenizer的构造方法中会对传入的表达式进行分析，并初始化上述字段， 具体实现如下：

```java
public PropertyTokenizer(String fullname) {
  // 查找"."的位置
  int delim = fullname.indexOf('.');
  if (delim > -1) {
    // 初始化name
    name = fullname.substring(0, delim);
    // 初始化children
    children = fullname.substring(delim + 1);
  } else {
    name = fullname;
    children = null;
  }
  // 初始化ndexedName
  indexedName = name;
  delim = name.indexOf('[');
  if (delim > -1) {
    // 初始化index
    index = name.substring(delim + 1, name.length() - 1);
    name = name.substring(0, delim);
  }
}
```

PropertyTokenizer继承了Iterator接口，它可以法代处理嵌套多层表达式。PropertyTokenizer.next()方法中会创建新的 PropertyTokenizer 对象并解析children宇段记录的子表达式。描述解析属性表达式 “orders[0].items[0].name”的迭代过程：

![image-20230302101619434](PropertyTokenizer表达式解析过程.png)

#### PropertyNamer

PropertyNamer是另一个工具类，提供了下列静态方法帮助完成方法名到属性名的转换，以及多种检测操作。 

```java
public final class PropertyNamer {

  private PropertyNamer() {
    // Prevent Instantiation of Static Class
  }

  // methodToProperty （）方法会将方法名转换成属性名 
  public static String methodToProperty(String name) {
    // 具体逻辑是将方法名开头的”iS”、 ”get”或”set”截掉，并将首字母小写
    if (name.startsWith("is")) {
      name = name.substring(2);
    } else if (name.startsWith("get") || name.startsWith("set")) {
      name = name.substring(3);
    } else {
      throw new ReflectionException(
          "Error parsing property name '" + name + "'.  Didn't start with 'is', 'get' or 'set'.");
    }

    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {
      name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);
    }

    return name;
  }

  // isProperty()方法负责检测方法名是否对应属性名 
  public static boolean isProperty(String name) {
    return isGetter(name) || isSetter(name);
  }

  public static boolean isGetter(String name) {
    return (name.startsWith("get") && name.length() > 3) || (name.startsWith("is") && name.length() > 2);
  }

  public static boolean isSetter(String name) {
    return name.startsWith("set") && name.length() > 3;
  }

}
```

#### PropertyCopier

PropertyCopier 是一个属性拷贝的工具类，其核心方法是 copyBeanProperties()方法， 主要实现相同类型的两个对象之间的属性值拷贝，具体实现如下：

```java
public static void copyBeanProperties(Class<?> type, Object sourceBean, Object destinationBean) {
  Class<?> parent = type;
  while (parent != null) {
    final Field[] fields = parent.getDeclaredFields();
    for (Field field : fields) {
      try {
        try {
          field.set(destinationBean, field.get(sourceBean));
        } catch (IllegalAccessException e) {
          if (Reflector.canControlMemberAccessible()) {
            field.setAccessible(true);
            // 将 sourceBean 对象中的属性值设直到 destinationBean 对象中
            field.set(destinationBean, field.get(sourceBean));
          } else {
            throw e;
          }
        }
      } catch (Exception e) {
        // Nothing useful to do, will only fail on final fields, which will be ignored.
      }
    }
    // 续拷贝父类中定义的字段
    parent = parent.getSuperclass();
  }
}
```

### MetaClass

MetaClass 通过 Reflector 和 PropertyTokenizer 组合使用， 实现了对复杂的属性表达式的解 析，并实现了获取指定属性描述信息的功能。 MetaClass 中各个字段的含义如下： 

```java
// 在创建MetaClass 时会指定一个类，该 Reflector 对象会用于记录该类相关的元信息
private final ReflectorFactory reflectorFactory;
// eflectorFactory 对象，用于缓存 Reflector 对象
private final Reflector reflector;
```

MetaClass 的构造函数中会为指定的 Class 创建相应的 Reflector 对象，井用其初始化MetaClass.reflector 字段，具体代码如下：

```java
// MetaClass 的构造方法是使用 private 修饰的
private MetaClass(Class<?> type, ReflectorFactory reflectorFactory) {
  this.reflectorFactory = reflectorFactory;
  // 创建Reflector对象
  this.reflector = reflectorFactory.findForClass(type);
}

// 使用静态方法创建MetaClass对象
public static MetaClass forClass(Class<?> type, ReflectorFactory reflectorFactory) {
  return new MetaClass(type, reflectorFactory);
}
```

MetaClass 中比较重要的是 findProperty()方法，它是通过调用 MetaClass. buildProperty()方法实现的，而 buildProperty()方法会通过PropertyTokenizer解析复杂的属性表达式，具体实现如下：

```java
public String findProperty(String name) {
  // 委托给buildProperty （）方法实现
  StringBuilder prop = buildProperty(name, new StringBuilder());
  return prop.length() > 0 ? prop.toString() : null;
}

private StringBuilder buildProperty(String name, StringBuilder builder) {
    // 解析属性表达式
    PropertyTokenizer prop = new PropertyTokenizer(name);
    // 是否还有子表达式
    if (prop.hasNext()) {
        // 查找 PropertyTokenizer.name 对应的属性
        String propertyName = reflector.findPropertyName(prop.getName());
        if (propertyName != null) {
            // 追加属性名
            builder.append(propertyName);
            builder.append(".");
            // 为该属性创建对应的 MetaClass 对象
            MetaClass metaProp = metaClassForProperty(propertyName);
            // 递归解析 PropertyTokenizer.children 字段，并将解析结果添加到 builder 中保存
            metaProp.buildProperty(prop.getChildren(), builder);
        }
    } else {
        // 递归出口
        String propertyName = reflector.findPropertyName(name);
        if (propertyName != null) {
            builder.append(propertyName);
        }
    }
    return builder;
}

public MetaClass metaClassForProperty(String name) {
    // 指定属性对应的 Class
    Class<?> propType = reflector.getGetterType(name);
    // 为该属性创建对应的 MetaClass 对象
    return MetaClass.forClass(propType, reflectorFactory);
}
```

MetaClass. findProperty()方法只查找“．”导航的属性，并没有检测下标。

MetaC!ass.hasGetter()和 hasSetter()方法负责判断属性表达式所表示的属性是否有对应的属性， 这两个方法逻辑类似，这里以 hasGetter()方法为例进行分析。两个方法最终 都 会查 找 Reflector.getMethods 集合或 setMethods 集合。Reflector.addFields()方法 ， 当字段没有对应 的 geter/setter 方法时会添加相应的 GetFieldlnvoker/SetFieldlnvoker 对象，所以 Reflector 有权限访问指定的字段时，这两个方法的 行为并不像其方法名所暗示 的那样 只直接判断属性的 getter/setter 方法。

```java
public boolean hasGetter(String name) {
  // 解析属性表达式
  PropertyTokenizer prop = new PropertyTokenizer(name);
  // 存在待处理的子表达式
  if (prop.hasNext()) {
    // PropertyTokenizer. narne 指定的属性有 getter 方法，才能处理子表达式
    if (reflector.hasGetter(prop.getName())) {
      // metaClassForProperty(String）方法的重载，
      MetaClass metaProp = metaClassForProperty(prop);
      return metaProp.hasGetter(prop.getChildren());
    } else {
      return false;
    }
  } else {
    return reflector.hasGetter(prop.getName());
  }
}
```

MetaClass.metaClassForProperty(PropertyTokenizer)方法底层会调用 MetaClass. getGetterType(PropertyTokenizer)方法， 针对 PropertyTokenizer 中是否包含索引信息做进一步处理，代码如下： 

```java
private MetaClass metaClassForProperty(PropertyTokenizer prop) {
  // 获取表达式所表示的属性的类型
  Class<?> propType = getGetterType(prop);
  return MetaClass.forClass(propType, reflectorFactory);
}

private Class<?> getGetterType(PropertyTokenizer prop) {
    // 获取属性类型
    Class<?> type = reflector.getGetterType(prop.getName());
    // 该表达式中是否使用” ［］ ”指定了下标， 且是 Collection 子类 
    if (prop.getIndex() != null && Collection.class.isAssignableFrom(type)) {
        // 通过 TypeParameterResolver 工具类解析属性的类型
        Type returnType = getGenericGetterType(prop.getName());
        if (returnType instanceof ParameterizedType) {
            // 获取实际参数类型
            Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments();
            if (actualTypeArguments != null && actualTypeArguments.length == 1) {
                // 泛型的类型
                returnType = actualTypeArguments[0];
                if (returnType instanceof Class) {
                    type = (Class<?>) returnType;
                } else if (returnType instanceof ParameterizedType) {
                    type = (Class<?>) ((ParameterizedType) returnType).getRawType();
                }
            }
        }
    }
    return type;
}

private Type getGenericGetterType(String propertyName) {
    try {
        // 根据 Reflector.getMethods 集合中记录的 Invoker 实现类的类型，决定解析 getter 方法返回值
        // 类型还是解析字段类型
        Invoker invoker = reflector.getGetInvoker(propertyName);
        if (invoker instanceof MethodInvoker) {
            Field declaredMethod = MethodInvoker.class.getDeclaredField("method");
            declaredMethod.setAccessible(true);
            Method method = (Method) declaredMethod.get(invoker);
            return TypeParameterResolver.resolveReturnType(method, reflector.getType());
        } else if (invoker instanceof GetFieldInvoker) {
            Field declaredField = GetFieldInvoker.class.getDeclaredField("field");
            declaredField.setAccessible(true);
            Field field = (Field) declaredField.get(invoker);
            return TypeParameterResolver.resolveFieldType(field, reflector.getType());
        }
    } catch (NoSuchFieldException | IllegalAccessException e) {
        // Ignored
    }
    return null;
}
```

通过一个示例分析 MetaClass.hasGetter（）方法的执行流程。假设现在通过orders[O].id 这个属性表达式， 检测 User 类中 orders 字段中的第一个元素（Order 对象）的 id 字段是否有 ge出r 方法，大致步骤如下：

1. 调用 MetaClass.forClass（）方法创建 User 对应的 MetaClass 对象并调用其 hasGeter()方法开始解析，经过 PropertyTokenizer 对属性表达式的解析后， Prope町Tokenizer 对象的 name值为 orders, indexName 为 orders[0], index 为 0, children 为 name。
2. 进入到 MetaClass.getGetterType()方法， 此时1处条件成立，调用 getGenericGetterType() 方法解析 orders 字段的类型， 得到 returnType 为 List<Order＞对应的 ParameterizedType 对象，此时条件2成立，更新 returnType 为 Order 对应的 Class 对象。
3. 继续检测 Order 中的 id 宇段是否有 getter 方法，具体逻辑同上

MetaClass 中有一个 public 修饰的 getGetterType(String）重载，其逻辑与 hasGetter() 类似，也是先对表达式进行解析 ， 然后调用 metaClassFor Property()方法或 getGetterType(PropertyTokenizer）方法进行下一步处理，代码如下：

```java
public Class<?> getGetterType(String name) {
  PropertyTokenizer prop = new PropertyTokenizer(name);
  if (prop.hasNext()) {
    MetaClass metaProp = metaClassForProperty(prop);
    return metaProp.getGetterType(prop.getChildren());
  }
  // issue #506. Resolve the type inside a Collection Object
  return getGetterType(prop);
}
```

MetaClass 中的其他 get*O方法比较简单，大多数是直接依赖于 Reflector 的对应方法实现的。

### ObjectWrapper 

MetaClass是MyBatis对类级别的元信息的封装和处理，下面来看MyBatis对对象级别的元信息的处理。ObjectWrapper 接口是对对象的包装，抽象了对象的属性信息，它定义了一系列查 询对象属性信息的方法，以及更新属性的方法。Object Wrapper 接口的定义如下：

```java
public interface ObjectWrapper {

  // 如果 ObjectWrapper 中封装的是普通的 Bean 对象，则调用相应属性的相应 getter 方法， 
  // 如果封装的是集合类，则获取指定 key 或下标对应的 value 位
  Object get(PropertyTokenizer prop);

  // 如果 ObjectWrapper 中封装的是普通的 Bean 对象， 则调用相应属性的相应 setter 方法，
  // 如果封装的是集合类，则设置指定 key 或下标对应的 value 值
  void set(PropertyTokenizer prop, Object value);

  // 查找属性表达式指定的属性，第二个参数表示是否忽略属性表达式中的下画线
  String findProperty(String name, boolean useCamelCaseMapping);

  // 找可写属性的名称集合
  String[] getGetterNames();

  // 找可读属性的名称集合 
  String[] getSetterNames();

  // 解析属性表达式指定属性的 setter 方法的参数类型 
  Class<?> getSetterType(String name);

  // 解析属性表达式指定属性的 getter 方法的返回值类型
  Class<?> getGetterType(String name);

  // 判断属性表达式指定属性是否有 getter/setter 方法
  boolean hasSetter(String name);
  boolean hasGetter(String name);

  // 为属性表达式指定的属性创建相应的 MetaObject 对象
  MetaObject instantiatePropertyValue(String name, PropertyTokenizer prop, ObjectFactory objectFactory);

  // 装的对象是否为 Collection 类型 
  boolean isCollection();

  // 用 Collection 对象的 add()方法
  void add(Object element);

  //  Collection 对象的 addAll()方法
  <E> void addAll(List<E> element);

}
```

ObjectWrapperFactory负责创建ObjectWrapper对象。DefaultObjectWrapperFactory实现了 ObjectWrapperFactory接口，但它实现的 getWrapperFor()方法始终抛出异常， hasWrapperFor()方法始终返回 false，所以该实现实际上是不可用的。但是 与 ObjectFactory 类似，我们可以在 mybatis-config.xml 中配置自定义的 ObjectWrapperFactory 实现类进行扩展。

BaseWrapper 是一个实现了 ObjectWrapper 接口的抽象类， 其中封装了 MetaObject 对象，并提供了三个常用的方法供其子类使用：BaseWrapper. resolveCollection()方法会调用 MetaObject. getValue()方法，它会解析属性表达式井获取指定的属性。Base Wrapper.getCollection Value()方法和 setCollectionValue()方法会解析属性表达式的索引信息，然后获取／设置对应项。这两个方法的实现类似：

```java

protected Object getCollectionValue(PropertyTokenizer prop, Object collection) {
  if (collection instanceof Map) {
    // 如果是 Map 类型，则index 为 key
    return ((Map) collection).get(prop.getIndex());
  } else {
    // 如果是其他集合类型，则 index 为下标
    int i = Integer.parseInt(prop.getIndex());
    if (collection instanceof List) {
      return ((List) collection).get(i);
    } else if (collection instanceof Object[]) {
      return ((Object[]) collection)[i];
    } else if (collection instanceof char[]) {
      return ((char[]) collection)[i];
    } else if (collection instanceof boolean[]) {
      return ((boolean[]) collection)[i];
    } else if (collection instanceof byte[]) {
      return ((byte[]) collection)[i];
    } else if (collection instanceof double[]) {
      return ((double[]) collection)[i];
    } else if (collection instanceof float[]) {
      return ((float[]) collection)[i];
    } else if (collection instanceof int[]) {
      return ((int[]) collection)[i];
    } else if (collection instanceof long[]) {
      return ((long[]) collection)[i];
    } else if (collection instanceof short[]) {
      return ((short[]) collection)[i];
    } else {
      throw new ReflectionException(
          "The '" + prop.getName() + "' property of " + collection + " is not a List or Array.");
    }
  }
}
```

BeanWrapper继承了BaseWrapper抽象类，其中封装了一个JavaBean对象以及该 JavaBean类相应的MetaClass对象，当然，还有从 BaseWrapper 继承下来的、该 JavaBean 对象相应的MetaObject 对象。BeanWrapper.get()方法和 set()方法会根据指定的属性表达式，获取／设置相应的属性值，两者逻辑类似，这里以 get()方法为例进行介绍，具体代码如下，

```java
public Object get(PropertyTokenizer prop) {
  // 存在索引信息，则表示属性表达式中的 name 部分为集合类型
  if (prop.getIndex() != null) {
    // 通过 MetaObject.getValue （）方法获取 object 对象中的指定集合属性
    Object collection = resolveCollection(prop, object);
    return getCollectionValue(prop, collection);
  } else {
    // 不存在索引信息，则 name 部分为普通对象，查找并调用 Invoker 相关方法获取属性
    return getBeanProperty(prop, object);
  }
}

private Object getBeanProperty(PropertyTokenizer prop, Object object) {
    try {
        // 根据属性名称，查找 Reflector . getMethods 集合中相应的 GetFieldinvoker 或 Methodinvoker
        Invoker method = metaClass.getGetInvoker(prop.getName());
        try {
            return method.invoke(object, NO_ARGUMENTS);
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
    } catch (RuntimeException e) {
        throw e;
    } catch (Throwable t) {
        throw new ReflectionException(
            "Could not get property '" + prop.getName() + "' from " + object.getClass() + ".  Cause: " + t.toString(), t);
    }
}
```

CollectionWrapper 实现了 ObjectWrapper 接口，其中封装了 Collection<Object>类型的对象，但它大部分实现方法都会抛出 UnsupportedOperationException 异常。MapWrapper 是 BaseWrapper 的另一个实现类，其中封装的是 Map<String, Object>类型对象，实现与BeanWrapper类似。

### MetaObject

 MetaObject 进行属性表达式的解析，其中字段属性的含义：

```java
// 原始JavaBean 对象
private final Object originalObject;
private final ObjectWrapper objectWrapper;
// 负责实例化 originalObject 的工厂对象
private final ObjectFactory objectFactory;
// 负责创建ObjectWrapper 的工厂对象
private final ObjectWrapperFactory objectWrapperFactory;
// 用于创建并缓存 Reflector 对象的工厂对象
private final ReflectorFactory reflectorFactory;
```

MetaObject的构造方法会根据传入的原始对象的类型以及ObjectFactory工厂的实现，创建相应的 ObjectWrapper对象，代码如下：

```java
private MetaObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory,
    ReflectorFactory reflectorFactory) {
  this.originalObject = object;
  this.objectFactory = objectFactory;
  this.objectWrapperFactory = objectWrapperFactory;
  this.reflectorFactory = reflectorFactory;

  if (object instanceof ObjectWrapper) {
    this.objectWrapper = (ObjectWrapper) object;
  } else if (objectWrapperFactory.hasWrapperFor(object)) {
    // 若ObjectWrapperFactory 能够为该原始对象创建对应的 ObjectWrapper 对象，则由优先使用
    // ObjectWrapperFactory，而 DefaultObjectWrapperFactory.hasWrapperFor （）始终 
    // 返回 false。 用户可以自定义 ObjectWrapperFactory 实现进行扩展
    this.objectWrapper = objectWrapperFactory.getWrapperFor(this, object);
  } else if (object instanceof Map) {
    // 若原始对象为 Map 类型， 则创建MapWrapper 对象
    this.objectWrapper = new MapWrapper(this, (Map) object);
  } else if (object instanceof Collection) {
    // 若原始对象为Collection 类型， 则创建CollectionWrapper 对象
    this.objectWrapper = new CollectionWrapper(this, (Collection) object);
  } else {
    // 若原始对象是普通的 JavaBean 对象，则创建 BeanWrapper 对象
    this.objectWrapper = new BeanWrapper(this, object);
  }
}

public static MetaObject forObject(Object object, ObjectFactory objectFactory,
                                   ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory) {
    if (object == null) {
        // 若 object 为 null，则统一返回 SystemMetaObject .NULL_META_OBJECT 这个标志对象 
        return SystemMetaObject.NULL_META_OBJECT;
    } else {
        return new MetaObject(object, objectFactory, objectWrapperFactory, reflectorFactory);
    }
}

```

MetaObject.getValue()/setValue()方法。 这里以 getValue()方法为例进行介绍， 具体代码如下：

```java
public Object getValue(String name) {
  PropertyTokenizer prop = new PropertyTokenizer(name);
  if (prop.hasNext()) {
    // 根据 PropertyTokenizer 解析后指定的属性，创建相应的 MetaObject 对象
    MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());
    if (metaValue == SystemMetaObject.NULL_META_OBJECT) {
      return null;
    } else {
      // 归处理子表达式 
      return metaValue.getValue(prop.getChildren());
    }
  } else {
    return objectWrapper.get(prop);
  }
}

public MetaObject metaObjectForProperty(String name) {
    Object value = getValue(name);
    return MetaObject.forObject(value, objectFactory, objectWrapperFactory, reflectorFactory);
}
```

MetaObject.get Value（）方法的执行流程：

1. 创建 User 对象相应的 MetaObject 对象，井调用 MetaObject.getValue()方法，经过PropertyTokenizer 解析“orders[0].id”表达式之后，其 name 为 orders, indexedName 为 orders[0], index 为 0, children 为 id。
2. 调用 MetaObject.metaObjectF or Property()方法处理“orders[0］” 表达式，底层会调用Bean Wrapper.get（）方法获取 orders 集合中第一个 Order 对象，其中先通过 BeanWrapper.resolveCollection()方法获取orders集合对象，然后调用 BeanWrapper.getCollection Value（）方法获取 orders 集合中的第一个元素。注意，这个过程中会递归调用 MetaObject.getValue（）方法。
3. 得到 Order 对象后，创建其相应的 MetaObject 对象，并调用 MetaObject.getValue（）方法处理 “id”表达式，逻辑同上，最后得到属性表达式指定属性的值，即 User对象的 orders 集合属性中第一个 Order 元素的 id 属性值。

MetaObject.setValue（）方法的逻辑与 MetaObject.getValue（）方法大致类似，如果需要设置的值不为空时，会调用 ObjectWrapper.instantiatePropertyValue() 初始化表达式路径上为空的属性，但是不能初始化集合类型字段中的集合元素。ObjectWrapper.instantiatePropertyValue（）方法实际上就是调用 ObjectFactory 接口的 create()方法 （默认实现是 DefaultObjectFactory）创建对象井将其设置到所属的对象中去。

```java
public MetaObject instantiatePropertyValue(String name, PropertyTokenizer prop, ObjectFactory objectFactory) {
  MetaObject metaValue;
  Class<?> type = getSetterType(prop.getName());
  try {
  	// 通过反射的方式，创建属性对象
    Object newObject = objectFactory.create(type);
    metaValue = MetaObject.forObject(newObject, metaObject.getObjectFactory(), metaObject.getObjectWrapperFactory(),
        metaObject.getReflectorFactory());
    // 将上面创建的属性对象，设直到对应的属性或集合中 
    set(prop, newObject);
  } catch (Exception e) {
    throw new ReflectionException("Cannot set value of property '" + name + "' because '" + name
        + "' is null and cannot be instantiated on instance of " + type.getName() + ". Cause:" + e.toString(), e);
  }
  return metaValue;
}
```

## 类型转换

JDBC 数据类型与 Java 语言中的数据类型井不是完全对应的，所以在 PreparedStatement 为SQL 语句绑定参数时，需要从 Java 类型转换成 JDBC 类型，而从结果集中获取数据时，则需要从 JDBC 类型转换成 Java 类型。 MyBatis 使用类型处理器完成上述两种转换。

在MyBatis中使用 JdbcType 这个枚举类型代表JDBC中的数据类型，该枚举类型中定义了TYPE_CODE字段，记录了 JDBC 类型在java.sql.Types中相应的常量编码，并通过一个静态集合codeLookup ( HashMap<Integer,JdbcType＞类型）维护了常量编码JdbcType 之间的对应关系。

### TypeHandler

MyBatis中所有的类型转换器都继承了 TypeHandler 接口 ，在 TypeHandler 接口中定义了如 下四个方法， 这四个方法分为两类： setParameter（）方法负责将数据由 JdbcType 类型转换成 Java类型： getResult（）方法及其重载负责将数据由 Java 类型转换成 JdbcType 类型。

```java
public interface TypeHandler<T> {

  // 在通过 PreparedStatement 为 SQL 语句绑定参数时，会将数据由 JdbcType 类型转换成 Java 类型 
  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;

  // 从 ResultSet 中获取数据时会调用此方法，会将数据由Java 类型转换成 JdbcType 类型
  T getResult(ResultSet rs, String columnName) throws SQLException;

  T getResult(ResultSet rs, int columnIndex) throws SQLException;

  T getResult(CallableStatement cs, int columnIndex) throws SQLException;

}
```

为方便用户自定义TypeHand\er实现， MyBatis 提供了 BaseType Handler 这个抽象类，它实现了 TypeHandler 接口，并继承了 TypeReference 抽象类，在 BaseTypeHandler 中实现了 TypeHandler.setParameter（）方法和 TypeHandler.getResult（）方法，具体实现如下所示：

```java
public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {
  if (parameter == null) {
    if (jdbcType == null) {
      throw new TypeException("JDBC requires that the JdbcType must be specified for all nullable parameters.");
    }
    try {
      // 定参数为 null 的处理
      ps.setNull(i, jdbcType.TYPE_CODE);
    } catch (SQLException e) {
      throw new TypeException("Error setting null for parameter #" + i + " with JdbcType " + jdbcType + " . "
          + "Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. "
          + "Cause: " + e, e);
    }
  } else {
    try {
      // 绑定非空参数，该方法抽象方法，由子类实现
      setNonNullParameter(ps, i, parameter, jdbcType);
    } catch (Exception e) {
      throw new TypeException("Error setting non null for parameter #" + i + " with JdbcType " + jdbcType + " . "
          + "Try setting a different JdbcType for this parameter or a different configuration property. " + "Cause: "
          + e, e);
    }
  }
}
```

BaseTypeHandler的实现类比较多， 但大多是直接调用 PreparedStatement和ResultSet或 CallableStatement 的对应方法，以 IntegerTypeHandler 为例简单介绍：

```java
public class IntegerTypeHandler extends BaseTypeHandler<Integer> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType)
      throws SQLException {
    // 用 PreparedStatement.seInt()实现参数绑定
    ps.setInt(i, parameter);
  }

  @Override
  public Integer getNullableResult(ResultSet rs, String columnName) throws SQLException {
    //  ResultSet.geTnt()获取指定列位
    int result = rs.getInt(columnName);
    return result == 0 && rs.wasNull() ? null : result;
  }

  @Override
  public Integer getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    int result = rs.getInt(columnIndex);
    return result == 0 && rs.wasNull() ? null : result;
  }

  @Override
  public Integer getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    int result = cs.getInt(columnIndex);
    return result == 0 && cs.wasNull() ? null : result;
  }
}
```

一般情况下， TypeHandler 用于完成单个参数以及单个列值的类型转换，如果存在多列值转换成一个 Java 对象的需求， 应该优先考虑使用在映射文件中定义合适的映射规则（<resultMap>节点）完成映射。 

### TypeHandlerRegistry

在MyBatis初始化过程中，会为所有己知的TypeHandler创建对象，并实现注册到TypeHandlerRegistry 中，由 TypeHandlerRegis盯F 负责管理这些TypeHandler 对象。TypeHandlerRegistry 中的核心字段的含义：

```java
// 记录 JdbcType 与 TypeHandler之间的对应关系，其中 JdbcType 是一个枚举类型，定义对应的 JDBC 类型该集合主要用于从结果集读取数据时，将数据从Jdbc 类型转换成 Java 类型
private final Map<JdbcType, TypeHandler<?>> jdbcTypeHandlerMap = new EnumMap<>(JdbcType.class);
// 记录了 Java 类型向指定JdbcType 转换时，需妥使用的 TypeHandler 对象。
private final Map<Type, Map<JdbcType, TypeHandler<?>>> typeHandlerMap = new ConcurrentHashMap<>();
// 记录了全部 TypeHandler 的类型以及该类型相应的 TypeHandler 对象
private final Map<Class<?>, TypeHandler<?>> allTypeHandlersMap = new HashMap<>();
// 空 TypeHandler 集合的标识
private static final Map<JdbcType, TypeHandler<?>> NULL_TYPE_HANDLER_MAP = Collections.emptyMap();
```

#### 注册TypeHandler

TypeHandlerRegistry.register（）方法实现了注册TypeHandler 对象的功能， 该注册过程会向上 述四个集合中添加 TypeHandler 对象。 register（）方法有多个重载，这些重载之间的调用关系如下所示：

![TypeHandlerRegistry.register重载关系](TypeHandlerRegistry.register重载关系.png)

多数 register()方法最终会调用重载④完成注册功能，该方法三个参数分别指定了 TypeHandler 能够处理的 Java 类型、 Jdbc 类型以及TypeHandler 对象。 

```java
private void register(Type javaType, JdbcType jdbcType, TypeHandler<?> handler) {
  // 是否明确指定了 TypeHandler 能够处理的 Java 类型
  if (javaType != null) {
    // 获取指定 Java 类型在 TYPE HANDLER MAP 集合中对应的 TypeHandler 集合
    Map<JdbcType, TypeHandler<?>> map = typeHandlerMap.get(javaType);
    // 建新的 TypeHandler 集合，并添加到 TYPE HANDLER MAP 中
    if (map == null || map == NULL_TYPE_HANDLER_MAP) {
      map = new HashMap<>();
    }
    map.put(jdbcType, handler);
    typeHandlerMap.put(javaType, map);
  }
  // 向 ALL_TYPE HANDLERS_MAP 集合注册 TypeHandler 类型和对应的 TypeHandler 对象
  allTypeHandlersMap.put(handler.getClass(), handler);
}
```

在①～③这个三个 register()方法重载中会尝试读取 TypeHandler类中定义的＠MappedTypes 注解和＠MappedJdbcTypes 注解，＠MappedTypes 注解用于指明该 TypeHandler 实现类能够处理 的 Java 类型的集合，＠MappedJdbcTypes 注解用于指明该 TypeHandler 实现类能够处理的 JDBC 类型集合。 register（）方法的重载①～③的具体实现如下：

```java
public void register(Class<?> typeHandlerClass) {
  boolean mappedTypeFound = false;
  // 获取＠MappedTypes注解
  MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);
  if (mappedTypes != null) {
    // 根据＠MappedTypes 注解中指定的 Java 类型进行注册
    for (Class<?> javaTypeClass : mappedTypes.value()) {
      // 经过强制类型转换以及使用反射创建 TypeHandler 对象之后，交由重载③继续处理
      register(javaTypeClass, typeHandlerClass);
      mappedTypeFound = true;
    }
  }
  if (!mappedTypeFound) {
    // 未指定＠MappedTypes 注解，交由重载继续处理
    register(getInstance(null, typeHandlerClass));
  }
}

  public <T> void register(TypeHandler<T> typeHandler) {
    boolean mappedTypeFound = false;
    MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);
    if (mappedTypes != null) {
      for (Class<?> handledType : mappedTypes.value()) {
        register(handledType, typeHandler);
        mappedTypeFound = true;
      }
    }
    // 从3.1.0版本开始，可以根据 TypeHandler 类型自动查找对应的 Java 类型，这需要我们的 TypeHandler 实现类同时继承 TypeReference 这个抽象类
    if (!mappedTypeFound && typeHandler instanceof TypeReference) {
      try {
        TypeReference<T> typeReference = (TypeReference<T>) typeHandler;
        register(typeReference.getRawType(), typeHandler);
        mappedTypeFound = true;
      } catch (Throwable t) {
        // maybe users define the TypeReference with a different type and are not assignable, so just ignore it
      }
    }
    if (!mappedTypeFound) {
      register((Class<T>) null, typeHandler);
    }
  }

  private <T> void register(Type javaType, TypeHandler<? extends T> typeHandler) {
    MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);
    if (mappedJdbcTypes != null) {
      // 根据＠MappedJdbcTypes i主解指定的 JDBC 类型进行注册 
      for (JdbcType handledJdbcType : mappedJdbcTypes.value()) {
        register(javaType, handledJdbcType, typeHandler);
      }
      if (mappedJdbcTypes.includeNullJdbcType()) {
        register(javaType, null, typeHandler);
      }
    } else {
      register(javaType, null, typeHandler);
    }
  }	
```

上述全部的 register方法重载都是在 向 TYPE_HANDLER_MAP 集合和 ALL_TYPE_ HANDLERS_MAP 集合注册 TypeHandler 对象，而重载⑤是向 JDBC_ TYPE_ HANDLER _MAP 集合注册 TypeHandler 对象，其具体实现如下： 

```java
public void register(JdbcType jdbcType, TypeHandler<?> handler) {
  jdbcTypeHandlerMap.put(jdbcType, handler);
}
```

TypeHandlerRegister除了提供注册单个 TypeHandler 的 register重载，还可以扫描整个包下的TypeHandler 接口实现类，并将完成这些 TypeHandler 实现类的注册。下面来看重载⑥的具体实现：

```java
public void register(String packageName) {
  ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();
  // 查找指定包下的 TypeHandler 接口实现类
  resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName);
  Set<Class<? extends Class<?>>> handlerSet = resolverUtil.getClasses();
  for (Class<?> type : handlerSet) {
    // 过滤掉内部类、接口 以及抽象类
    if (!type.isAnonymousClass() && !type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {
      register(type);
    }
  }
}
```

TypeHandlerRegistry 构造方法， 会通过上述 register（）方法为很多基础类型注册对应的 TypeHandler 对象。

#### 查找 TypeHandler

TypeHandlerRegistry.getTypeHandler（）方法实现了从上述四个集合中获取对应 TypeHandler 对象的功能。 TypeHandlerRegistry.getTypeHandler（）方法有多个重载， 这些重载之间的关系如下所示：

![TypeHandlerRegistry.getTypeHandler重载关系](TypeHandlerRegistry.getTypeHandler重载关系.png)

经过一系列类型转换之后，TypeHandlerRegistry.getTypeHandler()方法的多个重载都会调用 TypeHandlerRegistry.getTypeHandle(Type,JdbcType）这个重载方法， 它会根据指定的 Java 类型和 JdbcType 类型查找相应的 TypeHandler 对象，具体实现如下：

```java
private <T> TypeHandler<T> getTypeHandler(Type type, JdbcType jdbcType) {
  if (ParamMap.class.equals(type)) {
    return null;
  }
  // 查找（或初始化） Java 类型对应的 TypeHandler 集合
  Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = getJdbcHandlerMap(type);
  TypeHandler<?> handler = null;
  if (jdbcHandlerMap != null) {
    // 根据 JdbcType 类型查找 TypeHandler 对象
    handler = jdbcHandlerMap.get(jdbcType);
    if (handler == null) {
      handler = jdbcHandlerMap.get(null);
    }
    if (handler == null) {
      // 如果 jdbcHandlerMap 只注册了一个 TypeHandler，则使用此 TypeHandler 对象
      handler = pickSoleHandler(jdbcHandlerMap);
    }
  }
  // type drives generics here
  return (TypeHandler<T>) handler;
}
```

在 TypeHandlerRegis町r.getJdbcHandlerMapO方法中，会检测 TYPE_HANDLER_MAP 集合中指定 Java 类型对应的 TypeHandler 集合是否己经初始化。如果未初始化，则尝试以该 Java 类型的、己初始化的父类对应的 TypeHandler 集合为初始集合；如不存在己初始化的父类，则将其对应的 TypeHandler 集合初始化为 NULL_TYPE_HANDLER_ MAP 标识。getJdbcHandlerMap方法具体实现如下：

```java
private Map<JdbcType, TypeHandler<?>> getJdbcHandlerMap(Type type) {
  // 查找指定 Java 类型对应的 TypeHandler 集合
  Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = typeHandlerMap.get(type);
  if (jdbcHandlerMap != null) {
    return NULL_TYPE_HANDLER_MAP.equals(jdbcHandlerMap) ? null : jdbcHandlerMap;
  }
  // 初始化指定 Java 类型的 TypeHandler 集合
  if (type instanceof Class) {
    Class<?> clazz = (Class<?>) type;
    if (Enum.class.isAssignableFrom(clazz)) {
      // 查找父类对应的 TypeHandler 集合，并作为初始集合
      Class<?> enumClass = clazz.isAnonymousClass() ? clazz.getSuperclass() : clazz;
      jdbcHandlerMap = getJdbcHandlerMapForEnumInterfaces(enumClass, enumClass);
      if (jdbcHandlerMap == null) {
        register(enumClass, getInstance(enumClass, defaultEnumTypeHandler));
        return typeHandlerMap.get(enumClass);
      }
    } else {
      jdbcHandlerMap = getJdbcHandlerMapForSuperclass(clazz);
    }
  }
  typeHandlerMap.put(type, jdbcHandlerMap == null ? NULL_TYPE_HANDLER_MAP : jdbcHandlerMap);
  return jdbcHandlerMap;
}

  private Map<JdbcType, TypeHandler<?>> getJdbcHandlerMapForSuperclass(Class<?> clazz) {
    Class<?> superclass = clazz.getSuperclass();
    // 父类为 Object 或 null 则查找结束
    if (superclass == null || Object.class.equals(superclass)) {
      return null;
    }
    Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = typeHandlerMap.get(superclass);
    if (jdbcHandlerMap != null) {
      return jdbcHandlerMap;
    } else {
      // 继续逆归查找父类对应的 TypeHandler 集合 
      return getJdbcHandlerMapForSuperclass(superclass);
    }
  }
```

TypeHandlerRegis町.getMappingTypeHandler（）方法会根据指定的 TypeHandler 类型，直接从 ALL_ TYPE_ HAI'由LERS_MAP 集合中查找 TypeHandler 对象。TypeHandlerRegistry. getTypeHandler( J dbcType）方 法会 根据指定的 JdbcType 类型 ，从 JD BC_ TYPE_ HANDLER_ MAP 集合中查找 TypeHandler 对象

### TypeAliasRegistry 

MyBatis通过TypeAliasRegister类完成别名注册和管理的功能，TypeAliasRegistry 的结构比较简单，它通过 TYPE_ALIASES 宇段 (Map<String， Class＜？＞＞类型）管理别名与 Java 类型之间的对应关系，通过 TypeAliasRegistry.registerAlias()方法完成注册别名，该方法的具体实现如下：

```java
public void registerAlias(String alias, Class<?> value) {
  // 检测 alias 为 null，则直接抛出异常
  if (alias == null) {
    throw new TypeException("The parameter alias cannot be null");
  }
  // 转为小写，并检测名称是否存在
  String key = alias.toLowerCase(Locale.ENGLISH);
  if (typeAliases.containsKey(key) && typeAliases.get(key) != null && !typeAliases.get(key).equals(value)) {
    throw new TypeException(
        "The alias '" + alias + "' is already mapped to the value '" + typeAliases.get(key).getName() + "'.");
  }
  typeAliases.put(key, value);
}
```

TypeAliasRegister中还有两个方法， registerAliases(String，Class＜？＞）重载会扫描指定包下所有的类，并为指定类的子类添加别名： registerAlias( Class＜？＞）重载中会尝试读取@Alias 注解。这两个方法的实现如下： 

```java
public void registerAliases(String packageName, Class<?> superType) {
  ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();
  // 查找指定包下的 superType 类型类s
  resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
  Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();
  for (Class<?> type : typeSet) {
    // 过滤掉略内部类、接口以及抽象类
    if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {
      registerAlias(type);
    }
  }
}

  public void registerAlias(Class<?> type) {
    String alias = type.getSimpleName();
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    // 读取＠Alias i主解
    if (aliasAnnotation != null) {
      alias = aliasAnnotation.value();
    }
    registerAlias(alias, type);
  }
```

## 日志模块

在 MyBatis 的日志模块中，就使用了适配器模式。 MyBatis 内部调用其日志模块时，使用了其内部接口。Log4j、 Log4j2 等第三方日志组件对外提供的接口各不相同， MyBatis 为了集成和复用这些第三方日志组件， 在其日志模块中提供了多种 Adapter ，将这些第 三方日志 组件对外的接口适配成 了org.apache.ibatis.logging.Log 接口，这样 MyBatis 内部就可以统一通过 org.apache.ibatis.logging.Log 接口调用第三方日志组件的功能了。

### 日志适配器

MyBatis 统一提供了 trace、 debug、 warn、 eηor 四个级别，这基本与主流日志框架的日志级别类似，可以满足绝大多数场景的日志需求。My Batis 的日志模块位于 org.apache.ibatis.logging 包中，该模块中通过 Log 接口定义了日志模块的功能，当然日志适配器也会实现此接口。 LogFactory 工厂类负责创建对应的日志组件适配器：

![log接口是实现类](log接口实现类.png)

在 LogFactory 类加载时会执行其静态代码块，其逻辑是按序加载并实例化对应日志组件的适配器，然后使用 LogFactory. logConstructor 这个静态宇段，记录当前使用的第三方日志组件的适配器，具体代码如下所示：

```java
// 记录当前使用的第二方日志组件所对应的适配器的构造方法
private static Constructor<? extends Log> logConstructor;

static {
  // 下面会针对每种 日志组件调用 tryimplementation（）方法进行尝试加载，具体调用顺序是
  tryImplementation(LogFactory::useSlf4jLogging);
  tryImplementation(LogFactory::useCommonsLogging);
  tryImplementation(LogFactory::useLog4J2Logging);
  tryImplementation(LogFactory::useLog4JLogging);
  tryImplementation(LogFactory::useJdkLogging);
  tryImplementation(LogFactory::useNoLogging);
}
```

LogFactory.trylmplementation（）方法首先 会 检测 logConstructor 字段 ，若为空则 调用Runnable.run（）方法，如上述代码所示，其中会调用 use*Logging（）方法。 这里以 useJdkLogging O为例进行介绍， 具体代码如下：

```java
public static synchronized void useJdkLogging() {
  setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);
}

  private static void setImplementation(Class<? extends Log> implClass) {
    try {
      // 获取指定适配器的构造方法 
      Constructor<? extends Log> candidate = implClass.getConstructor(String.class);
      Log log = candidate.newInstance(LogFactory.class.getName());
      if (log.isDebugEnabled()) {
        log.debug("Logging initialized using '" + implClass + "' adapter.");
      }
      logConstructor = candidate;
    } catch (Throwable t) {
      throw new LogException("Error setting Log implementation.  Cause: " + t, t);
    }
  }
```

Jdkl 4Logginglmpl 实现了 org.apache.ibatis.logging.Log 接口，并封装了 java.util.logging.Logger 对象， org.apache.ibatis.logging.Log 接口的功能全部通过调用 java.util.logging.Logger 对象实现，dkl4Logginglmpl 的实现如下：

```java
public class Jdk14LoggingImpl implements Log {

  private final Logger log;
  
  // 将请求全部委托给了 java.ut工l.logg工ng. Logger 对象的相应方法 
  @Override
  public boolean isDebugEnabled() {
    return log.isLoggable(Level.FINE);
  }

  @Override
  public boolean isTraceEnabled() {
    return log.isLoggable(Level.FINER);
  }

}
```

### 代理模式与 JDK 动态代理 

代理模式类图如下所示：

![代理模式类图.png](代理模式类图.png)

其中， Subject 是程序中的业务逻辑接口， Rea!Subject 是实现了 Su均ect 接口的真正业务类，Proxy 是实现了 Subject 接口的代理类，其中封装了 Rea!Subject 对象。在程序中不会直接调动 RealSubject 对象的方法，而是使用 Proxy 对象实现相关功能。 Proxy.operation（）方法的实现会调 用 RealSubject 对象的 operation（）方法执行真正的业务逻辑，但是处理完业务逻辑， Proxy.operation（）会在 RealSubj巳ct.operation（）方法调用前后进行预处理和相关的后置处理。这就是所谓的“代理模式”。

使用代理模式可以控制程序对 RealSubject 对象的访问，或是在执行业务处理的前后进行相关的预处理和后置处理。 代理模式还可以用于实现延迟加载的功能，我们知道查询数据库是一个耗时的操作，而有些时候查询到的数据也并没有真正被程序使用。 延迟加载功能就可以有效 地避免这种浪费，系统访问数据库时，首先可以得到一个代理对象，此时并没有执行任何数据 库查询操作，代理对象中自然也没有真正的数据，当系统真正需要使用数据时，再调用代理对象完成数据库查询井返回数据。 MyBatis 中延迟加载功能的大致原理也是如此。

JDK 动态代理的核心是 InvocationHandler 接口。 InvocationHandler 的示例实现，代码如下： 

```java
public class TestInvokerHandler implements InvocationHandler {

    private Object target;

    public TestInvokerHandler(Object target){
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = method.invoke(target,args);
        return result;
    }

    public Object gerProxy(){
        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader()
                ,target.getClass().getInterfaces(),this);
    }
    
}
```

对于需要相同代理行为的业务类，只需要提供一个 InvocationHandler 实现即可。在程序运行时， JDK 会为每个 Rea!Subject 类动态生成代理类井加载到虚拟机中，之后创建对应的代理对象。

JDK 动态代理相关实现的入口是Proxy.newProxylnstanceO这个静态方法，它的三个参数分别是加载动态生成的代理类的类加载器、业务类实现的接口、上面介绍的 InvocationHandler 对象。 Proxy.newProxy Instance（）方法的具体实现如下：

```java
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
{
    Objects.requireNonNull(h);

    final Class<?>[] intfs = interfaces.clone();
    final SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    }

    /*
     * Look up or generate the designated proxy class.
     */
    Class<?> cl = getProxyClass0(loader, intfs);

    /*
     * Invoke its constructor with the designated invocation handler.
     */
    try {
        if (sm != null) {
            checkNewProxyPermission(Reflection.getCallerClass(), cl);
        }

        // 获取代理类的构造方法
        final Constructor<?> cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction<Void>() {
                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        return cons.newInstance(new Object[]{h});
    } catch (IllegalAccessException|InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}

    private static Class<?> getProxyClass0(ClassLoader loader,
                                           Class<?>... interfaces) {
        // 限制接口数量
        if (interfaces.length > 65535) {
            throw new IllegalArgumentException("interface limit exceeded");
        }

        // 如果指定的类加载器中已经创建了实现指定接口的代理类，则查找缓存
        // 否则通过 ProxyClassFactory 创建实现指定接口的代理类
        return proxyClassCache.get(loader, interfaces);
    }
```

 proxyC!assCache 是定义在 Proxy 类中的静态字段，主要用于缓存已经创建过的代理类，定义如下： 

```java
private static final WeakCache<ClassLoader, Class<?>[], Class<?>>
    proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());
```

WeakCache.get（）方法会首先尝试从缓存中查找代理类，如果查找不到， 则会创建 Factory 对象并调用其 get（）方法获取代理类。 Factory 是 WeakCache 中的内部类， Factory.get（）方法会调用ProxyClassFactory叩ply（）方法创建并加载代理类。 

ProxyC!assFactoηapply（）方法首先会检测代理类需要实现的接口集合，然后确定代理类的名称，之后创建代理类并将其写入文件中， 最后加载代理类， 返回对应的 Class 对象用于后续的实例化代理类对象。该方法的具体实现如下： 

```java
public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
    // 对 interfaces 集合进行一系列检测,选择定义代理类的包名
    
    // 代理类的名称是通过包名、代理类名称前级以及编号这三项组成的
    long num = nextUniqueNumber.getAndIncrement();
    String proxyName = proxyPkg + proxyClassNamePrefix + num;
    // 生成代理类，并写入文件
    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
    // 加载代理类，并返回 Class 对象
    return defineClass0(loader, proxyName,
                                    proxyClassFile, 0, proxyClassFile.length);
    
}
```

ProxyGenerator.generateProxyClass（）方法会按照指定的名称和接口集合生成代理类的字节码，并根据条件决定是否保存到磁盘上。该方法的具体代码如下：

```java
public static byte[] generateProxyClass(final String var0, Class<?>[] var1, int var2) {
    ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);
    // 动态生成代理类的字节码
    final byte[] var4 = var3.generateClassFile();
    // 如果 saveGeneratedFiles 值为 true，会将生成的代理类的字节码保存到文件中 
    if (saveGeneratedFiles) {
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {
                try {
                    int var1 = var0.lastIndexOf(46);
                    Path var2;
                    if (var1 > 0) {
                        Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar));
                        Files.createDirectories(var3);
                        var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class");
                    } else {
                        var2 = Paths.get(var0 + ".class");
                    }

                    Files.write(var2, var4, new OpenOption[0]);
                    return null;
                } catch (IOException var4x) {
                    throw new InternalError("I/O exception saving generated file: " + var4x);
                }
            }
        });
    }

    // 返回上面生成的代理类的字节码 
    return var4;
}
```

JDK 动态代理的实现原理是动态创建代理类井通过指定类加载器加载，然后在创建代理对象时将 InvokerHandler 对象作为构造参数传入。当调用代理对象时，会调用 InvokerHandler.invoke（）方法，并最终调用真正业务对象的相应方法。

### JDBC 调试

在MyBatis 的日志模块中有一个Jdbc 包，它并不是将日志信息通过JDBC保存到数据库中，而是通过 JDK 动态代理的方式，将 JDBC 操作通过指定的日志框架打印出来。它可以输出 SQL 语句、用户传入的绑定参数、 SQL 语句影响行数等等信息，对调试程序来说是非常重要的。 BaseJdbcLogger 是一个抽象类，它是 Jdbc 包下其他 Logger 类的父类，继承关系如图：

![image-20230412114630841](BaseJdbcLogger继承关系.png)

在 BaseJdbcLogger 中定义了 SET_METHODS 和 EXECUTE_METHODS 两个 Set<String＞类型的集合，用于记录绑定 SQL 参数相关的 set＊（）方法名称以及执行 SQL 语句相关的方法名称，其定义以及相关静态代码块如下： 

```java
// 记录了 PreparedStatement 接口中定义的常用的 set*（）方法 
protected static final Set<String> SET_METHODS;
// 记录了 Statement 接口和 PreparedStatement 接口中与执行 SQL 语句相关的方法
protected static final Set<String> EXECUTE_METHODS = new HashSet<>();

static {
    SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods())
        .filter(method -> method.getName().startsWith("set")).filter(method -> method.getParameterCount() > 1)
        .map(Method::getName).collect(Collectors.toSet());

    EXECUTE_METHODS.add("execute");
    EXECUTE_METHODS.add("executeUpdate");
    EXECUTE_METHODS.add("executeQuery");
    EXECUTE_METHODS.add("addBatch");
}
```

BaseJdbcLogger 中核心宇段的含义如下：

```java
// 记录了 PreparedStatement.set*（）方法设置的键位对 
private final Map<Object, Object> columnMap = new HashMap<>();
// 记录了 PreparedStatement.set*（）方法设置的 key值
private final List<Object> columnNames = new ArrayList<>();
// 记录了 PreparedStatement.set*（）方法设置的 value 值
private final List<Object> columnValues = new ArrayList<>();
// 用户输出日志的Log对象
protected final Log statementLog;
// 记录的SQL层数，用于格式化输出SQL
protected final int queryStack;
```

ConnectionLogger继承了BaseJdbcLogger 抽象类，其中封装了Connection对象井同时实现了 lnvocationHandler 接口。 ConnectionLogger. wlnstance（）方法为会为其封装自q Connection 对象创建相应的代理对象，具体代码如下：

```JAVA
public static Connection newInstance(Connection conn, Log statementLog, int queryStack) {
  // 使用 JDK动态代理的方式创建代理对象
  InvocationHandler handler = new ConnectionLogger(conn, statementLog, queryStack);
  ClassLoader cl = Connection.class.getClassLoader();
  return (Connection) Proxy.newProxyInstance(cl, new Class[] { Connection.class }, handler);
}
```

ConnectionLogger.invoke（）方法是代理对象的核心方法，它为 prepareStatement（）、prepareCall（）、createStatement（）等方法提供了代理，具体实现如下： 

```JAVA
public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {
    // 如采调用的是从 Object 继承的方法，则直接调用，不做任何其他处理 
    if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, params);
    }
    // 如果调用的是 prepareStatement （）方法、 prepareCall （）方法或 createStatement （）方法， 
    // 则在创建相应 Statement 对象后，为其创建代理对象并返回该代理对象
    if ("prepareStatement".equals(method.getName()) || "prepareCall".equals(method.getName())) {
        if (isDebugEnabled()) {
            debug(" Preparing: " + removeExtraWhitespace((String) params[0]), true);
        }
        // 调用底层封装的 Connection 对象的 prepareStatement （）方法，得到 PreparedStatement 对象
        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);
        // 为该 PreparedStatement 对象创建代理对象 
        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);
        return stmt;
    } else if ("createStatement".equals(method.getName())) {
        Statement stmt = (Statement) method.invoke(connection, params);
        stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);
        return stmt;
    } else {
        return method.invoke(connection, params);
    }
}
```

PreparedStatementLogger中封装了PreparedStatement对象，也继承了BaseJdbcLogger抽象类井实现了 InvocationHandler接口 。PreparedStatementLogger.newlnstance（）方法的实现与 ConnectionLogger.newlnstance（）方法类似。

PreparedStatementLogger.invoke（） 方法会 为 E姐CUTE_METHODS 集合 中的 方法 、 SET_METHODS 集合中的方法、 getResultSet（）等方法提供代理， 具体代码如下：

```java
public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {
    // 如采调用的是从 Object 继承的方法，则直接调用，不做任何其他处理
    if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, params);
    }
    // 调用了EXECUTE 阻THODS 集合中的方法 
    if (EXECUTE_METHODS.contains(method.getName())) {
        if (isDebugEnabled()) {
            // 日志输出 ，输出的是参数值以及参数类型
            debug("Parameters: " + getParameterValueString(), true);
        }
        // 空 BaseJdbcLogger 中定义的三个 column*集合
        clearColumnInfo();
        if ("executeQuery".equals(method.getName())) {
            // 如果调用 executeQuery （）方法， 则为 ResultSet 创建代理对象
            ResultSet rs = (ResultSet) method.invoke(statement, params);
            return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack);
        } else {
            return method.invoke(statement, params);
        }
    } else if (SET_METHODS.contains(method.getName())) {
        // 如果调用 SET 阻THODS 集合中的方法， 则通过 setColumn （）方法记录到 BaseJdbcLogger 中定义的三个column*集合
        if ("setNull".equals(method.getName())) {
            setColumn(params[0], null);
        } else {
            setColumn(params[0], params[1]);
        }
        return method.invoke(statement, params);
    } else if ("getResultSet".equals(method.getName())) {
        // 如果调用 getResultSet （）方法，则为 ResultSet创建代理对象
        ResultSet rs = (ResultSet) method.invoke(statement, params);
        return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack);
    } else if ("getUpdateCount".equals(method.getName())) {
        // 如果调用 getUpdateCount()方法，则通过日志框架输出其结果
        int updateCount = (Integer) method.invoke(statement, params);
        if (updateCount != -1) {
            debug("   Updates: " + updateCount, false);
        }
        return updateCount;
    } else {
        return method.invoke(statement, params);
    }
}
```

 ResultSetLogger 中封装了 ResultSet 对象，也继承了 BaseJdbcLogger 抽象类并实现了 InvocationHandler 接口 。ResultSetLogger 中定义的宇段如下： 

```java
// 记录了超大长度的类型
private static final Set<Integer> BLOB_TYPES = new HashSet<>();
// 是否是ResultSet结果集的第一行 
private boolean first = true;
// 统计行数
private int rows;
// 真正的 ResultSet 对象 
private final ResultSet rs;
// 记录了起大字段的列编号
private final Set<Integer> blobColumns = new HashSet<>();

static {
  BLOB_TYPES.add(Types.BINARY);
  BLOB_TYPES.add(Types.BLOB);
  BLOB_TYPES.add(Types.CLOB);
  BLOB_TYPES.add(Types.LONGNVARCHAR);
  BLOB_TYPES.add(Types.LONGVARBINARY);
  BLOB_TYPES.add(Types.LONGVARCHAR);
  BLOB_TYPES.add(Types.NCLOB);
  BLOB_TYPES.add(Types.VARBINARY);
}
```

ResultSetLogger.new Instance（）方法的实现与 ConnectionLogger.newInstance（）类似，它会为 ResultSet 创建代理对象。ResultSetLogger.invoke（）方法的实现会针对 ResultSet.next() 方法的调用进行一系列后置操作，通过这些后置操作会将 ResultSet 数据集中的记录全部输出到日志中。具体实现如下： 

```java
public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, params);
      }
      Object o = method.invoke(rs, params);
      // 针对ResultSet.next （）方法的处理
      if ("next".equals(method.getName())) {
        // 还存在下一行数据
        if ((Boolean) o) {
          rows++;
          if (isTraceEnabled()) {
            ResultSetMetaData rsmd = rs.getMetaData();
            final int columnCount = rsmd.getColumnCount();
            // 如果是第一行数据，则输出表头
            if (first) {
              first = false;
              // 除了输出表头，还会填充 blobColurnns 集合，记录超大类型的列
              printColumnHeaders(rsmd, columnCount);
            }
            // 输出该行记录，注意会过滤掉blobColurnns 中记录的列，这些列的数据较大，不会输出到日志
            printColumnValues(columnCount);
          }
        } else {
          debug("     Total: " + rows, false);
        }
      }
      clearColumnInfo();
      return o;
}
```

## 资源加载

### ClassloaderWrapper 

在 IO 包中提供的 ClassLoaderWrapper 是一个 ClassLoader 的包装器，其中包含了多个ClassLoader 对象。 通过调整多个类加载器的使用顺序， ClassLoaderWrapper 可以确保返回给系统使用的是正确的类加载器。用 ClassLoaderWr叩per 就如同使用一个 ClassLoader 对象， ClassLoaderWrapper 会按照指定的顺序依次检测其中封装的 ClassLoader 对象，并从中选取第一个可用的 ClassLoader 完成相关功能。

ClassLoaderWrapper 中定义了两个字段，分别记录了系统指定的默认 ClassLoader 和 SystemClassLoader， 定义如下：  

```java
// 应用指定的默认类加载器
ClassLoader defaultClassLoader;
ClassLoader systemClassLoader;

ClassLoaderWrapper() {
  try {
    // 初始化systemClassLoader字段
    systemClassLoader = ClassLoader.getSystemClassLoader();
  } catch (SecurityException ignored) {
    // AccessControlException on Google App Engine
  }
}
```

ClassLoaderWrapper 的主要 功能可以分为三类 ， 分别 是 getResourceAsURL（）方法、 classForName（）方法、 getResourceAsStream（）方法，这三个方法都有多个重载， 这三类方法最终都会调用参数为 String和 ClassLoader［］的重载。这里以 getResourceAsURL（）方法为例进行介绍，其他两类方法的实现与该实现类似，ClassLoaderWrapper.getResourceAsURL（）方法的实现如下： 

```java
public URL getResourceAsURL(String resource) {
  return getResourceAsURL(resource, getClassLoaders(null));
}

// ClassLoaderWrapper.getClassLoaders （）方法会返回 ClassLoader ［］数量且，该数纽指明了类加载器的使用顺序
ClassLoader[] getClassLoaders(ClassLoader classLoader) {
    return new ClassLoader[] { 
        classLoader,// 数指定的类加载器
        defaultClassLoader,// 统指定的默认类加载器 
        Thread.currentThread().getContextClassLoader(),// 前线程绑定的类加载器
        getClass().getClassLoader(), // 载当前类所使用的类加载器
        systemClassLoader };
}


URL getResourceAsURL(String resource, ClassLoader[] classLoader) {

    URL url;
    // 遍历lassLoader数组
    for (ClassLoader cl : classLoader) {
        if (null != cl) {
            // 调用 ClassLoader.getResource （）方法查找指定的资源
            url = cl.getResource(resource);
            // 以”／”开头，再次查找
            if (null == url) {
            	url = cl.getResource("/" + resource);
            }
            // 查找到指定的资源
            if (null != url) {
                return url;
            }

        }

    }

    // didn't find it anywhere.
    return null;

}
```

Resources 是一个提供了多个静态方法的工具类， 其中封装了一个 ClassLoaderWrapper 类型的静态字段， Resources 提供的这些静态工具都是通过调用该 ClassLoaderWrapper 对象的相应方法实现的。

### ResolverUtil

ResolverUtil 可以根据指定的条件查找指定包下的类，其中使用的条件由 Test 接口表示。 ResolverUtil 中使用 classLoader 字段（ClassLoader 类型）记录了当前使用的类加载器，默认情 况下，使用的是当前线程上下文绑定的 ClassLoader，我们可以通过 setC!assLoader（）方法修改使用类加载器。

MyBatis 提供了两个常用的 Test 接口实现，分别是 IsA 和 AnnotatedWith，IsA 用于检测类是否继承了指定的类或接口， AnnotatedWith 用于检测类是否添加了指定的注解。也可以 自己实现 Test 接口，实现指定条件的检测。 Test 接口中定义了 matches（）方法，它用于检测指定类是否符合条件，代码如下：

```java
public interface Test {

  /**
   * 参数 type 是待检测的类，如果该类符合检测的条件，则 matches （）方法返回 true，否则返回 false
   * false otherwise.
   *
   * @param type
   *          the type
   *
   * @return true, if successful
   */
  boolean matches(Class<?> type);
}
```

IsA 和 AnnotatedWith 的具体实现如下：

```java
// 检测指定类是否继承了 parent 指定的类
public static class IsA implements Test {
    
    @Override
    public boolean matches(Class<?> type) {
      return type != null && parent.isAssignableFrom(type);
    }
}
// 指定类是否添加了 annotation注解 
public static class AnnotatedWith implements Test {
    @Override
    public boolean matches(Class<?> type) {
      return type != null && type.isAnnotationPresent(annotation);
    }
}
```

默认情况下，使用 Thread.currentThread().getContextClassLoader（）这个类加载器加载符合条件的类，我们可以在调用 find（）方法之前，调用 setC!assLoader(ClassLoader）设置需要使用的ClassLoader，这个ClassLoader 可以从 ClassLoaderWrapper 中获取合适的类加载器。

ResolverUtil 的使用方式如下：

```java
ResolverUtil<Comparable> resolverUtil = new ResolverUtil<>();
// 在包下查找实现了 Comparable 这个类
resolverUtil.findImplementations(Comparable.class,"org.example.test.io");
Set<Class<? extends Comparable>> comparables = resolverUtil.getClasses();
```

ResolverUtil. mdlmplementations（） 方法和 ResolverUtil.findAnnotated（）方法都 是依赖ResolverUtil.fmd（）方法实现的， findlmplementations（）方法会创建 lsA 对象作为检测条件， fmdAnnotated（）方法会创建 AnnotatedWith 对象作为检测条件。 这几个方法的调用关系如下：

![image-20230418153252661](ResolverUtil方法调用图.png)

ResolverUtil.find（）方法的实现如下：

```java
public ResolverUtil<T> find(Test test, String packageName) {
  String path = getPackagePath(packageName);

  try {
    // 通过 VFS . list （）查找 packageName 包下的所有资源
    List<String> children = VFS.getInstance().list(path);
    for (String child : children) {
      if (child.endsWith(".class")) {
        addIfMatching(test, child);
      }
    }
  } catch (IOException ioe) {
    log.error("Could not read package: " + packageName, ioe);
  }

  return this;
}

protected void addIfMatching(Test test, String fqn) {
    try {
        // fqn 是类的完全限定名，即包括其所在包的包名 
        String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
        ClassLoader loader = getClassLoader();
        if (log.isDebugEnabled()) {
            log.debug("Checking to see if class " + externalName + " matches criteria [" + test + "]");
        }

        Class<?> type = loader.loadClass(externalName);
        // 过 Test.matches （）方法检测条件是否满足
        if (test.matches(type)) {
            // 符合条件的类记录到 matches 集合中
            matches.add((Class<T>) type);
        }
    } catch (Throwable t) {
        log.warn("Could not examine class '" + fqn + "'" + " due to a "
                 + t.getClass().getName() + " with message: " + t.getMessage());
    }
}
```

### VFS

VFS表示虚拟文件系统 （VirtualFile System）， 它用来查找指定路径下的资源。 VFS是一个抽象类， MyBatis 中提供了 JBoss6VFS 和 DefaultVFS 两个VFS 的实现，VFS 的核心字段的含义如下： 

```java
/** 记录了 MyBatis提供的两个VFS 实现类 */
public static final Class<?>[] IMPLEMENTATIONS = { JBoss6VFS.class, DefaultVFS.class };

/**
 * 记录了用户自定义的VFS 实现类。 VFS.addimplClass（）方法会将指定的VFS 实现对应的Class对象添加到USER IMPLEMENTATIONS集合中 
 */
public static final List<Class<? extends VFS>> USER_IMPLEMENTATIONS = new ArrayList<>();

/** 单例模式VFS*/
private static class VFSHolder {
    static final VFS INSTANCE = createVFS();

    @SuppressWarnings("unchecked")
    static VFS createVFS() {
        // 先添加用户自己的实现
        List<Class<? extends VFS>> impls = new ArrayList<>();
        impls.addAll(USER_IMPLEMENTATIONS);
        impls.addAll(Arrays.asList((Class<? extends VFS>[]) IMPLEMENTATIONS));

        // 尝试实现每个类，直到找到有效的类
        VFS vfs = null;
        for (int i = 0; vfs == null || !vfs.isValid(); i++) {
            Class<? extends VFS> impl = impls.get(i);
            try {
                vfs = impl.getDeclaredConstructor().newInstance();
                if (!vfs.isValid() && log.isDebugEnabled()) {
                    log.debug("VFS implementation " + impl.getName() + " is not valid in this environment.");
                }
            } catch (InstantiationException | IllegalAccessException | NoSuchMethodException
                     | InvocationTargetException e) {
                log.error("Failed to instantiate " + impl, e);
                return null;
            }
        }

        if (log.isDebugEnabled()) {
            log.debug("Using VFS adapter " + vfs.getClass().getName());
        }

        return vfs;
    }
}

// 获取单例VFS
public static VFS getInstance() {
    return VFSHolder.INSTANCE;
}
```

VFS 中定义了 list(URL，String）和 isValid（）两个抽象方法， isValid（）负责检测当前 VFS 对象在当前环境下是否有效， list(URL, String）方法负 责查找指定的资源名称列表，在ResolverUtil.find（）方法查找类文件时会调用 list（）方法的 重载方法，该重载最终会调用list(URL,String）这个重载。 DefaultVFS. I ist(URL,String）方法的实现如下：

```java
public List<String> list(URL url, String path) throws IOException {
  InputStream is = null;
  try {
    List<String> resources = new ArrayList<>();

    // 首先，尝试查找包含请求资源的JAR文件的URL。如果找到了一个JAR文件，那么我们将通过读取该JAR来列出子资源。
    URL jarUrl = findJarForResource(url);
    if (jarUrl != null) {
      is = jarUrl.openStream();
      if (log.isDebugEnabled()) {
        log.debug("Listing " + url);
      }
      // 边历 Jar 中的资源，并返回以 path 开头的资源列表
      resources = listResources(new JarInputStream(is), path);
    } else {
      List<String> children = new ArrayList<>();
      try {
        if (isJar(url)) {
          // JBoss VFS的某些版本可能会提供JAR流，即使URL引用的资源实际上不是JAR
          is = url.openStream();
          try (JarInputStream jarInput = new JarInputStream(is)) {
            if (log.isDebugEnabled()) {
              log.debug("Listing " + url);
            }
            for (JarEntry entry; (entry = jarInput.getNextJarEntry()) != null;) {
              if (log.isDebugEnabled()) {
                log.debug("Jar entry: " + entry.getName());
              }
              children.add(entry.getName());
            }
          }
        } else {
          /*
           * 一些servlet容器允许读取目录资源，如文本文件，每行列出一个子资源。然而，仅仅通过读取目录资源和
           * 文件资源是无法区分的。要解决这个问题，在读取每一行时，请尝试通过类加载器将其作为当前资源的子级
           * 进行查找。如果任何一行失败，那么我们假设当前资源不是目录。
           */
          is = url.openStream();
          List<String> lines = new ArrayList<>();
          try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {
            for (String line; (line = reader.readLine()) != null;) {
              if (log.isDebugEnabled()) {
                log.debug("Reader entry: " + line);
              }
              lines.add(line);
              if (getResources(path + "/" + line).isEmpty()) {
                lines.clear();
                break;
              }
            }
          } catch (InvalidPathException | FileSystemException e) {
            // #1974 #2598
            lines.clear();
          }
          if (!lines.isEmpty()) {
            if (log.isDebugEnabled()) {
              log.debug("Listing " + url);
            }
            children.addAll(lines);
          }
        }
      } catch (FileNotFoundException e) {
        /*
         * 对于文件URL，openStream（）调用可能会失败，具体取决于servlet容器，因为无法打开目录进行读取。
         * 如果发生这种情况，请直接列出目录。
         */
        if ("file".equals(url.getProtocol())) {
          File file = new File(url.getFile());
          if (log.isDebugEnabled()) {
            log.debug("Listing directory " + file.getAbsolutePath());
          }
          if (file.isDirectory()) {
            if (log.isDebugEnabled()) {
              log.debug("Listing " + url);
            }
            children = Arrays.asList(file.list());
          }
        } else {
          // No idea where the exception came from so rethrow it
          throw e;
        }
      }

      // 递归列出子资源时要使用的URL前缀
      String prefix = url.toExternalForm();
      if (!prefix.endsWith("/")) {
        prefix = prefix + "/";
      }

      // 遍历children 集合，递归查找符合条件的资源名称 
      for (String child : children) {
        String resourcePath = path + "/" + child;
        resources.add(resourcePath);
        URL childUrl = new URL(prefix + child);
        resources.addAll(list(childUrl, resourcePath));
      }
    }

    return resources;
  } finally {
    if (is != null) {
      try {
        is.close();
      } catch (Exception e) {
        // Ignore
      }
    }
  }
}

protected List<String> listResources(JarInputStream jar, String path) throws IOException {
    // 如果 path 不是以”／”开始和结束，则在其开始和结束位置添加”／”
    if (!path.startsWith("/")) {
        path = "/" + path;
    }
    if (!path.endsWith("/")) {
        path = path + "/";
    }

    // 遍历整个 Jar 色，将以 path 开头的资源记录到 resources 集合中并返回 
    List<String> resources = new ArrayList<>();
    for (JarEntry entry; (entry = jar.getNextJarEntry()) != null;) {
        if (!entry.isDirectory()) {
            // Add leading slash if it's missing
            StringBuilder name = new StringBuilder(entry.getName());
            if (name.charAt(0) != '/') {
                name.insert(0, '/');
            }

            // Check file name
            if (name.indexOf(path) == 0) {
                if (log.isDebugEnabled()) {
                    log.debug("Found resource: " + name);
                }
                // Trim leading slash
                resources.add(name.substring(1));
            }
        }
    }
    return resources;
}
```

## 数据源模块

在数据持久层中，数据源是一个非常重要的组件，其性能直接关系到整个数据持久层的性能。在实践中比较常见的第三方数据源组件有ApacheCommon DBCP,C3PO、Proxool等，MyBatis不仅可以集成第三方数据源组件，还提供了自己的数据源实现。 常见的数据源组件都实现了javax.sql.DataSource接口。MyBatis 提供了两个 jav ax. sq l.DataSource 接口实现，分别是 PooledDataSource 和UnpooledDataSource。 Mybatis 使用不同的DataSourceFactory 接口实现创建不同类型的DataSource，如下所示：

![image-20230424100649550](datasource 实现类.png)

### DataSourceFactory

在数据源模块中， DataSourceFactory 接口扮演工厂接口的角色。 UnpooledDataSourceFactory 和 PooledDataSourceFactory 则扮演着具体工厂类的角色。其定义如下：

```java
public interface DataSourceFactory {

  // 设置 DataSource 的相关属性，一般紧跟在初始化完成之后
  void setProperties(Properties props);

  // 获取DataSource对象
  DataSource getDataSource();

}
```

在 UnpooledDataSourceF actory 的构造函数中会直接创建 UnpooledDataSource 对象，并初始化 UnpooledDataSourceFactory.dataSource 宇段。 UnpooledDataSourceFactory.setProperties（）方法会完成对 UnpooledDataSource 对象的配置，代码如下： 

```java
public void setProperties(Properties properties) {
  Properties driverProperties = new Properties();
  // 创建 DataSource 相应的 MetaObject
  MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);
  // 遍历 properties 集合，该集合中自己置了数据源需要的信息
  for (Object key : properties.keySet()) {
    String propertyName = (String) key;
    if (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) {
      String value = properties.getProperty(propertyName);
      // 以”driver. ”开头的自己置项是对 DataSource 的配置，记录到 driverProperties 中保存 
      driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);
    } else if (metaDataSource.hasSetter(propertyName)) { // 是否有该属性的 setter 方法 
      String value = (String) properties.get(propertyName);
      // 根据属性类型进行类型转换， 主要是 Integer、 Long、 Boolean 三种类型的转换 
      Object convertedValue = convertValue(metaDataSource, propertyName, value);
      // 设置 DataSource 的相关属性值 
      metaDataSource.setValue(propertyName, convertedValue);
    } else {
      throw new DataSourceException("Unknown DataSource property: " + propertyName);
    }
  }
  if (driverProperties.size() > 0) {
    // 设置 DataSource.driverProperties 属性值
    metaDataSource.setValue("driverProperties", driverProperties);
  }
}
```

UnpooledDataSourceFactory.getDataSource（）方法实现比较简单，它直接返回 dataSource 字段记录的 UnpooledDataSource 对象。 ooledDataSourceFactory 继承了 UnpooledDataSourceF actory，但并没有覆盖 setProperties() 方法和 getDataSource（）方法。两者唯一的区别是 PooledDataSourceFactory 的构造函数会将其dataSource 字段初始化为 PooledDataSource 对象。 JndiDataSourceFactory 是依赖开IDI 服务从容器中获取用户配置的 DataSource。

### UnpooledDataSource

javax叫l.DataSource 接口在数据源模块中扮演了产品接口 的角色， MyBatis 提供了两个DataSource 接口的实现类，分别是 UnpooledDataSource 和 PooledDataSource，它们扮演着具体产品类的角色。 

UnpooledDataSource实现了javax叫l.DataSource接口中定义的getConnection（）方法及其重载方法， 用于获取数据库连接。每次通过 Unpoo ledDataSource. getConnection（）方法获取数据库连接时都会创建一个新连接。 UnpooledDataSource 中的宇段如下，每个字段都有对应的 getter/setter方法： 

```java
private ClassLoader driverClassLoader;// 加载 Driver 类的类加载器 
private Properties driverProperties;// 数据库连接驱动的相关配置 
// 缓存所有已注册的数据库连接驱动 
private static Map<String, Driver> registeredDrivers = new ConcurrentHashMap<>();

private String driver;// 数据库连接的驱动名称 
private String url;
private String username;
private String password;

private Boolean autoCommit;
private Integer defaultTransactionIsolationLevel;
private Integer defaultNetworkTimeout;
```

如下的静态代码块进行jdbc的注册：

```java
static {
    try {
        DriverManager.registerDriver(new Driver());
    } catch (SQLException var1) {
        throw new RuntimeException("Can't register driver!");
    }
}
```

Driver Manager 中定义了 registeredDrivers 字段用于记录注册的 JDBC 驱动，定义如下：

```java
private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();

public static synchronized void registerDriver(java.sql.Driver driver,
                                               DriverAction da)
    throws SQLException {

    /* Register the driver if it has not already been added to our list */
    if(driver != null) {
        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));
    } else {
        // This is for compatibility with the original DriverManager
        throw new NullPointerException();
    }

    println("registerDriver: " + driver);

}
```

下面回到 MyBatis 中 UnpooledDataSourc巳的分析， UnpooledDataSource 中定义了如下静态 代码块，在 UnpooledDataSource 加载时会通过该静态代码块将己在 DriverManager 中注册的 JDBC Driver 复制一份到 UnpooledDataSource.registeredDrivers 集合中。 

```java
static {
  Enumeration<Driver> drivers = DriverManager.getDrivers();
  while (drivers.hasMoreElements()) {
    Driver driver = drivers.nextElement();
    registeredDrivers.put(driver.getClass().getName(), driver);
  }
}
```

UnpooledDataSource.getConnection（）方法的所有重载最终会调用 UnpooledDataSource.doGetConnection（）方法获取数据库连接，具体实现如下： 

```java
private Connection doGetConnection(Properties properties) throws SQLException {
    // 初始化数据库驱动
    initializeDriver();
    // 创建真正的数据连接
    Connection connection = DriverManager.getConnection(url, properties);
    // 配置数据库连接的 autoCommit 和隔离级别 
    configureConnection(connection);
    return connection;
}
```

UnpooledDataSource.initializeDriver（）方法主要负责数据库驱动的初始化，该方法会创建配置中指定的 Driver 对象，并将其注册到 DriverManager 以及上面介绍的 UnpooledDataSource.registeredDrivers 集合中保存。 

```java
private synchronized void initializeDriver() throws SQLException {
  if (!registeredDrivers.containsKey(driver)) {
    Class<?> driverType;
    try {
      if (driverClassLoader != null) {
        driverType = Class.forName(driver, true, driverClassLoader);
      } else {
        driverType = Resources.classForName(driver);
      }
      // 创建 Driver 对象
      Driver driverInstance = (Driver) driverType.getDeclaredConstructor().newInstance();
      // 注册驱动， DriverProxy 是定义在 UnpooledDataSource 中的内部类，是 Driver 的静态代理类 
      DriverManager.registerDriver(new DriverProxy(driverInstance));
      // 将驱动添加到 registeredDrivers 集合中 
      registeredDrivers.put(driver, driverInstance);
    } catch (Exception e) {
      throw new SQLException("Error setting driver on UnpooledDataSource. Cause: " + e);
    }
  }
}
```

UnpooledDataSource.configureConnection（）方法主要完成数据库连接的一系列配置， 具体实现如下： 

```java
private void configureConnection(Connection conn) throws SQLException {
  if (defaultNetworkTimeout != null) {
    conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout);
  }
  if (autoCommit != null && autoCommit != conn.getAutoCommit()) {
    conn.setAutoCommit(autoCommit);
  }
  if (defaultTransactionIsolationLevel != null) {
    conn.setTransactionIsolation(defaultTransactionIsolationLevel);
  }
}
```

### PooledDataSource 

PooledDataSource 实现了简易数据库连接池的功能，其中需要注意的是， PooledDataSource 创建新数据库连接的功能是依赖其中封装的 UnpooledDataSource对象实现的。

PooledDataSource 并不会直接管理 java. sq I. Connection 对象，而是管理 PooledConnection 对象。在 PooledConnection 中封装了真正的数据库连接对象（java.sql.Connection）以及其代理对象，这里的代理对象是通过 JDK 动态代理产生的。 PooledConnection 继承了 lnvocationHandler接口：

PooledConnection 中的核心字段如下：

```java
private static final String CLOSE = "close";
private static final Class<?>[] IFACES = new Class<?>[] { Connection.class };

private final int hashCode;
// 记录当前 PooledConnection 对象所在的 PooledDataSource 对象。 该 PooledConnection 是从
// 该 PooledDataSource 中获取的；当调用 close （）方法时会将 PooledConnection 放回该
// PooledDataSource 中
private final PooledDataSource dataSource;
// 正的数据库连接
private final Connection realConnection;
// 据库连接的代理对象
private final Connection proxyConnection;
// 连接池中取出该连接的时间戳
private long checkoutTimestamp;
private long createdTimestamp;
private long lastUsedTimestamp;
// 由数据库 URL、用户名和密码计算出来的 hash 佳，可用于标识该连接所在的连接池
private int connectionTypeCode;
// 检测当前 PooledConnection 是否有效，主要是为了防止程序通过close （）方法将连接归还给连接池之后，依然通过该连接操作数据库
private boolean valid;
```

PooledConnection.invoke（）方法的实现，该方法是 proxyConn巳ction 这个连接代理对象的真正代理逻辑，它会对 close（）方法的调用进行代理，并且在调用真正数据库连接的方法之前进行检测，代码如下：

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  String methodName = method.getName();
  // 如果调用 close （）方法，则将其重新放入连接池，而不是真正关闭数据库连接
  if (CLOSE.equals(methodName)) {
    dataSource.pushConnection(this);
    return null;
  }
  try {
    if (!Object.class.equals(method.getDeclaringClass())) {
      // 过 valid 字段检测连接是否有效
      checkConnection();
    }
    // 用真正数据库连接对象的对应方法 
    return method.invoke(realConnection, args);
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }

}
```

PoolState 是用于管理 PooledConnection 对象状态的组件，它通过两个 ArrayList <Pooled Connection＞集合分别管理空闲状态的连接和活跃状态的连接，定义如下：

```java
// 空闲的集合
protected final List<PooledConnection> idleConnections = new ArrayList<>();
// 活跃的集合
protected final List<PooledConnection> activeConnections = new ArrayList<>();
```

PoolState 中还定义了一系列用于统计的字段，定义如下：

```java
protected long requestCount = 0;// 数据库连接的次数
protected long accumulatedRequestTime = 0; // 连接数据库累计的时间
protected long accumulatedCheckoutTime = 0;// 累计使用的时间
protected long claimedOverdueConnectionCount = 0;// 长时间为归还的连接个数
protected long accumulatedCheckoutTimeOfOverdueConnections = 0;// 累计超时时间
protected long accumulatedWaitTime = 0;// 累计等待时间
protected long hadToWaitCount = 0;// 等待次数
protected long badConnectionCount = 0;// 无效的连接数
```

PooledDataSource 中管理的真正的数据库连接对象是由 PooledDataSource 中封装的UnpooledDataSource 对象创建的，并由 Poo!State 管理所有连接的状态。 PooledDataSource 中核心字段的含义和功能如下：

```java
// 通过 PoolState 管理连接池的状态并记录统计信息
private final PoolState state = new PoolState(this);
// 记录 UnpooledDataSource 对象，用于生成真实的数据库连接对象，构造函数中会初始化该字段 
private final UnpooledDataSource dataSource;

// 大活跃连接数
protected int poolMaximumActiveConnections = 10;
// 空闲连接数
protected int poolMaximumIdleConnections = 5;
// 最大checkout 时长
protected int poolMaximumCheckoutTime = 20000;
// 在无法获取连接时，线＃呈需妥等待的时间
protected int poolTimeToWait = 20000;
// 大活跃连接数
protected int poolMaximumLocalBadConnectionTolerance = 3;
// 在检测一个数据库连接是否可用时，会给数据库发送一个测试 SQL 语句
protected String poolPingQuery = "NO PING QUERY SET";
// 否允许发送测试 SQL语句
protected boolean poolPingEnabled;
// 当连接超过poolPingConnect工onsNotUsedFor 毫秒未使用时，会发送一次测试 SQL 语句，检测连接是否正常
protected int poolPingConnectionsNotUsedFor;
// 根据数据库的 URL、 用户名和密码生成的一个 hash 佳，该哈希值用于标志着当前的连接池，在构造函数中初始化
private int expectedConnectionTypeCode;
```

PooledDataSource.getConnection（）方法首先会调用 PooledDataSource.popConnection（）方法获取 PooledConnection 对象，然后通过 PooledConnection.getProxyConnection（）方法获取数据库连接的代理对象。 popConnection（）方法是 PooledDataSource 的核心逻辑之一，代码如下：

```java
private PooledConnection popConnection(String username, String password) throws SQLException {
  boolean countedWait = false;
  PooledConnection conn = null;
  long t = System.currentTimeMillis();
  int localBadConnectionCount = 0;

  while (conn == null) {
    // 加锁
    lock.lock();
    try {
      // 检测空闲连接
      if (!state.idleConnections.isEmpty()) {
        // 获取连接
        conn = state.idleConnections.remove(0);
        if (log.isDebugEnabled()) {
          log.debug("Checked out connection " + conn.getRealHashCode() + " from pool.");
        }
      } else {
        // 当前连接池没有空闲连接，活跃连接数没有到最大佳，则可以创建新连接
        if (state.activeConnections.size() < poolMaximumActiveConnections) {
          // Can create new connection
          conn = new PooledConnection(dataSource.getConnection(), this);
          if (log.isDebugEnabled()) {
            log.debug("Created connection " + conn.getRealHashCode() + ".");
          }
        } else {
          // 活跃连接数已到最大值，则不能创建新连接
          // 获取最先创建的活跃连接
          PooledConnection oldestActiveConnection = state.activeConnections.get(0);
          long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();
          // 检测该连接是否超时
          if (longestCheckoutTime > poolMaximumCheckoutTime) {
            // 对超时连接的信息进行统计
            state.claimedOverdueConnectionCount++;
            state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;
            state.accumulatedCheckoutTime += longestCheckoutTime;
            // 将起时连接移出 activeConnections 集合
            state.activeConnections.remove(oldestActiveConnection);
            // 如果超时连接未提交，则自动回滚
            if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {
              try {
                oldestActiveConnection.getRealConnection().rollback();
              } catch (SQLException e) {
                log.debug("Bad connection. Could not roll back");
              }
            }
            // 创建新 PooledConnect工on 对象，但是真正的数据库连接并未创建新的
            conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);
            conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());
            conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());
            // 将超时PooledConnection 设置为无效
            oldestActiveConnection.invalidate();
            if (log.isDebugEnabled()) {
              log.debug("Claimed overdue connection " + conn.getRealHashCode() + ".");
            }
          } else {
            // 元空闲连接、无法创建新连接且无超时连接， 9]1j只能阻塞等待
            try {
              if (!countedWait) {
                // 统计等待次数
                state.hadToWaitCount++;
                countedWait = true;
              }
              if (log.isDebugEnabled()) {
                log.debug("Waiting as long as " + poolTimeToWait + " milliseconds for connection.");
              }
              long wt = System.currentTimeMillis();
              condition.await(poolTimeToWait, TimeUnit.MILLISECONDS);
              state.accumulatedWaitTime += System.currentTimeMillis() - wt;
            } catch (InterruptedException e) {
              // set interrupt flag
              Thread.currentThread().interrupt();
              break;
            }
          }
        }
      }
      if (conn != null) {
        // 测 PooledConnecttion 是否有效 
        if (conn.isValid()) {
          if (!conn.getRealConnection().getAutoCommit()) {
            conn.getRealConnection().rollback();
          }
          // 配置 PooledConnection 的相关属性，设置 connectionTypeCode、
          // checkoutTimestamp、 lastUsedTimestamp 字段的位
          conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));
          conn.setCheckoutTimestamp(System.currentTimeMillis());
          conn.setLastUsedTimestamp(System.currentTimeMillis());
          state.activeConnections.add(conn);
          state.requestCount++;
          state.accumulatedRequestTime += System.currentTimeMillis() - t;
        } else {
          if (log.isDebugEnabled()) {
            log.debug("A bad connection (" + conn.getRealHashCode()
                + ") was returned from the pool, getting another connection.");
          }
          state.badConnectionCount++;
          localBadConnectionCount++;
          conn = null;
          if (localBadConnectionCount > (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) {
            if (log.isDebugEnabled()) {
              log.debug("PooledDataSource: Could not get a good connection to the database.");
            }
            throw new SQLException("PooledDataSource: Could not get a good connection to the database.");
          }
        }
      }
    } finally {
      lock.unlock();
    }

  }

  if (conn == null) {
    if (log.isDebugEnabled()) {
      log.debug("PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.");
    }
    throw new SQLException(
        "PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.");
  }

  return conn;
}
```

通过前面对 PooledConnection.invoke（）方法的分析我们知道， 当调用连接的代理对象的close（）方法时，并未关闭真正的数据连接，而是调用 PooledDataSource.pushConnection（）方法将PooledConnection 对象归还给连接池，供之后重用。 PooledDataSource.pushConnection（）方法也是PooledDataSource 的核心逻辑之一，代码如下：

```java
protected void pushConnection(PooledConnection conn) throws SQLException {
  // 加锁
  lock.lock();
  try {
    // 从 activeConnections 集合中移除该 PooledConnection 对象
    state.activeConnections.remove(conn);
    // 检测 PooledConnection 对象是否有效
    if (conn.isValid()) {
      // 检测空闲连接数是否已达到上限，以及 PooledConnection 是否为该连接池的连接
      if (state.idleConnections.size() < poolMaximumIdleConnections
          && conn.getConnectionTypeCode() == expectedConnectionTypeCode) {
        state.accumulatedCheckoutTime += conn.getCheckoutTime();
        // 回滚未提交的事务
        if (!conn.getRealConnection().getAutoCommit()) {
          conn.getRealConnection().rollback();
        }
        // 为返还连接创建新的 PooledConnection 对象s
        PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);
        // 添加到 idleConnections 集合
        state.idleConnections.add(newConn);
        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());
        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());
        // 将原 PooledConnection 对象设置为无效 
        conn.invalidate();
        if (log.isDebugEnabled()) {
          log.debug("Returned connection " + newConn.getRealHashCode() + " to pool.");
        }
        // 醒阻塞等待的线程
        condition.signal();
      } else {
        // 空闲连接数已达到上限或 PooledConnection 对象并不属于该连接池 
        state.accumulatedCheckoutTime += conn.getCheckoutTime();
        if (!conn.getRealConnection().getAutoCommit()) {
          conn.getRealConnection().rollback();
        }
        conn.getRealConnection().close();
        if (log.isDebugEnabled()) {
          log.debug("Closed connection " + conn.getRealHashCode() + ".");
        }
        conn.invalidate();
      }
    } else {
      if (log.isDebugEnabled()) {
        log.debug("A bad connection (" + conn.getRealHashCode()
            + ") attempted to return to the pool, discarding connection.");
      }
      state.badConnectionCount++;
    }
  } finally {
    lock.unlock();
  }
}
```

PooledConnection.isValid（）方法来检测 PooledConnection 的有效性 ， 该方法除了检测PooledConnection. valid 宇段的值，还会调用 PooledDataSource.pingConnection（）方法尝试让数据库执行 poolPingQuery 字段中记录的测试 SQL 语句，从而检测真正的数据库连接对象是否依然可以正常使用。 isValid（）方法以及 pingConnection（）方法的代码如下：

```java
protected boolean pingConnection(PooledConnection conn) {
  // 记录ping 操作是否成功
  boolean result = true;

  try {
    // 检测真正的数据库连接是否已经关闭
    result = !conn.getRealConnection().isClosed();
  } catch (SQLException e) {
    if (log.isDebugEnabled()) {
      log.debug("Connection " + conn.getRealHashCode() + " is BAD: " + e.getMessage());
    }
    result = false;
  }
  // 检测 poolPingEnabled 设置，是否运行执行测试 SQL 语句
  // 长时间（超过 poolPingConnectionsNotUsedFor 指定的时长）未使用的连接，才需要 ping
  // 操作来检测数据库连接是否正常
  if (result && poolPingEnabled && poolPingConnectionsNotUsedFor >= 0
      && conn.getTimeElapsedSinceLastUse() > poolPingConnectionsNotUsedFor) {
    try {
      if (log.isDebugEnabled()) {
        log.debug("Testing connection " + conn.getRealHashCode() + " ...");
      }
      Connection realConn = conn.getRealConnection();
      try (Statement statement = realConn.createStatement()) {
        statement.executeQuery(poolPingQuery).close();
      }
      if (!realConn.getAutoCommit()) {
        realConn.rollback();
      }
      result = true;
      if (log.isDebugEnabled()) {
        log.debug("Connection " + conn.getRealHashCode() + " is GOOD!");
      }
    } catch (Exception e) {
      log.warn("Execution of ping query '" + poolPingQuery + "' failed: " + e.getMessage());
      try {
        conn.getRealConnection().close();
      } catch (Exception e2) {
        // ignore
      }
      result = false;
      if (log.isDebugEnabled()) {
        log.debug("Connection " + conn.getRealHashCode() + " is BAD: " + e.getMessage());
      }
    }
  }
  return result;
}
```

最后需要注意的是 PooledDataSource.forceCloseAII（）方法，当修改 PooledDataSource 的字段时，例如数据库 URL、用户名、 密码、 autoCornmit 配置等， 都会调用 forceCloseAII（）方法将所有数据库连接关 闭， 同 时也会将所有相应 的 PooledConnection 对象都设置为无效，清空前tiveConnecti ons 集合 和 idleConnections 集合。应用系统之后通过 PooledDataSource.getConnection（） 获 取连 接 时 ，会 按照新的配置重新创建新的数据库连接以 及 相 应 的PooledConnection 对象。 forceCloseAll（）方法的具体实现如下：

```java
public void forceCloseAll() {
  lock.lock();
  try {
    // 更新当前连接池的标识
    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(),
        dataSource.getPassword());
    for (int i = state.activeConnections.size(); i > 0; i--) {
      // 全部的活跃连接
      try {
        // 从 PoolState.activeConnections 集合中获取 PooledConnection 对象
        PooledConnection conn = state.activeConnections.remove(i - 1);
        conn.invalidate();

        Connection realConn = conn.getRealConnection();
        if (!realConn.getAutoCommit()) {
          realConn.rollback();
        }
        realConn.close();
      } catch (Exception e) {
        // ignore
      }
    }
    for (int i = state.idleConnections.size(); i > 0; i--) {
      try {
        PooledConnection conn = state.idleConnections.remove(i - 1);
        conn.invalidate();

        Connection realConn = conn.getRealConnection();
        if (!realConn.getAutoCommit()) {
          realConn.rollback();
        }
        realConn.close();
      } catch (Exception e) {
        // ignore
      }
    }
  } finally {
    lock.unlock();
  }
  if (log.isDebugEnabled()) {
    log.debug("PooledDataSource forcefully closed/removed all connections.");
  }
}
```

## 事务管理模块

MyBatis 使用 Transaction 接口对数据库事务进行了抽象， Transaction 接口的定义如下： 

```java
public interface Transaction {
    // 获取对应的数据库连接对象
    Connection getConnection() throws SQLException;
    // 提交事务
    void commit() throws SQLException;
    // 回滚事务
    void rollback() throws SQLException;
    // 关闭数据库连接
    void close() throws SQLException;
    // 获取事务超时时间
    Integer getTimeout() throws SQLException;
}
```

Transaction接口有 JdbcTransaction 、ManagedTransaction 两个实现，其对象分别 由 JdbcTransactionFactory和 ManagedTransactionFactory 负责创建。 

![image-20230425101908206](Transaction 工厂模式创建.png)

JdbcTransaction 依赖于 JDBC Connection 控制事务的提交和回滚。 JdbcTransaction 中字段的含义如下：

```java
protected Connection connection;
protected DataSource dataSource;
protected TransactionIsolationLevel level;
protected boolean autoCommit;
```

在 JdbcTransaction 的构造函数中会初始化除 connection 字段之外的其他三个字段， 而 connection宇段会延迟初始化，它会在调用 getConnection（）方法时通过dataSource.getConnection() 方法初始化，并且同时设置 autoCommit 和事务隔离级别。 JdbcTransaction 的 commit（）方法和 rollback（）方法都会调用 Connection 对应方法实现的。

ManagedTransaction 的实现更加简单，它同样依赖其中的 dataSource 宇段获取连接， 但其commit（）、 rollback（）方法都是空实现，事务的提交和回漆都是依 靠容器管理的 。Managed Transaction 中通过 closeConnection 宇段的值控制数据库连接的关闭行为。

```java
public void close() throws SQLException {
  if (this.closeConnection && this.connection != null) {
    if (log.isDebugEnabled()) {
      log.debug("Closing JDBC Connection [" + this.connection + "]");
    }
    this.connection.close();
  }
}
```

TransactionFactory 接口定义了配置新建 TransactionFactory 对象的方法 ，以及创建Transaction 对象的方法，代码如下：

```java
public interface TransactionFactory {
    // 自己置Transact工onFactory对象，一般紧跟在创建完成之后， 完成对TransactionFactory的自定义配置
    default void setProperties(Properties props) {}
    
    // 在指定的连接上创建 Transaction 对象 
    Transaction newTransaction(Connection conn);
    
    // 从指定数据源中获取数据库连接，并在此连接之上创建 Transaction 对象
    Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);

}
```

## binding模块

Mapper 接口中定义了 SQL 语句对应的方法，这些方法在 MyBatis 初始化过程中会与映射配置文件中定义的 SQL 语句相关联。如果存在无法关联的 SQL 语句，在 MyBatis 的初始化节点就会抛出异常。我们可以调用 Mapper 接口中的方法执行相应的 SQL 语句，这样编译器就可以帮助我们提早发现上述问题。查询 Blog 对象就变成了如下代码：

- 首先，获取 BlogMapper 对应的代理对象
- 调用 Mapper 接口中定义的方法执行对应的 SQL 语句

### MapperRegistry&MapperProxyFactory

Mapper Register是 Mapper 接口及其对应的代理对象工厂的注册中心。 Configuration 是My Batis 全局性的配置对象，在 MyBatis 初始化的过程中，所有配置信息会被解析成相应的对象井记录到 Configuration对象中，Mapper Register 中字段的含义和功能如下：

```java
// Configuration 对象， MyBatis 全局唯一的配置对象，其中包含了所有配置信息
private final Configuration config;
// 记录了 Mapper 接口与对应 MapperProxyFactory 之间的关系 
private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<>();
```

在 MyBatis 初始化过程中会读取映射配置文件以及 Mapper 接口中的注解信息，并调用 Mapper Register.addMapperO方法填充 M叩perRegistry.knownMappers 集合， 该集合的 key 是 Mapper 接口对应的 Class 对象， value 为 MapperProxyFactory 工厂对象，可以为 Mapper 接口创建代理对象， MapperRegistry.addMapper（）方法的部分实现如下：

```java
public <T> void addMapper(Class<T> type) {
  if (type.isInterface()) {
    if (hasMapper(type)) {
      throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
    }
    boolean loadCompleted = false;
    try {
      knownMappers.put(type, new MapperProxyFactory<>(type));
      // 在运行解析器之前添加类型是很重要的，否则映射器解析器可能会自动尝试绑定。如果类型已知，则不会尝试。
      MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
      parser.parse();
      loadCompleted = true;
    } finally {
      if (!loadCompleted) {
        knownMappers.remove(type);
      }
    }
  }
}
```

在需要执行某 SQL 语句时，会先调用 MapperRegistry.getMapper（）方法获取实现了 Mapper接口的代理对象，实际上是MyBatis通过JDK动态代理为BlogMapper接口生成的代理对象。MapperRegister.getMapper()方法的代码如下所示：

```java
public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
  final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
  }
  try {
    // 创建实现了 type 接口的代理对象
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException("Error getting mapper instance. Cause: " + e, e);
  }
}
```

MapperProxyFactory 主要负责创建代理对象， 其中核心字段的含义和功能如下：

```java
// 当前MapperProxyFactory 对象可以创建实现了 mapperInterface接口的代理对象
private final Class<T> mapperInterface;
// 缓存， key是mapperinterface接口中某方法对应的 Method对象， value 是对应的 MapperMethod对象
private final Map<Method, MapperMethodInvoker> methodCache = new ConcurrentHashMap<>();
```

### MapperProxy

Mapper Proxy 实现了 lnvocationHandler 接口,该接口的实现是代理对象的核心逻辑，这里不再重复描述。 MapperProxy 中核心宇段的含义和功能如下：

```java
// 记录了关联的 SqlSession 对象
private final SqlSession sqlSession;
// Mapper接口对应的 Class 对象 
private final Class<T> mapperInterface;
// 用于缓存MapperMethod对象，其中key是Mapper接口中方法对应的 Method对象，value是对应的 
// MapperMethod 对象。 MapperMethod 对象会完成参数转换以及 SQL 语句的执行功能 
// 需要注意的是， MapperMethod 中并不记录任何状态相关的信息，所以可以在多个代理对象之间共享
private final Map<Method, MapperMethodInvoker> methodCache;
```

MapperProxy. invokeO方法是代理对象执行的主要逻辑， 实现如下： 

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    // 如采目标方法继承自 Object，则直接调用目标方法
    if (Object.class.equals(method.getDeclaringClass())) {
      return method.invoke(this, args);
    } else {
      // 从缓存中获取MapperMethod 对象，如采缓存中没有，则创建新的 MapperMethod对象并添加到缓存中
      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
    }
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }
}

// 通过缓存Invoker对象来避免重复创建Invoker对象的开销
private MapperMethodInvoker cachedInvoker(Method method) throws Throwable {
    try {
        return MapUtil.computeIfAbsent(methodCache, method, m -> {
            if (m.isDefault()) {
                try {
                    if (privateLookupInMethod == null) {
                        return new DefaultMethodInvoker(getMethodHandleJava8(method));
                    } else {
                        return new DefaultMethodInvoker(getMethodHandleJava9(method));
                    }
                } catch (IllegalAccessException | InstantiationException | InvocationTargetException
                         | NoSuchMethodException e) {
                    throw new RuntimeException(e);
                }
            } else {
                return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));
            }
        });
    } catch (RuntimeException re) {
        Throwable cause = re.getCause();
        throw cause == null ? re : cause;
    }
}
```

### MapperMethod

Mapper Method 中封装了 Mapper 接口中对应方法的信息，以及对应 SQL 语句的信息。可以将 MapperMethod 看作连接 Mapper 接口以及映射配置文件中定义的 SQL 语句的桥梁。Mapper Method 中各个字段的信息如下：

```java
// 录了SQL语句的名称和类型
private final SqlCommand command;
// Mapper接口中对应方法的相关信息
private final MethodSignature method;
```

SqlCommand 是 MapperMethod 中定义的内部类，它使用 name 字段记录了 SQL语句的名称，使用 type 宇段（SqlCommandType 类型）记录了 SQL 语句的类型。 SqlCommandType 是枚举类型，有效取值为 UNKNOWN、 INSERT、 UPDATE、 DELETE、 SELECT、 FLUSH。SqICommand 的构造方法会初始化 name 字段和 type 字段，代码如下：

```java
private MappedStatement resolveMappedStatement(Class<?> mapperInterface, String methodName, Class<?> declaringClass,
                                               Configuration configuration) {
    // SQL 语句的名称是由 Mapper 接口的名称与对应的方法名称组成的
    String statementId = mapperInterface.getName() + "." + methodName;
    // 检测是否有该名称的 SQL 语句 
    if (configuration.hasStatement(statementId)) {
        // 从 Configuration.πiappedStatements 集合中查找对应的 MappedStatement 对象
        return configuration.getMappedStatement(statementId);
    } else if (mapperInterface.equals(declaringClass)) {
        return null;
    }
    // 如果指定方法是在父接口中定义的， 则在此进行继承结构的处理	
    for (Class<?> superInterface : mapperInterface.getInterfaces()) {
        if (declaringClass.isAssignableFrom(superInterface)) {
            MappedStatement ms = resolveMappedStatement(superInterface, methodName, declaringClass, configuration);
            if (ms != null) {
                return ms;
            }
        }
    }
    return null;
}
}
```

在 MethodSignature 中， 会使用 ParamNameResolver 处理 Mapper 接口中定义的方法的参数 列表。 ParamNameResolver 使用 name 宇段（SortedMap<Integer, String＞类型）记录了参数在参 数列表中的位置索引与参数名称之间的对应关系，其中 key 表示参数在参数列表中的索引位置， value 表示参数名称，参数名称可以通过＠Param 注解指定，如果没有指定＠Param 注解，则使用参数索寻引作为其名称。 

ParamNameResolver 的 hasParamAnnotation 字段（boolean 类型）记录对应方法的参数列表中是否使用了＠Param 注解。在 ParamNameResolver 的构造方法中，会通过反射的方式读取 Mapper 接口中对应方法的信息，井初始化上述两个字段，具体实现代码如下：

```java
public ParamNameResolver(Configuration config, Method method) {
  this.useActualParamName = config.isUseActualParamName();
  final Class<?>[] paramTypes = method.getParameterTypes();
  final Annotation[][] paramAnnotations = method.getParameterAnnotations();
  final SortedMap<Integer, String> map = new TreeMap<>();
  int paramCount = paramAnnotations.length;
  // get names from @Param annotations
  for (int paramIndex = 0; paramIndex < paramCount; paramIndex++) {
    if (isSpecialParameter(paramTypes[paramIndex])) {
      // 如果参数是 RowBounds 类型或 ResultHandler 类型，贝1］跳过对该参数的分析
      continue;
    }
    String name = null;
    for (Annotation annotation : paramAnnotations[paramIndex]) {
      if (annotation instanceof Param) {
        // @Param 注解出现过一次，就将 hasParamAnnotation 初始化为 true
        hasParamAnnotation = true;
        name = ((Param) annotation).value();
        break;
      }
    }
    if (name == null) {
      // 该参数没有对应的＠Param注解，则根据自己置决定是否使用参数实际名称作为其名称
      if (useActualParamName) {
        name = getActualParamName(method, paramIndex);
      }
      if (name == null) {
        // 用参数的索引作为其名称
        name = String.valueOf(map.size());
      }
    }
    map.put(paramIndex, name);
  }
  names = Collections.unmodifiableSortedMap(map);
}


// isSpecialParameter （）方法用来过滤 RowBounds 和 ResultHandler 两种类型的参数 
private static boolean isSpecialParameter(Class<?> clazz) {
    return RowBounds.class.isAssignableFrom(clazz) || ResultHandler.class.isAssignableFrom(clazz);
}
```

names 集合主要在 ParamNameResolver.getNamedParams（）方法中使用，该方法接收的参数是用户传入的实参列表，并将实参与其对应名称进行关联，具体代码如下： 

```java
public Object getNamedParams(Object[] args) {
  final int paramCount = names.size();
  if (args == null || paramCount == 0) {
    return null;
  } else if (!hasParamAnnotation && paramCount == 1) {
    Object value = args[names.firstKey()];
    return wrapToMapIfCollection(value, useActualParamName ? names.get(names.firstKey()) : null);
  } else {
    // 处理使用自Param d主解指定了参数名称或有多个参数的情况 
    // param 这个 Map 中记录了参数名称与实参之间的对应关系。 ParamMap 继承了 HashMap，如果向 
    // ParamMap 中添加已经存在的 key，会报错，其他行为与 HashMap相同 
    final Map<String, Object> param = new ParamMap<>();
    int i = 0;
    for (Map.Entry<Integer, String> entry : names.entrySet()) {
      param.put(entry.getValue(), args[entry.getKey()]);
      // 下面是为参数创建”param＋索号｜”格式的默认参数名称，
      final String genericParamName = GENERIC_NAME_PREFIX + (i + 1);
      // 如采＠Param注解指定的参数名称就是”param＋索引”格式的，则不需要再添加 
      if (!names.containsValue(genericParamName)) {
        param.put(genericParamName, args[entry.getKey()]);
      }
      i++;
    }
    return param;
  }
}
```

MethodSignature 也是 MapperMethod 中定义的内部类，其中封装了 Mapper 接口中定义的方法的相关信息， MethodSignature 中核心字段的含义如下： 

```java
// 返回值类型是否为 Collection 类型或是数组类型 
private final boolean returnsMany;
// 返回值类型是否为 Map 类型 
private final boolean returnsMap;
// 返回值类型是否为 viod
private final boolean returnsVoid;
// 返回值是否为Cursor类型
private final boolean returnsCursor;
// 返回值类型
private final boolean returnsOptional;
// 返回值类型
private final Class<?> returnType;
// 如果返回值类型是Map，则该字段记录了作为 key 的列名 
private final String mapKey;
// 用来标记该方法参数列表中 ResultHandler 类型参数的位置 
private final Integer resultHandlerIndex;
// 用来标记该方法参数列表中 RowBounds 类型参数的位置 
private final Integer rowBoundsIndex;
// 该方法对应的 ParamNameResolver 对象 
private final ParamNameResolver paramNameResolver;
```

在MethodSignature 的构造函数中会解析相应的Method对象，并初始化上述字段，具体代码如下： 

```java
public MethodSignature(Configuration configuration, Class<?> mapperInterface, Method method) {
  Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);
  if (resolvedReturnType instanceof Class<?>) {
    this.returnType = (Class<?>) resolvedReturnType;
  } else if (resolvedReturnType instanceof ParameterizedType) {
    this.returnType = (Class<?>) ((ParameterizedType) resolvedReturnType).getRawType();
  } else {
    this.returnType = method.getReturnType();
  }
  // 初始化
  this.returnsVoid = void.class.equals(this.returnType);
  this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) ||     this.returnType.isArray();
  this.returnsCursor = Cursor.class.equals(this.returnType);
  this.returnsOptional = Optional.class.equals(this.returnType);
  // 若MethodSignature 对应方法的返回位是Map 且指定了＠MapKey j主解， ~1］使用 getMapKey （）方法处理
  this.mapKey = getMapKey(method);
  this.returnsMap = this.mapKey != null;
  // 初始化 rowBoundsindex 和 resultHandlerindex 字段
  this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);
  this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);
  // 创建 ParamNameResolver 对象
  this.paramNameResolver = new ParamNameResolver(configuration, method);
}
```

getUniqueParamlndexO方法的主要功能是查找指定类型的参数在参数列表中的位置，如下：

```java
private Integer getUniqueParamIndex(Method method, Class<?> paramType) {
  Integer index = null;
  final Class<?>[] argTypes = method.getParameterTypes();
  for (int i = 0; i < argTypes.length; i++) {
    if (paramType.isAssignableFrom(argTypes[i])) {
      // 记录 paramType 类型参数在参数列表中的位置索引 
      if (index == null) {
        index = i;
      } else {
        // RowBounds 和 ResultHandler 类型的参数只能有一个，不能重复出现 
        throw new BindingException(
            method.getName() + " cannot have multiple " + paramType.getSimpleName() + " parameters");
      }
    }
  }
  return index;
}
```

MapperMethod 中最核心的方法是 execute（）方法，它会根据 SQL 语句的类型调用 SqI Session 对应的方法完成数据库操作。 SqlSession 是 MyBatis 的核心组件之一。MapperMethod.execute（）方法的具体实现如下： 

```java
public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  // 根据 SQL 语句的类型调用 SqlSession 对应的方法
  switch (command.getType()) {
    case INSERT: {
      // 使用 ParamNameResolver 处理 args ［］数量且（用户传入的实参列表）
      Object param = method.convertArgsToSqlCommandParam(args);
      // 调用 SqlSession.insert （）方法， rowCountResult （）方法会根据method 字段中记录的方法的
      // 返回值类型对结果进行转换
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      // 处理返回值为 void 且 ResultSet 通过 ResultHandler 处理的方法
      if (method.returnsVoid() && method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
        if (method.returnsOptional() && (result == null || !method.getReturnType().equals(result.getClass()))) {
          result = Optional.ofNullable(result);
        }
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException("Unknown execution method for: " + command.getName());
  }
  if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {
    throw new BindingException("Mapper method '" + command.getName()
        + "' attempted to return null from a method with a primitive return type (" + method.getReturnType() + ").");
  }
  return result;
}
```

当执行 INSERT、UPDATE、DELETE 类型的 SQL 语句时，其执行结果都需要经过 MapperMethod.rowCountResult（）方法处理。 SqI Session 中的 insert（）等方法返回的是 int 值， rowCountResult（）方法会将该 int 值转换成 Mapper 接口中对应方法的返回值，具体实现如下： 

```java
private Object rowCountResult(int rowCount) {
  final Object result;
  if (method.returnsVoid()) {
    // Mapper 接口中相应方法的返回值为 void
    result = null;
  } else if (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) {
    // Mapper 接口中相应方法的返回值为 Integer or int
    result = rowCount;
  } else if (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) {
    result = (long) rowCount;
  } else if (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) {
    result = rowCount > 0;
  } else {
    throw new BindingException(
        "Mapper method '" + command.getName() + "' has an unsupported return type: " + method.getReturnType());
  }
  return result;
}
```

如果 Mapper 接口中对应方法的返回值为数组或是 Collection 接口实现类，则通过 MapperMethod.executeForMany （）方法处理，具体实现如下：

```java
private <E> Object executeForMany(SqlSession sqlSession, Object[] args) {
  List<E> result;
  Object param = method.convertArgsToSqlCommandParam(args);
  // 检测是否制定RowBounds
  if (method.hasRowBounds()) {
    RowBounds rowBounds = method.extractRowBounds(args);
    result = sqlSession.selectList(command.getName(), param, rowBounds);
  } else {
    result = sqlSession.selectList(command.getName(), param);
  }
  // 将结采集转换为数纽或 Collection 集合
  if (!method.getReturnType().isAssignableFrom(result.getClass())) {
    if (method.getReturnType().isArray()) {
      return convertToArray(result);
    } else {
      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);
    }
  }
  return result;
}
```

convertToDeclaredCollection（）方法和 convertToArray（）方法的功能类似， 主要负责将结果对象转换成 Collection 集合对象和数组对象， 具体实现如下： 

```java
private <E> Object convertToDeclaredCollection(Configuration config, List<E> list) {
  Object collection = config.getObjectFactory().create(method.getReturnType());
  MetaObject metaObject = config.newMetaObject(collection);
  // 实际上就是调用 Collection. addAll （）方法
  metaObject.addAll(list);
  return collection;
}

private <E> Object convertToArray(List<E> list) {
    Class<?> arrayComponentType = method.getReturnType().getComponentType();
    Object array = Array.newInstance(arrayComponentType, list.size());
    if (arrayComponentType.isPrimitive()) {
        for (int i = 0; i < list.size(); i++) {
            Array.set(array, i, list.get(i));
        }
        return array;
    } else {
        return list.toArray((E[]) array);
    }
}
```

如果 Mapper接口中对应方法的返回值为 Map 类型， 则通过MapperMethod.executeFor Map () 方法处理，具体实现如下：

```java
  private <K, V> Map<K, V> executeForMap(SqlSession sqlSession, Object[] args) {
    Map<K, V> result;
    Object param = method.convertArgsToSqlCommandParam(args);
    if (method.hasRowBounds()) {
      RowBounds rowBounds = method.extractRowBounds(args);
      result = sqlSession.selectMap(command.getName(), param, method.getMapKey(), rowBounds);
    } else {
      result = sqlSession.selectMap(command.getName(), param, method.getMapKey());
    }
    return result;
  }
```

executeF orCursor（）方法与 executeForMap O方法类似，唯一区别就是调用了 SqlSession 的 selectCursor（）方法

## 缓存模块

MyBatis 中的缓存是两层结构的，分为一级缓存、二级缓存，但在本质上是相同的，它们使用的都是 Cache 接口的实现。

### Cache 接口及其实现 

```java
public interface Cache {
    
    // 该缓存对象的id
	String getId();
    // 向缓存中添加数据，一般情况下， key是CacheKey, value 是查询结果 
    void putObject(Object key, Object value);
    // 据指定的 key，在缓存中查找对应的结果对象
    Object getObject(Object key);
    // 删除key对应的缓存项
    Object removeObject(Object key);
    // 清空缓存
    void clear();
    // 存储在缓存中的元素数
    int getSize();
    // 获取读写锁
    default ReadWriteLock getReadWriteLock() {
       return null;
    }
}
```

Cache 接口的实现类有多个，但大部分都是装饰器，只有 PerpetualCache提供了 Cache 接口的基本实现。

### Perpetual Cache

PerpetualCache 在缓存模块中扮演着 ConcreteComponent 的角色，其实现比较简单，底层使用 HashMap 记录缓存项，也是通过该 HashMap 对象的方法实现的 Cache 接口中定义的相应方法。 PerpetualCache 的具体实现如下：

















# 注解

## @Arg

用于为构造函数参数指定映射定义的注释：

```java
	@Select("select * from mk_user")
	@ConstructorArgs(value = {
			@Arg(column = "id", javaType = Integer.class),
			@Arg(column = "name", javaType = String.class),
			@Arg(column = "gender", javaType = Gender.class, typeHandler = EnumTypeHandler.class),
			@Arg(column = "id", javaType = List.class, select = "com.demo.mapper.RoleMapper.getRoleByUserId")
	})
	List<User> findAll2();
```

可以在@ConstructorArgs重复使用，这点在源码中可以看到：

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(ConstructorArgs.class)// @ConstructorArgs中重复使用
public @interface Arg {
```

## @ConstructorArgs

作为实体类的构造函数，结合上面的@Arg进行使用，构建实体类：

```java
@ConstructorArgs(value = {
    @Arg(column = "id", javaType = Integer.class),
    @Arg(column = "other", javaType = String.class),
    @Arg(column = "an_other", javaType = String.class),
    @Arg(column = "date", javaType = Date.class)})
@Select("select * from test")
List<Test> selectFull();
```

<span style="color:red">实体类必须有这个入参的构造函数。</span>

## @AutomapConstructor

用于自动映射的构造函数的标记批注。



## @Case

结合@TypeDiscriminatort条件映射的注解，作为条件选择的注解：

```java
@TypeDiscriminator(column = "type",javaType = String.class,
                   cases = {
                       @Case(value = "1", type = CatTest.class,results = {@Result(property = "catTest",column = "cat_test")}),
                       @Case(value = "2", type = DogTest.class,results = {@Result(property = "dogTest",column = "dog_test")})})
@Select("SELECT id, type, other, date,cat_test, dog_test FROM test")
List<Test> selectFull2();
```

## @TypeDiscriminator

分组映射的注解，与@Case一起使用。

## @CacheNamespace

指定在命名空间上使用缓存的注释，作用于mapper接口上面，是用来实现二级缓存的。

```java
@CacheNamespace
public interface TestMapper {

    /**
     * xml定义查询
     *
     * @param test
     * @return
     */
    List<Test> selectList(Test test);
```

配置文件需要开启缓存：

```xml
<setting name="cacheEnabled" value="true"/>
```

配置文件和接口注释配合使用时，需要在xml配置文件中配置<cache>属性， 同时在接口中修改注释为@CacheNamespaceRef。

## @CacheNamespaceRef

引用缓存注解，只有两个属性vlaue和name，都需要指定。Java里面没有指针，但是Java里面有引用，CacheNamespaceRef就是一个引用。CacheNamespaceRef当做CacheNamespace的短链接、快捷键，它是CacheNamespace的引用。CacheNamespaceRef的作用：

我们知道，MyBatis分为一级缓存和二级缓存。一级缓存是会话（session）级别的，二级缓存是应用（application）级别的。但是，MyBatis并不是简单地对整个Application就只有一个Cache缓存对象，它将缓存划分的更细，即是Mapper级别的，即每一个Mapper都可以拥有一个Cache对象，具体如下： 

1. 为每一个Mapper分配一个Cache缓存对象使用<cache>节点配置或者 @CacheNamespace注解 ）；
2. 多个Mapper共用一个Cache缓存对象（使用<cache-ref>节点配置或者本文所提到的@CacheNamespaceRef注解）；

Mybatis 二级缓存示意图：![img](Mybatis 二级缓存示意图.png)

## @MapKey

指定键值的属性名（或列名）作为map的key值，实体类作为value：

```
@MapKey("id")
@Select("select * from test")
Map<Integer,Test> selectMapKey();
```

## @One

指定用于检索单个对象的嵌套语句的注释（结合Result使用）。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({})
public @interface One {
  /**
   * 返回字段前缀
   *
   * @return the columnPrefix.
   *
   * @since 3.5.5
   */
  String columnPrefix() default "";
  /**
   * 返回用于映射单个对象的结果映射id。
   *
   * @return the result map id
   *
   * @since 3.5.5
   */
  String resultMap() default "";
  /**
   * 返回检索单个对象的语句id。
   *
   * @return the statement id
   */
  String select() default "";
  /**
   * 返回嵌套语句的获取策略。
   *
   * @return the fetch strategy
   */
  FetchType fetchType() default FetchType.DEFAULT;
}
```

## @Many

指定用于检索集合的嵌套语句的注释。

```java
@Result(property = "roleInfoList",column = "user_id", many = @Many(select = "com.pjb.mapper.UserMapper.getRoleList", fetchType = FetchType.LAZY))
})
public UserInfo getUserAndRolesInfo(@Param("userId")int userId);
```

具体属性与@One一样，结合Result使用。

## @Result

返回结果集属性映射。

```java
public @interface Result {
  /**
   * 是否是id字段
   *
   * @return {@code true} if id column; {@code false} if otherwise
   */
  boolean id() default false;

  /**
   * 数据库字段名
   *
   * @return the column name(or column label)
   */
  String column() default "";

  /**
   * 实体类属性名
   *
   * @return the property name
   */
  String property() default "";

  /**
   * 实体类java类型
   *
   * @return the java type
   */
  Class<?> javaType() default void.class;

  /**
   * 数据库类型
   *
   * @return the jdbc type
   */
  JdbcType jdbcType() default JdbcType.UNDEFINED;

  /**
   * 使用那种类型控制器
   *
   * @return the {@link TypeHandler} type
   */
  Class<? extends TypeHandler> typeHandler() default UnknownTypeHandler.class;

  /**
   * 子查询一对一
   *
   * @return the mapping definition for single relationship
   */
  One one() default @One;

  /**
   * 子查询一对多
   *
   * @return the mapping definition for collection relationship
   */
  Many many() default @Many;
}
```

## @Results

对属性的映射定义进行分组的注释，内部可以包含多个Result。

## @ResultMap

结合注释sql一起使用，指定返回结果集属性映射的map的id。

## @Select

用于填写sql的注释，@Select注解的目的是为了取代xml中的select标签，只作用于方法上面。普通的字符串值，只能实现变量的替换功能，如下所示：

```java
@Select("SELECT id, type, other, date FROM test where id = #{id}")
Test selectById(Long id);
```

实现复杂的逻辑判断，则需要使用`<script></script>`标签，如下所示：

```java
@Select("<script> SELECT id, type, other, date FROM test where id = #{id}<when test='address !=null'> and address = #{address} </when> </script>")
Test selectById(Long id);
```

<script></script> 标签并非是@Select注解专用的，其他的注解，例如@Insert，@Update等等，都可以使用的。

@Update、@Delete、@Insert类似。

# Mybatis初始化

在Mybatis初始化过程中，大致会有以下几个步骤：

1. 创建Configuration全局配置文件，会往typeAliasesPackage别名注册中心添加Mybatis需要用到的类，并设置默认的语言驱动为XMLLanguageDriver；
2. 加载Mybatis-config配置文件，Mapper接口中的注解信息和XML映射文件，解析后的配置信息会设置进Configuration里；
3. 构建DefaultSqlSessionFactory对象，通过这个对象可以创建DefaultSqlSession对象。DefaultSqlSession是Mybatis中SqlSession默认实现类。

## 初始化Configuration配置

结合spring的mybatis配置文件选项汇总：

```java
/**
 * MyBatis的配置项总汇
 *
 * @author Eddú Meléndez
 * @author Kazuki Shimizu
 */
// 前缀
@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)
public class MybatisProperties {

  public static final String MYBATIS_PREFIX = "mybatis";

  private static final ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();

  /**
   * 本地MyBatis的xml配置文件位置
   */
  private String configLocation;

  /**
   * MyBatis的mapper的mapper文件位置
   */
  private String[] mapperLocations;

  /**
   * 用于搜索类型别名的包。（包分隔符为“，；\t\t”）
   */
  private String typeAliasesPackage;

  /**
   * 用于筛选类型别名的超级类。如果未指定，MyBatis会将从typeAliasesPackage中搜索的所有类作为类型别名处
   * 理。
   */
  private Class<?> typeAliasesSuperType;

  /**
   * 要搜索类型处理程序的包。（包分隔符为“，；\t\t”）
   */
  private String typeHandlersPackage;

  /**
   * 指示是否执行MyBatis xml配置文件的状态检查。
   */
  private boolean checkConfigLocation = false;

  /**
   * sql执行模式（SIMPLE, REUSE, BATCH）。
   */
  private ExecutorType executorType;

  /**
   * 默认脚本语言驱动程序类。（与mybatis spring 2.0.2+一起使用时可用）
   */
  private Class<? extends LanguageDriver> defaultScriptingLanguageDriver;

  /**
   * MyBatis外部配置properties文件
   */
  private Properties configurationProperties;

  /**
   * 用于自定义默认设置的配置对象。如果指定了configLocation，则此属性为未使用。
   */
  private CoreConfiguration configuration;

 /**
   * Mybatis总配置信息类
   *
   * @since 3.0.0
   */
  public static class CoreConfiguration {

    /**
     * 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。
     */
    private Boolean safeRowBoundsEnabled;

    /**
     * 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。
     */
    private Boolean safeResultHandlerEnabled;

    /**
     * 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。
     */
    private Boolean mapUnderscoreToCamelCase;

    /**
      * 当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载（参考 lazyLoadTriggerMethods)。
      * 默认为false （在 3.4.1 及之前的版本默认值为 true）
     */
    private Boolean aggressiveLazyLoading;

    /**
     * 是否允许单一语句返回多结果集（需要驱动支持）。默认为true。
     */
    private Boolean multipleResultSetsEnabled;

    /**
     * 允许 JDBC 支持自动生成主键。
     */
    private Boolean useGeneratedKeys;

    /**
     * 使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。
     *<p>
     *isUseColumnLabel，默认为true。根据Javadoc，这个ColumnLabel就是AS后的那个名字，如果没有AS的话，就是获取的原生的字段名
     * </p>
     * 默认为true。
     */
    private Boolean useColumnLabel;

    /**
     * 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。默认开启
     */
    private Boolean cacheEnabled;

    /**
     * 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，
   	 * 这在依赖于 Map.keySet() 或 null 值初始化的时候比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。
     */
    private Boolean callSettersOnNulls;

    /**
     * 允许使用构造函数的参数名作为语句参数名称。
     * 为了使用该特性，你的项目必须采用 Java 8 编译。
     */
    private Boolean useActualParamName;

    /**
     * 当返回行的所有列都是空时，MyBatis默认返回 null。
     * 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 （如集合或关联）。（新增于 3.4.2）
     */
    private Boolean returnInstanceForEmptyRow;

    /**
     * 从SQL中删除多余的空白字符。注意，这也会影响SQL中的文本字符串。
     * 
     */
    private Boolean shrinkWhitespacesInSql;

    /**
     * 指定“foreach”标记上“nullable”属性的默认值。默认值为false。
     */
    private Boolean nullableOnForEach;

    /**
     * 应用构造函数自动映射时，参数名称用于搜索要映射的列，而不是依赖于*列顺序。默认值为false。
     */
    private Boolean argNameBasedConstructorAutoMapping;

    /**
     * 全局启用或禁用延迟加载。启用后，所有关系都将延迟加载。通过使用fetchType属性，可以为特定关系替换此	 * 值。默认值为False。
     */
    private Boolean lazyLoadingEnabled;

    /**
     * 设置驱动程序等待数据库响应的秒数。
     */
    private Integer defaultStatementTimeout;

    /**
     * 为驱动程序设置一个提示，以控制返回结果的获取大小。查询设置可以覆盖此参数值。
     */
    private Integer defaultFetchSize;

    /**
     * MyBatis使用本地缓存来防止循环引用并加快重复的嵌套查询。
     * 默认情况下（SESSION），缓存会话期间执行的所有查询。
     * 如果localCacheScope=STATEMENT本地会话将仅用于语句执行，则不会在对同一SqlSession的两个不同调用
     * 之间共享数据。默认值为SESSION。
     */
    private LocalCacheScope localCacheScope;

    /**
     * 当没有为参数提供特定的JDBC类型时，为空值指定JDBC类型。
     * 一些驱动程序需要指定列JDBC类型，但其他驱动程序使用NULL、VARCHAR或OTHER等泛型值。
     * 默认值为OTHER。
     */
    private JdbcType jdbcTypeForNull;

    /**
     * 指定在忽略每语句设置时的滚动策略。
     */
    private ResultSetType defaultResultSetType;

    /**
     * 配置默认执行器。SIMPLE执行器没有做任何特殊的事情。REUSE执行器重用准备好的语句。
	 * BATCH执行器重用语句和批处理更新。默认值为SIMPLE。
     */
    private ExecutorType defaultExecutorType;

    /**
     * 指定MyBatis是否以及如何自动将列映射到字段。
     * NONE禁用自动映射。PARTIAL将仅自动映射内部未定义嵌套结果映射的结果。
     * FULL将自动映射任何复杂度的结果映射（包含嵌套或其他）。默认值为PARTIAL。
     */
    private AutoMappingBehavior autoMappingBehavior;

    /**
     * 指定检测到自动映射目标的未知列（或未知属性类型）时的行为。
     * 默认值为NONE。
     */
    private AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior;

    /**
     * 指定MyBatis将添加到记录器名称的前缀字符串。
     */
    private String logPrefix;

    /**
     * 指定哪个Object的方法触发延迟加载。默认值为[equals，clone，hashCode，toString]。
     */
    private Set<String> lazyLoadTriggerMethods;

    /**
     * 指定MyBatis应使用的日志记录实现。如果不存在此设置，则记录实现将自动发现。
     * 
     */
    private Class<? extends Log> logImpl;

    /**
     * 指定VFS实现。
     */
    private Class<? extends VFS> vfsImpl;

    /**
     * 指定保存提供程序方法的sql提供程序类。当省略这些属性时，此类应用于sql提供程序注释（例如@SelectProvider）上的类型（或值）属性。
     */
    private Class<?> defaultSqlProviderType;

    /**
     * 指定默认情况下用于枚举的TypeHandler。
     */
    Class<? extends TypeHandler> defaultEnumTypeHandler;

    /**
     * 指定提供Configuration实例的类。返回的Configuration实例用于加载反序列化对象的惰性properties。
     * 此类必须具有具有签名静态配置的方法*getConfiguration（）。
     */
    private Class<?> configurationFactory;

    /**
     * 指定任何配置变量。
     */
    private Properties variables;

   /**
     * 指定任何配置变量（3.0.0后添加新方法）。
     */
 void applyTo(Configuration target) {
      PropertyMapper mapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
      mapper.from(getSafeRowBoundsEnabled()).to(target::setSafeRowBoundsEnabled);
      mapper.from(getSafeResultHandlerEnabled()).to(target::setSafeResultHandlerEnabled);
      mapper.from(getMapUnderscoreToCamelCase()).to(target::setMapUnderscoreToCamelCase);
      mapper.from(getAggressiveLazyLoading()).to(target::setAggressiveLazyLoading);
      mapper.from(getMultipleResultSetsEnabled()).to(target::setMultipleResultSetsEnabled);
      mapper.from(getUseGeneratedKeys()).to(target::setUseGeneratedKeys);
      mapper.from(getUseColumnLabel()).to(target::setUseColumnLabel);
      mapper.from(getCacheEnabled()).to(target::setCacheEnabled);
      mapper.from(getCallSettersOnNulls()).to(target::setCallSettersOnNulls);
      mapper.from(getUseActualParamName()).to(target::setUseActualParamName);
      mapper.from(getReturnInstanceForEmptyRow()).to(target::setReturnInstanceForEmptyRow);
      mapper.from(getShrinkWhitespacesInSql()).to(target::setShrinkWhitespacesInSql);
      mapper.from(getNullableOnForEach()).to(target::setNullableOnForEach);
      mapper.from(getArgNameBasedConstructorAutoMapping()).to(target::setArgNameBasedConstructorAutoMapping);
      mapper.from(getLazyLoadingEnabled()).to(target::setLazyLoadingEnabled);
      mapper.from(getLogPrefix()).to(target::setLogPrefix);
      mapper.from(getLazyLoadTriggerMethods()).to(target::setLazyLoadTriggerMethods);
      mapper.from(getDefaultStatementTimeout()).to(target::setDefaultStatementTimeout);
      mapper.from(getDefaultFetchSize()).to(target::setDefaultFetchSize);
      mapper.from(getLocalCacheScope()).to(target::setLocalCacheScope);
      mapper.from(getJdbcTypeForNull()).to(target::setJdbcTypeForNull);
      mapper.from(getDefaultResultSetType()).to(target::setDefaultResultSetType);
      mapper.from(getDefaultExecutorType()).to(target::setDefaultExecutorType);
      mapper.from(getAutoMappingBehavior()).to(target::setAutoMappingBehavior);
      mapper.from(getAutoMappingUnknownColumnBehavior()).to(target::setAutoMappingUnknownColumnBehavior);
      mapper.from(getVariables()).to(target::setVariables);
      mapper.from(getLogImpl()).to(target::setLogImpl);
      mapper.from(getVfsImpl()).to(target::setVfsImpl);
      mapper.from(getDefaultSqlProviderType()).to(target::setDefaultSqlProviderType);
      mapper.from(getConfigurationFactory()).to(target::setConfigurationFactory);
      mapper.from(getDefaultEnumTypeHandler()).to(target::setDefaultEnumTypeHandler);
    }
  }
}
```

> Currently, we use the `org.apache.ibatis.session.Configuration` as the nested configuration properties in `MybatisPropertes`. But this coding style has not been recommended as Spring Boot development teams. Therefore we rewrite a recommended coding style.
>
> 目前，我们使用org.apache.ibatis.session.Configuration作为MybatisPropertes中的嵌套配置财产。但是这种编码风格并没有被推荐给Spring Boot开发团队。因此，我们重写了推荐的编码样式。

结合spring-boot进行装配初始化。spring boot的自动装配原理是在自动装配包的META-INF下创建spring.factories文件，在文件里面配置EnableAutoConfiguration的配置类全名即可实现自动装配，以下是mybatis-spring-boot-autoconfigure包的spring.factories文件：

```properties
# Auto Configure (3.0.0之后已弃用)
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration

# Depends On Database Initialization Detectors (2.3.0之后使用)
org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitializationDetector=\
org.mybatis.spring.boot.autoconfigure.MybatisDependsOnDatabaseInitializationDetector
```

更改初始化配置的原因为[^p1]：

> Using `spring.factories` to find auto-configuration classes is causing problems with our native work. We initially used it because the code was already available, but we want to offer an alternative in 2.7 and stop using spring.factories for auto-configuration in 3.0.
>
> 使用spring.factories查找自动配置类会导致本机工作出现问题。我们最初使用它是因为代码已经可用，但我们希望在2.7中提供一个替代方案，并在3.0中停止使用spring.factories进行自动配置。

### MybatisLanguageDriverAutoConfiguration

自动加载额外的LanguageDriver配置:

- FreeMarkerLanguageDriver
- VelocityLanguageDriver

#### LanguageDriver

LanguageDriver主要用于构造SqlSource和ParameterHandler，从LanguageDriver在Mybatis中调用链路来看，Configuration#newParameterHandler通过调用LanguageDriver#createParameterHandler完成构建ParameterHandler，通过调用LanguageDriver#createSqlSource来完成构建SqlSource。

```java
/**
 * 语言驱动
 */
public interface LanguageDriver {

  /**
   * Creates a {@link ParameterHandler} that passes the actual parameters to the the JDBC statement.
   * 创建 {@link ParameterHandler} 通过JDBC的实际参数
   * @param mappedStatement The mapped statement that is being executed 映射的正在执行语句
   * @param parameterObject The input parameter object (can be null) 输入的参数对象（可以为空）
   * @param boundSql The resulting SQL once the dynamic language has been executed. 生成的SQL，一旦动态语言被执行
   * @return
   * @author Frank D. Martinez [mnesarco]
   * @see DefaultParameterHandler
   */
  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);

  /**
   * Creates an {@link SqlSource} that will hold the statement read from a mapper xml file.
   * It is called during startup, when the mapped statement is read from a class or an xml file.
   * 创建一个{@link SqlSource} 读取映射XML文件
   * @param configuration The MyBatis configuration MyBatis配置
   * @param script XNode parsed from a XML file
   * @param parameterType input parameter type got from a mapper method or specified in the parameterType xml attribute. Can be null.
   *                      输入参数类型从一个xml类型映射器参数中指定的方法或属性。可以为空。;
   * @return
   */
  SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType);

  /**
   * Creates an {@link SqlSource} that will hold the statement read from an annotation.
   * It is called during startup, when the mapped statement is read from a class or an xml file.
   * 创建一个{@link SqlSource} 从一个字解里，它在启动期间,当映射语句从一个类或读取一个xml文件被调用。;
   * @param configuration The MyBatis configuration
   * @param script The content of the annotation
   * @param parameterType input parameter type got from a mapper method or specified in the parameterType xml attribute. Can be null.
   *                      输入参数类型从一个xml类型映射器参数中指定的方法或属性。可以为空。;
   * @return
   */
  SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType);

}
```

#### XMLLanguageDriver

```java
/**
 * XML语言驱动
 * <p>
 *     Mybatis默认XML驱动类为XMLLanguageDriver，其主要作用于解析select|update|insert|delete节点为完整的SQL语句。
 * </p>
 * @author Eduardo Macarron
 */
public class XMLLanguageDriver implements LanguageDriver {
    @Override
  public ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
    return new DefaultParameterHandler(mappedStatement, parameterObject, boundSql);
  }

  @Override
  public SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType) {
    XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);
    /***
     *  当sql中包含有${}时，就认为是动态SQL
     *       或者 当DML标签存在动态SQL标签名，如&lt;if&gt;,&lt;trim&gt;等，就认为是动态SQL
     *  ，如果是动态返回 {@link DynamicSqlSource} ，否则 {@link RawSqlSource}
     */
    return builder.parseScriptNode();
  }
  @Override
  public SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType) {
    // issue #3 此处兼容XML方式的解析，条件以<script>为头结点
    if (script.startsWith("<script>")) {
      XPathParser parser = new XPathParser(script, false, configuration.getVariables(), new XMLMapperEntityResolver());
      return createSqlSource(configuration, parser.evalNode("/script"), parameterType);
    } else {
      // issue #127
      /**
       * 解析Configuration#variable变量,将有${...}形式的字符串转换成对应字符串,
       *    eg:  '${first_name},${initial},${last_name}' => 'James,T,Kirk'
       */
      script = PropertyParser.parse(script, configuration.getVariables());
      TextSqlNode textSqlNode = new TextSqlNode(script);
      //根据TextSqlNode的内部属性isDynamic来进行解析帮助类的分配
      if (textSqlNode.isDynamic()) {
        return new DynamicSqlSource(configuration, textSqlNode);
      } else {
        return new RawSqlSource(configuration, script, parameterType);
      }
    }
  }
```

#### XMLScriptBuilder

```java
/**
 * XML脚本构建器
 * @author Clinton Begin
 */
public class XMLScriptBuilder extends BaseBuilder {

  /**
   * DML标签
   */
  private final XNode context;

  /**
   * 是否是动态SQL脚本.
   * <ol style='margin-top:0px'>
   *     <li>当sql中包含有${}时，就认为是动态SQL</li>
   *     <li>当DML标签存在动态SQL标签名，如&lt;if&gt;,&lt;trim&gt;等，就认为是动态SQL</li>
   * </ol>
   */
  private boolean isDynamic;

  /**
   * DML标签的参数类型
   */
  private final Class<?> parameterType;
   /**
   *
   * @param configuration mybatis全局配置
   * @param context DML标签
   */
  public XMLScriptBuilder(Configuration configuration, XNode context) {
    this(configuration, context, null);
  }

  /**
   *
   * @param configuration mybatis全局配置
   * @param context DML标签
   * @param parameterType 参数类型
   */
  public XMLScriptBuilder(Configuration configuration, XNode context, Class<?> parameterType) {
    super(configuration);
    this.context = context;
    this.parameterType = parameterType;
    initNodeHandlerMap();
  }
  
  /**
   * 将所有的动态SQL标签处理器添加到 {@link #nodeHandlerMap}
   */
  private void initNodeHandlerMap() {
    nodeHandlerMap.put("trim", new TrimHandler());
    nodeHandlerMap.put("where", new WhereHandler());
    nodeHandlerMap.put("set", new SetHandler());
    nodeHandlerMap.put("foreach", new ForEachHandler());
    nodeHandlerMap.put("if", new IfHandler());
    nodeHandlerMap.put("choose", new ChooseHandler());
    nodeHandlerMap.put("when", new IfHandler());
    nodeHandlerMap.put("otherwise", new OtherwiseHandler());
    nodeHandlerMap.put("bind", new BindHandler());
  }
    /**
   * 解析脚本标签节点
   * @return
   *  当sql中包含有${}时，就认为是动态SQL
   *      或者 当DML标签存在动态SQL标签名，如&lt;if&gt;,&lt;trim&gt;等，就认为是动态SQL
   * ，如果是动态返回 {@link DynamicSqlSource} ，否则 {@link RawSqlSource}
   */
  public SqlSource parseScriptNode() {
    //解析DML标签下的子节点，封装成MixedSqlNode
    MixedSqlNode rootSqlNode = parseDynamicTags(context);
    SqlSource sqlSource;
    if (isDynamic) {
      //只创建DynamicSqlSource对象。完整可执行的sql，需要在调用getBoundSql(Parameter)方法时才能组装完成。
      sqlSource = new DynamicSqlSource(configuration, rootSqlNode);
    } else {
      /**
       * 调用 SqlSourceBuilder类将"#{xxx}“ 替换为占位符”?"，并绑定ParameterMapping，
       * 最后返回的RawSqlSource中持有一个由SqlSourceBuilder构建的SqlSource对象。
       */
      sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);
    }
    return sqlSource;
  }
 /**
   * 解析动态SQL标签，对 {@code node} 的子节点和文本节点进行解析，
   *  这里会检测是否属于动态就会对isDynamic设置对应的值
   * @param node DML标签或者是动态SQL标签
   * @return 混合着 {@code node} 的子节点的MixedSqlNode实例
   */
  protected MixedSqlNode parseDynamicTags(XNode node) {
    List<SqlNode> contents = new ArrayList<>();
    NodeList children = node.getNode().getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
      /**
       * XNode.newXNode(Node node)：新建一个XNode,XNode只是mybatis对Node实例的封装，用于方便操作。
       * 并不是添加node节点的功能
       */
      XNode child = node.newXNode(children.item(i));
      /**
       * Node.CDATA_SECTION_NODE:代表文档中的 CDATA 部（不会由解析器解析的文本）
       * Node.TEXT_NODE:代表元素或属性中的文本内容
       */
      if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) {
        //获取文本节点的文本内容
        String data = child.getStringBody("");
        //文本SQL节点。用传入的实际参数对象中的属性值对${}进行直接替换，并且不会进行任何检查！
        TextSqlNode textSqlNode = new TextSqlNode(data);
        //当sql中包含有${}时，就认为是动态SQL.下面就是根据是否是动态SQL来添加对应SqlNode类型
        if (textSqlNode.isDynamic()) {
          contents.add(textSqlNode);
          isDynamic = true;
        } else {
          //StaticTextSqlNode:静态文本SQL节点，其apply方法使得只是将存储的文本内容直接添加到DynamicContext对象中
          contents.add(new StaticTextSqlNode(data));
        }
      } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // issue #628 Node.ELEMENT_NODE:代表元素
        String nodeName = child.getNode().getNodeName();
        //根据标签名找到对应的NodeHandler
        NodeHandler handler = nodeHandlerMap.get(nodeName);
        if (handler == null) {
          throw new BuilderException("Unknown element <" + nodeName + "> in SQL statement.");
        }
        handler.handleNode(child, contents);
        isDynamic = true;
      }
    }
    return new MixedSqlNode(contents);
  }
    
  /**
   * 标签节点处理器,解析标签节点，封装到对应sqlNode中
   */
  private interface NodeHandler {
    /**
     * 解析标签节点，封装到对应sqlNode中，并将sqlNode添加到 {@code targetContents}
     * @param nodeToHandle 动态SQL标签名,如&lt;if&gt;,&lt;trim&gt;等
     * @param targetContents 解析完 {@code nodeToHandle}SqlNode后，
     */
    void handleNode(XNode nodeToHandle, List<SqlNode> targetContents);
  }

  /**
   * &lt;bind&gt;处理器:元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文
   * <p>如：</p>
   * <p>
   *     &lt;bind name="pattern" value="'%' + _parameter.getTitle() + '%'" /&gt;
   * </p>
   */
  private class BindHandler implements NodeHandler {
    public BindHandler() {
      // Prevent Synthetic Access
    }
      
    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      //获取bind标签的name属性值
      final String name = nodeToHandle.getStringAttribute("name");
      //获取bind标签的value属性值
      final String expression = nodeToHandle.getStringAttribute("value");
      //OGNL解析
      final VarDeclSqlNode node = new VarDeclSqlNode(name, expression);
      targetContents.add(node);
    }
  }
  /**
   * trim标签处理器
   */
  private class TrimHandler implements NodeHandler {
    public TrimHandler() {
      // Prevent Synthetic Access
    }
      
    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      //解析trim标签下的字节点，封装成MixedSqlNode
      MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);
      //获取trim标签的prefix属性，给sql语句拼接的前缀
      String prefix = nodeToHandle.getStringAttribute("prefix");
      /**
       * 获取trim标签的prefixOverrides属性
       * 去除sql语句前面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定，
       * 假设该属性指定为"AND"，当sql语句的开头为"AND"，trim标签将会去除该"AND"
       */
      String prefixOverrides = nodeToHandle.getStringAttribute("prefixOverrides");
      //获取trim标签的suffix属性，给sql语句拼接的后缀
      String suffix = nodeToHandle.getStringAttribute("suffix");
      //获取trim标签的suffixOverride,去除sql语句后面的关键字或者字符，该关键字或者字符由suffixOverrides属性指定
      String suffixOverrides = nodeToHandle.getStringAttribute("suffixOverrides");
      //Trim标签的功能逻辑交给TrimSqlNode
      TrimSqlNode trim = new TrimSqlNode(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides);
      targetContents.add(trim);
    }
  }
 
  /**
   * where标签处理器
   */
  private class WhereHandler implements NodeHandler {
    public WhereHandler() {
      // Prevent Synthetic Access
    }

    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      //解析where标签下的字节点，封装成MixedSqlNode
      MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);
      //where标签的功能逻辑交给whereSqlNode处理
      WhereSqlNode where = new WhereSqlNode(configuration, mixedSqlNode);
      targetContents.add(where);
    }
  }

  /**
   * Set标签处理器
   */
  private class SetHandler implements NodeHandler {
    public SetHandler() {
      // Prevent Synthetic Access
    }

    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      //解析set标签下的子节点，封装成MixedSqlNode
      MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);
      //set标签的功能逻辑交给whereSqlNode处理
      SetSqlNode set = new SetSqlNode(configuration, mixedSqlNode);
      targetContents.add(set);
    }
  }

  /**
   * forEach标签接收处理器
   */
  private class ForEachHandler implements NodeHandler {
    public ForEachHandler() {
      // Prevent Synthetic Access
    }

    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      ///解析forEach标签下的子节点，封装成MixedSqlNode
      MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);
      //获取foreach标签的collection属性，循环的集合对象名
      String collection = nodeToHandle.getStringAttribute("collection");
      //获取foreach标签的item属性，集合对象的元素名
      String item = nodeToHandle.getStringAttribute("item");
      //获取foreach标签的index属性，在list和数组中,index是元素的序号，在map中，index是元素的key，该参数可选。
      String index = nodeToHandle.getStringAttribute("index");
      //获取foreach标签的open属性，foreach代码的开始符号，一般是(和close=")"合用。常用在in(),values()时。该参数可选。
      String open = nodeToHandle.getStringAttribute("open");
      //获取foreach标签的close属性,foreach代码的关闭符号，一般是)和open="("合用。常用在in(),values()时。该参数可选。
      String close = nodeToHandle.getStringAttribute("close");
      /**
       * 获取foreach标签的separator属性,元素之间的分隔符，例如在in()的时候，
       * separator=","会自动在元素中间用“,“隔开，避免手动输入逗号导致sql错误，如in(1,2,)这样。该参数可选
       */
      String separator = nodeToHandle.getStringAttribute("separator");
      ForEachSqlNode forEachSqlNode = new ForEachSqlNode(configuration, mixedSqlNode, collection, index, item, open, close, separator);
      targetContents.add(forEachSqlNode);
    }
  }

  /**
   * if标签接收处理器
   */
  private class IfHandler implements NodeHandler {
    public IfHandler() {
      // Prevent Synthetic Access
    }

    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      //解析if标签下的子节点，封装成MixedSqlNode
      MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);
      //获取if标签的test属性，ognl表达式
      String test = nodeToHandle.getStringAttribute("test");
      IfSqlNode ifSqlNode = new IfSqlNode(mixedSqlNode, test);
      targetContents.add(ifSqlNode);
    }
  }

  /**
   * otherwise标签，当 when 元素中的条件都不生效，就可以使用 otherwise 元素的默认文本。
   */
  private class OtherwiseHandler implements NodeHandler {
    public OtherwiseHandler() {
      // Prevent Synthetic Access
    }

    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      //解析otherwise标签下的子节点，封装成MixedSqlNode
      MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);
      /**
       * 因为otherwise标签的应用情况是由choose标签控制，而且应用otherwise标签不过是
       * 应用otherwise标签的所有子节点对应sqlNode，所有otherwise不需要对应的sqlNode
       */
      targetContents.add(mixedSqlNode);
    }
  }

  /**
   * choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。
   * 当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。
   * 类似于Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。
   */
  private class ChooseHandler implements NodeHandler {
    public ChooseHandler() {
      // Prevent Synthetic Access
    }

    @Override
    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {
      List<SqlNode> whenSqlNodes = new ArrayList<>();
      List<SqlNode> otherwiseSqlNodes = new ArrayList<>();
      //接收处理when标签和otherwise标签
      handleWhenOtherwiseNodes(nodeToHandle, whenSqlNodes, otherwiseSqlNodes);
      //获取otherwise标签
      SqlNode defaultSqlNode = getDefaultSqlNode(otherwiseSqlNodes);
      ChooseSqlNode chooseSqlNode = new ChooseSqlNode(whenSqlNodes, defaultSqlNode);
      targetContents.add(chooseSqlNode);
    }

    /**
     * 接收处理when标签和otherwise标签
     * @param chooseSqlNode choose标签
     * @param ifSqlNodes when标签集合
     * @param defaultSqlNodes otherwise标签集合
     */
    private void handleWhenOtherwiseNodes(XNode chooseSqlNode, List<SqlNode> ifSqlNodes, List<SqlNode> defaultSqlNodes) {
      List<XNode> children = chooseSqlNode.getChildren();
      for (XNode child : children) {
        String nodeName = child.getNode().getNodeName();
        NodeHandler handler = nodeHandlerMap.get(nodeName);
        if (handler instanceof IfHandler) {//when标签的处理器是IfHandler
          //handleNode方法会将child添加到ifSqlNodes集合中
          handler.handleNode(child, ifSqlNodes);
        } else if (handler instanceof OtherwiseHandler) {//Otherwise标签
          //handleNode方法会将child添加到defaultSqlNodes集合中
          handler.handleNode(child, defaultSqlNodes);
        }
      }
    }

    /**
     * 获取otherwise标签
     * @param defaultSqlNodes otherwise标签集合
     * @return 返回集合的第一个元素， {@code defaultSqlNodes} 只能存在一个元素或者没有元素，
     *      超过一个都会抛出BuilderException
     */
    private SqlNode getDefaultSqlNode(List<SqlNode> defaultSqlNodes) {
      SqlNode defaultSqlNode = null;
      if (defaultSqlNodes.size() == 1) {
        defaultSqlNode = defaultSqlNodes.get(0);
      } else if (defaultSqlNodes.size() > 1) {
        throw new BuilderException("Too many default (otherwise) elements in choose statement.");
      }
      return defaultSqlNode;
    }
  }

}
```

#### RawLanguageDriver

```java
/**
 * 这是一个简单的语言驱动，只能针对静态SQL的处里，如果出现动态SQL标签会抛出异常
 * As of 3.2.4 the default XML language is able to identify static statements
 * and create a {@link RawSqlSource}. So there is no need to use RAW unless you
 * want to make sure that there is not any dynamic tag for any reason.
 * 默认XML语言是能够识别静态语句并创建一个{@link RawSqlSource}，所以没有需要使用原始的,除非你想确保没有任何动态标记任何理由。
 * @since 3.2.0
 * @author Eduardo Macarron
 */
public class RawLanguageDriver extends XMLLanguageDriver {

  @Override
  public SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType) {
    SqlSource source = super.createSqlSource(configuration, script, parameterType);
    checkIsNotDynamic(source);
    return source;
  }
    
  @Override
  public SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType) {
    SqlSource source = super.createSqlSource(configuration, script, parameterType);
    checkIsNotDynamic(source);
    return source;
  }

  private void checkIsNotDynamic(SqlSource source) {
    if (!RawSqlSource.class.equals(source.getClass())) {
      throw new BuilderException("Dynamic content is not allowed when using RAW language");
    }
  }

}
```

### MybatisAutoConfiguration

1. 首先是该Enable起作用是当前环境下存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类，还记得之前分析mybatis和spring整合的，就是通过SqlSessionFactoryBean,这就表示需要引入mybatis-spring依赖，而SqlSessionFactory则是mybatis本身的依赖，即pom需要引入mybatis和mybatis-spring这两个依赖MybatisAutoConfiguration才会起作用。

~~~java
/**
  * Mybatis的自动配置提供了SqlSessionFactory和SqlSessionTemplate。
  * 如果MapperScan被使用，或者配置文件是被指定
  * 指定为属性时，将考虑这些属性，否则此自动配置将尝试注册映射器
  * 基于根自动配置包中或下的接口定义。
  */
@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })
@ConditionalOnSingleCandidate(DataSource.class)
@EnableConfigurationProperties(MybatisProperties.class)
@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })
public class MybatisAutoConfiguration implements InitializingBean {

  private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);

  private final MybatisProperties properties;

  private final Interceptor[] interceptors;

  private final TypeHandler[] typeHandlers;

  private final LanguageDriver[] languageDrivers;

  private final ResourceLoader resourceLoader;

  private final DatabaseIdProvider databaseIdProvider;

  private final List<ConfigurationCustomizer> configurationCustomizers;

  private final List<SqlSessionFactoryBeanCustomizer> sqlSessionFactoryBeanCustomizers;
  
  ``````
~~~

自动配置所拥有的属性变量：

- MybatisProperties：Mybaits以及包括和spring相关的配置；
- interceptors：Mybatis拦截器；
- TypeHandler：Mybatis类型处理器；
- LanguageDriver：语言驱动解析接口；
- ResourceLoader：资源加载类；
- DatabaseIdProvider：数据厂商标识；
- configurationCustomizers：用户自定义配置列表；
- SqlSessionFactoryBeanCustomizer：自定义SqlSessionFactory；

~~~java
  ``````
  @Override
  public void afterPropertiesSet() {
      checkConfigFileExists();
  }
  // 检查是否有且存在本地配置文件
  private void checkConfigFileExists() {
      if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
          Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());
          Assert.state(resource.exists(),
                         "Cannot find config location: " + resource + " (please add config file or check your Mybatis configuration)");
      }
  }
  ``````
~~~

2. 获取SqlSessionFactory，如果当前IOC容器没有SqlSessionFactory类型的bean，则这里会创建一个。通过SqlSessionFactoryBean创建SqlSessionFactory：

~~~java
``````
@Bean
@ConditionalOnMissingBean
public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
  SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
  factory.setDataSource(dataSource);
  // 添加vfs配置
  if (properties.getConfiguration() == null || properties.getConfiguration().getVfsImpl() == null) {
    factory.setVfs(SpringBootVFS.class);
  }
  // 查找是否存在本地配置
  if (StringUtils.hasText(this.properties.getConfigLocation())) { factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
  }
  applyConfiguration(factory);
  // 装配一些配置信息
  if (this.properties.getConfigurationProperties() != null) {
    factory.setConfigurationProperties(this.properties.getConfigurationProperties());
  }
  if (!ObjectUtils.isEmpty(this.interceptors)) {
    factory.setPlugins(this.interceptors);
  }
  if (this.databaseIdProvider != null) {
    factory.setDatabaseIdProvider(this.databaseIdProvider);
  }
  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
  }
  if (this.properties.getTypeAliasesSuperType() != null) {
    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
  }
  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
  }
  if (!ObjectUtils.isEmpty(this.typeHandlers)) {
    factory.setTypeHandlers(this.typeHandlers);
  }
  Resource[] mapperLocations = this.properties.resolveMapperLocations();
  if (!ObjectUtils.isEmpty(mapperLocations)) {
    factory.setMapperLocations(mapperLocations);
  }
  Set<String> factoryPropertyNames = Stream
      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
      .collect(Collectors.toSet());
  Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
  if (factoryPropertyNames.contains("scriptingLanguageDrivers") && !ObjectUtils.isEmpty(this.languageDrivers)) {
    // Need to mybatis-spring 2.0.2+
    factory.setScriptingLanguageDrivers(this.languageDrivers);
    if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
      defaultLanguageDriver = this.languageDrivers[0].getClass();
    }
  }
  if (factoryPropertyNames.contains("defaultScriptingLanguageDriver")) {
    // mybatis-spring版本2.0.2以上
    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
  }
  applySqlSessionFactoryBeanCustomizers(factory);
  // 生成SqlSessionFactory工厂类
  return factory.getObject();
}
// 自带内部配置类和配置类的填充
private void applyConfiguration(SqlSessionFactoryBean factory) {
    MybatisProperties.CoreConfiguration coreConfiguration = this.properties.getConfiguration();
    Configuration configuration = null;
    if (coreConfiguration != null || !StringUtils.hasText(this.properties.getConfigLocation())) {
        configuration = new Configuration();
    }
    if (configuration != null && coreConfiguration != null) {
        coreConfiguration.applyTo(configuration);
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
        for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
            customizer.customize(configuration);
        }
    }
    factory.setConfiguration(configuration);
}
// 自定义SqlSessionFactory的bean添加
private void applySqlSessionFactoryBeanCustomizers(SqlSessionFactoryBean factory) {
    if (!CollectionUtils.isEmpty(this.sqlSessionFactoryBeanCustomizers)) {
        for (SqlSessionFactoryBeanCustomizer customizer : this.sqlSessionFactoryBeanCustomizers) {
            customizer.customize(factory);
    }
}
``````
~~~

3. 创建SqlSessionTemplate，如果当前IOC容器没有SqlSessionTemplate类型bean，则这里会创建一个：


```java
@Bean
@ConditionalOnMissingBean
public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
  ExecutorType executorType = this.properties.getExecutorType();
  if (executorType != null) {
    return new SqlSessionTemplate(sqlSessionFactory, executorType);
  } else {
    return new SqlSessionTemplate(sqlSessionFactory);
  }
}
```

4. 如果当前IOC容器没有MapperFactoryBean.class, MapperScannerConfigurer.class这两个bean，则会通过：

```java
  /**
   * 这将只扫描与Spring Boot相同的基本包。 {@link org.mybatis.spring.annotation.MapperScan}但这将使键入的映射器能够正常工作，
   * 开箱即用，类似于使用Spring Data JPA存储库。
   */
  public static class AutoConfiguredMapperScannerRegistrar
      implements BeanFactoryAware, EnvironmentAware, ImportBeanDefinitionRegistrar {

```

通过`AutoConfiguredMapperScannerRegistrar`导入，其通过实现`registerBeanDefinitions`方法，将`MapperScannerConfigurer`这个类注入到了IOC容器中。

#### SqlSessionFactoryBean

```java
/**
 * {@inheritDoc}
 */
@Override
public SqlSessionFactory getObject() throws Exception {
  if (this.sqlSessionFactory == null) {
    afterPropertiesSet();
  }

  return this.sqlSessionFactory;
}

@Override
public void afterPropertiesSet() throws Exception {
    notNull(dataSource, "Property 'dataSource' is required");
    notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required");
    state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),
          "Property 'configuration' and 'configLocation' can not specified with together");

    this.sqlSessionFactory = buildSqlSessionFactory();
}
```

buildSqlSessionFactory()方法这里的核心目的就是将configurationProperties解析到Configuration对象中。

```java
/**
 * 构建SqlSessionFactory，使用标准的Mybatis XMLConfigBuilder接口构建。
 */
protected SqlSessionFactory buildSqlSessionFactory() throws Exception {
```

![SqlSessionFactoryBean的buildSqlSessionFactory方法](SqlSessionFactoryBean的buildSqlSessionFactory方法.png)

通过buildSqlSessionFactory()解析得到的Configuration对象创建一个DefaultSqlSessionFactory(config)。

#### SqlSessionTemplate

这个自动配置类还创建了SqlSessionTemplate这个类，具体构建源码入下：

```java
public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType) {
    this(sqlSessionFactory, executorType, new MyBatisExceptionTranslator(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), true));
}

public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) {
    Assert.notNull(sqlSessionFactory, "Property 'sqlSessionFactory' is required");
    Assert.notNull(executorType, "Property 'executorType' is required");
    this.sqlSessionFactory = sqlSessionFactory;
    this.executorType = executorType;
    this.exceptionTranslator = exceptionTranslator;
    this.sqlSessionProxy = (SqlSession)Proxy.newProxyInstance(SqlSessionFactory.class.getClassLoader(), new Class[]{SqlSession.class}, new SqlSessionTemplate.SqlSessionInterceptor());
}
```

这里通过动态代理创建了一个SqlSession。

## 解析Mapper接口和xml文件

### XMLMapperBuilder

解析入口为XMLConfigBuilder的mapperElement方法：

```java
private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    for (XNode child : parent.getChildren()) {
      if ("package".equals(child.getName())) {
        String mapperPackage = child.getStringAttribute("name");
        configuration.addMappers(mapperPackage);
      } else {
        String resource = child.getStringAttribute("resource");
        String url = child.getStringAttribute("url");
        String mapperClass = child.getStringAttribute("class");
        if (resource != null && url == null && mapperClass == null) {
          ErrorContext.instance().resource(resource);
          try (InputStream inputStream = Resources.getResourceAsStream(resource)) {
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource,
                configuration.getSqlFragments());
            mapperParser.parse();
          }
        } else if (resource == null && url != null && mapperClass == null) {
          ErrorContext.instance().resource(url);
          try (InputStream inputStream = Resources.getUrlAsStream(url)) {
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url,
                configuration.getSqlFragments());
            mapperParser.parse();
          }
        } else if (resource == null && url == null && mapperClass != null) {
          Class<?> mapperInterface = Resources.classForName(mapperClass);
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(
              "A mapper element may only specify a url, resource or class, but not more than one.");
        }
      }
    }
  }
}
```

调用XMLMapperBuilder中parse：


```java
  /**
   * 解析Mapper.xml，解析mapper标签下的所有标签，并对解析出来的标签信息加以封装，
   * 然后添加到Mybatis全局配置信息中。然后重新解析Mybatis全局配置信息中未能完成解析的
   * ResultMap标签信息，CacheRef标签信息，DML标签信息
   */
  public void parse() {
    //如果没有加载过resource
    if (!configuration.isResourceLoaded(resource)) {
      //解析mapper标签下的所有标签，并对解析出来的标签信息加以封装，然后添加到Mybatis全局配置信息中
      configurationElement(parser.evalNode("/mapper"));
      //将resouce添加到Mybatis全局配置信息中，以防止重新加载对应的resource
      configuration.addLoadedResource(resource);
      //找出对应当前Mapper.xml的java类型,并添加到Mybatis全局配置信息中
      bindMapperForNamespace();
    }
    //重新解析Mybatis全局配置信息中未能完成解析的ResultMap标签信息
    parsePendingResultMaps();
    //重新解析Mybatis全局配置信息中未能完成解析的CacheRef标签信息
    parsePendingCacheRefs();
    //重新解析Mybatis全局配置信息中未能完成解析的DML标签信息
    parsePendingStatements();
  }


  /**
   *  解析mapper标签下的所有标签，并对解析出来的标签信息加以封装，然后添加到Mybatis全局配置信息中
   * @param context mapper标签
   */
  private void configurationElement(XNode context) {
    try {
      //获取命名空间属性
      String namespace = context.getStringAttribute("namespace");
      if (namespace == null || namespace.equals("")) {
        throw new BuilderException("Mapper's namespace cannot be empty");
      }
      builderAssistant.setCurrentNamespace(namespace);
      //解析 cache-ref 标签
      cacheRefElement(context.evalNode("cache-ref"));
      //解析 cache 标签
      cacheElement(context.evalNode("cache"));
      //解析 paramterMap 标签
      parameterMapElement(context.evalNodes("/mapper/parameterMap"));
      //解析 resultMap 表
      resultMapElements(context.evalNodes("/mapper/resultMap"));
      //解析sql标签
      sqlElement(context.evalNodes("/mapper/sql"));
      //构建每个DML标签对应的XMLStatmentBuilder，并通过XMLStatementBuilder对DML标签进行解析
      buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing Mapper XML. The XML location is '" + resource + "'. Cause: " + e, e);
    }
  }

  /**
   * 找出对应当前Mapper.xml的java类型,并添加到Mybatis全局配置信息中
   */
  private void bindMapperForNamespace() {
    //获取当前命名空间
    String namespace = builderAssistant.getCurrentNamespace();
    //如果当前命名空间不为null
    if (namespace != null) {
      Class<?> boundType = null;
      try {
        //获取Mapper.xml需要绑定java类型
        boundType = Resources.classForName(namespace);
      } catch (ClassNotFoundException e) {
        //ignore, bound type is not required 因为绑定的java类型并不是必须的，所有忽略
      }
      //如果绑定类型不为null
      if (boundType != null) {
        //如果Mybatis全局配置信息中没有注册boundType
        if (!configuration.hasMapper(boundType)) {
          // Spring may not know the real resource name so we set a flag
          // to prevent loading again this resource from the mapper interface
          // look at MapperAnnotationBuilder#loadXmlResource
          // 译：
          // Spring框架可能不知道真正的资源名称，所以我们设置一个标签
          // 去防止再次加载这个资源映射接口
          // 查看MapperAnnotationBuilder#loadXmlResource
          //将{@code resource} 添加到mybatis全局配置信息的已加载资源集合里
          configuration.addLoadedResource("namespace:" + namespace);
          //将boundType加入到mybatis全局配置信息的mapperRegistry中
          configuration.addMapper(boundType);
        }
      }
    }
  }

  /**
   * 重新解析Mybatis全局配置信息中未能完成的ResultMap标签信息
   */
  private void parsePendingResultMaps() {
    //获取Mybatis全局配置信息中未能完成的ResultMap标签信息
    Collection<ResultMapResolver> incompleteResultMaps = configuration.getIncompleteResultMaps();
    //同步,防止重新解析
    synchronized (incompleteResultMaps) {
      //获取incompleteResultMaps的迭代器
      Iterator<ResultMapResolver> iter = incompleteResultMaps.iterator();
      //遍历incompleteResultMaps
      while (iter.hasNext()) {
        try {
          //获取ResultMap标签信息解析器重新解析
          iter.next().resolve();
          //如果解析成功，就从集合中移除
          iter.remove();
        } catch (IncompleteElementException e) {
          //抛出异常时，不做任何操作，让未能完成的ResultMap标签信息继续在Mybatis全局配置信息中等待下次解析
          // ResultMap is still missing a resource... ResultMap标签仍然丢失一个资源
        }
      }
    }
  }

  /**
   * 重新解析Mybatis全局配置信息中未能完成解析的CacheRef标签信息
   */
  private void parsePendingCacheRefs() {
    //获取Mybatis全局配置信息中未能完成解析的CacheRef标签信息
    Collection<CacheRefResolver> incompleteCacheRefs = configuration.getIncompleteCacheRefs();
    //同步,防止重新解析
    synchronized (incompleteCacheRefs) {
      //获取incompleteCacheRefs的迭代器
      Iterator<CacheRefResolver> iter = incompleteCacheRefs.iterator();
      //遍历incompleteCacheRefs
      while (iter.hasNext()) {
        try {
          //获取CacheRef标签信息解析器重新解析
          iter.next().resolveCacheRef();
          //如果解析成功，就从集合中移除
          iter.remove();
        } catch (IncompleteElementException e) {
          //抛出异常时，不做任何操作，让未能完成解析的CacheRef标签信息继续在Mybatis全局配置信息中等待下次解析
          // Cache ref is still missing a resource... CacheRef标签仍然丢失一个资源
        }
      }
    }
  }

  /**
   * 重新解析Mybatis全局配置信息中未能完成解析的DML标签信息
   */
  private void parsePendingStatements() {
    //获取Mybatis全局配置信息中未能完成解析的DML标签信息
    Collection<XMLStatementBuilder> incompleteStatements = configuration.getIncompleteStatements();
    //同步,防止重新解析
    synchronized (incompleteStatements) {
      //获取incompleteStatements的迭代器
      Iterator<XMLStatementBuilder> iter = incompleteStatements.iterator();
      //遍历incompleteStatements
      while (iter.hasNext()) {
        try {
          //获取DML标签信息解析器重新解析
          iter.next().parseStatementNode();
          //如果解析成功，就从集合中移除
          iter.remove();
        } catch (IncompleteElementException e) {
          //抛出异常时，不做任何操作，让未能完成解析的DML标签信息继续在Mybatis全局配置信息中等待下次解析
          // Statement is still missing a resource... DML标签仍然丢失一个资源
        }
      }
    }
  }

```
### XMLStatementBuilder

通过statementParser.parseStatementNode方法对Mapper的xml文件进行解析：

```java
  /**
   * 解析DML标签
   * <p>将DML标签中的include标签替换成对应sql标签下的所有子标签</p>
   * <p>将DML标签中的selectKey标签封装成KeyGenerator对象，然后添加到Mybatis全局配置信息信息，然后删除DML标签里的所有selectKey标签</p>
   * <p>将DML标签，封装成MapperStatement对象，然后添加到Mybatis全局配置信息中</p>
   */
  public void parseStatementNode() {
    //获取DML标签的id属性
    String id = context.getStringAttribute("id");
    //获取DML标签的databaseId属性
    String databaseId = context.getStringAttribute("databaseId");
    //如果当前DML标签不对应当前配置的数据库Id
    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {
      //结束方法
      return;
    }
    //获取DML标签名：select|insert|update|delete 标签
    String nodeName = context.getNode().getNodeName();
    //获取对应的DML标签名的SQLCommentType枚举实例
    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));
    //只有不是select语句，isSelect才会为true
    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;
    //获取DML标签的flushCache属性，flushCache表示执行DML语句时是否刷新缓存，默认是只要不是select语句就会刷新缓存
    boolean flushCache = context.getBooleanAttribute("flushCache", !isSelect);
    //获取DML标签的flushCache属性，useCache表示是否对该语句进行二级缓存，默认是对select语句进行缓存。
    boolean useCache = context.getBooleanAttribute("useCache", isSelect);
    /**
     * 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，
     * 这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。
     * 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。
     */
    boolean resultOrdered = context.getBooleanAttribute("resultOrdered", false);

    // Include Fragments before parsing
    /**
     * 处理include标签。其实就是将include标签替换成对应sql标签下的所有子标签
     *
     * 根据include标签的refid属性值去找到存在mybatis全局配置里的对应的SQL标签，
     * 如果sql标签和include标签不在同一个mapper.xml中，会将sql标签加入到与include标签对应的
     * mapper.xml中，然后将include标签替换成sql标签,再将sql标签下的所有子节点（sql标签下面的文本也是子节点的一部分）
     * 全部复制插入到sql标签的父标签下，又在sql标签前面的位置。这里的sql父标签其实就是DML标签，
     * 也就是这里context。最后将sql标签删除。
     *
     * 在覆盖过程中，还会对include标签下的property标签传递给sql标签的'${...}'参数，并更改掉
     */
    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);
    includeParser.applyIncludes(context.getNode());

    /**
     * 获取DML标签的parameterType属性。
     * parmeterType:将要传入语句的参数的完全限定类名或别名。这个属性是可选的，
     * 因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。
     */
    String parameterType = context.getStringAttribute("parameterType");
    Class<?> parameterTypeClass = resolveClass(parameterType);

    /**
     * 获取DML标签的lang属性:
     * lang:指定该DML标签使用的语言驱动
     * 语言驱动：MyBatis 从 3.2 开始支持可插拔脚本语言，这允许你插入一种脚本语言驱动，
     * 并基于这种语言来编写动态 SQL 查询语句
     */
    String lang = context.getStringAttribute("lang");
    LanguageDriver langDriver = getLanguageDriver(lang);

    // Parse selectKey after includes and remove them.
    /**
     * 获取DML标签中的所有对应配置的当前项目引用的databaseId的SelectKey标签，获取没有配置databaseId的SelectKey标签，
     * 遍历selectKey标签集合，将selectKey标签封装成KeyGenerator，然后添加到Mybatis全局配置信息中，
     * 然后删除DML标签中的所有selectKey标签
     */
    processSelectKeyNodes(id, parameterTypeClass, langDriver);

    // Parse the SQL (pre: <selectKey> and <include> were parsed and removed)
    KeyGenerator keyGenerator;
    //拼装selectKey标签的Id,selectKey标签的Id=DML标签ID+!selectKey
    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;
    //检查ID是否简写，简写就应用当前命名空间
    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);
    //如果Mybatis全局配置信息中有keyStatementId对应的KeyGenerator
    if (configuration.hasKeyGenerator(keyStatementId)) {
      //获取keyGenerator
      keyGenerator = configuration.getKeyGenerator(keyStatementId);
    } else {
      //如果DML标签配置了useGeneratorKeys为true，就使用JDBC3KeyGenertor作为keyGenerator;如果为false,就是用NoKeyGenerator
      //默认情况下，配置了MyBatis全局配置信息中的useGenerateKey为true时，只要是SQL是Insert类型的，useGeneratorKeys都会为true.
      /**
       * Jdbc3KeyGenerator:主要用于数据库的自增主键，比如 MySQL、PostgreSQL；会将执行SQL后从Statemenet中获取主键放到参数对象对应的属性里
       * NoKeyGenerator: 什么事情都不干，里面是空实现方法
       */
      keyGenerator = context.getBooleanAttribute("useGeneratedKeys",
          configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))
          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
    }
    //创建DML标签对应的动态SQL
    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);
    //获取StatementType，默认情况下是StatementType.PREPARED
    /**
     * StatementType.STATEMENT:对应于Statement对象，有SQL注入的风险
     * StatementType.PREPARED: PreparedStatement，预编译处理,默认
     * StatementType.CALLABLE:CallableStatement一般调用存储过程的时候使用
     */
    StatementType statementType = StatementType.valueOf(context.getStringAttribute("statementType", StatementType.PREPARED.toString()));
    //fetchSize:尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。
    Integer fetchSize = context.getIntAttribute("fetchSize");
    //timeout:这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。
    Integer timeout = context.getIntAttribute("timeout");
    //获取参数映射ID,对应于parameterMap标签
    String parameterMap = context.getStringAttribute("parameterMap");
    /**
     * 获取结果的类型。MyBatis 通常可以推断出来，但是为了更加精确，写上也不会有什么问题。
     * MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。
     */
    String resultType = context.getStringAttribute("resultType");
    //通过类别名注册器typeAliasRegistry解析出对应的类 实际调用{@link #resolveAlias(String)}，返回类实例
    Class<?> resultTypeClass = resolveClass(resultType);
    // 获取结果映射Id，对应于resultMap标签
    String resultMap = context.getStringAttribute("resultMap");
    /**
     * ResultSetType.DEFAULT:依赖驱动,默认
     * ResultSetType.FORWARD_ONLY:结果集的游标只能向下滚动
     * ResultSetType.SCROLL_INSENSITIVE:结果集的游标可以上下移动，当数据库变化时，当前结果集不变
     * ResultSetType.SCROLL_SENSITIVE:返回可滚动的结果集，当数据库变化时，当前结果集同步改变
     */
    String resultSetType = context.getStringAttribute("resultSetType");
    //将resultSetType转换成ResultSetType枚举
    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);
    /**
     * （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过
     * getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，
     * 默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。
     */
    String keyProperty = context.getStringAttribute("keyProperty");
    /**
     * （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库
     * （像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。
     * 如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。
     */
    String keyColumn = context.getStringAttribute("keyColumn");
    /**
     * 这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，
     * 名称是逗号分隔的。
     */
    String resultSets = context.getStringAttribute("resultSets");
    // 构建MapperStatement对象，并添加到全局配置信息中
    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
        resultSetTypeEnum, flushCache, useCache, resultOrdered,
        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);
  }
```

### MapperBuilderAssistant



















[^p1]:配置初始化版本问题。




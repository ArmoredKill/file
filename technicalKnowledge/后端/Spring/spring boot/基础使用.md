# 概述

使用适配的开发环境：

- **Build systems:** [Maven] | [Gradle] | [Ant] | [Starters]
- **Best practices:** [Code Structure] | [@Configuration] | [@EnableAutoConfiguration] | [Beans and Dependency Injection]
- **Running your code:** [IDE] | [Packaged] | [Maven] | [Gradle]
- **Packaging your app:** [Production jars]
- **Spring Boot CLI:** [Using the CLI]

web应用相关部分：

- **Servlet Web Applications:** [Spring MVC, Jersey, Embedded Servlet Containers]
- **Reactive Web Applications:** [Spring Webflux, Embedded Servlet Containers]
- **Graceful Shutdown:** [Graceful Shutdown]
- **Spring Security:** [Default Security Configuration, Auto-configuration for OAuth2, SAML]
- **Spring Session:** [Auto-configuration for Spring Session]
- **Spring HATEOAS:** [Auto-configuration for Spring HATEOAS]

数据应用处理存储相关：

- **SQL:** [Configuring a SQL Datastore, Embedded Database support, Connection pools, and more.]
- **NOSQL:** [Auto-configuration for NOSQL stores such as Redis, MongoDB, Neo4j, and others.]

消息组件部分：

- **JMS:** [Auto-configuration for ActiveMQ and Artemis, Sending and Receiving messages through JMS]
- **AMQP:** [Auto-configuration for RabbitMQ]
- **Kafka:** [Auto-configuration for Spring Kafka]
- **RSocket:** [Auto-configuration for Spring Framework’s RSocket Support]
- **Spring Integration:** [Auto-configuration for Spring Integration]

应用IO的功能相关：

- **Caching:** [Caching support with EhCache, Hazelcast, Infinispan, and more]
- **Quartz:** [Quartz Scheduling]
- **Mail:** [Sending Email
- **Validation:** [JSR-303 Validation]
- **REST Clients:** [Calling REST Services with RestTemplate and WebClient
- **Webservices:** [Auto-configuration for Spring Web Services]
- **JTA:** [Distributed Transactions with JTA]

# 基础使用

## 系统构建

Spring Boot 的每个版本都提供了它支持的依赖项的精选列表。不需要在构建配置中为任何这些依赖项提供版本，因为 Spring Boot 会进行管理。当您升级 Spring Boot 本身时，这些依赖项也会以一致的方式升级。

Starters 是一组方便的依赖描述符，您可以将它们包含在您的应用程序中。您可以获得所需的所有 Spring 和相关技术的一站式服务，而无需搜索示例代码和复制粘贴大量依赖项描述符。所有**官方**启动器都遵循类似的命名模式；`spring-boot-starter-*`，其中`*`是特定类型的应用程序。此命名结构旨在在您需要查找启动器时提供帮助。Spring Boot 组下提供了以下应用启动器`org.springframework.boot`：

| 名称                                          | 描述                                                         |
| :-------------------------------------------- | :----------------------------------------------------------- |
| `spring-boot-starter`                         | Core starter，包括自动配置支持、日志记录和 YAML              |
| `spring-boot-starter-amqp`                    | 使用 Spring AMQP 和 Rabbit MQ 的启动器                       |
| `spring-boot-starter-aop`                     | 使用 Spring AOP 和 AspectJ 进行面向方面编程的入门            |
| `spring-boot-starter-artemis`                 | 使用 Apache Artemis 的 JMS 消息传递启动器                    |
| `spring-boot-starter-batch`                   | 使用 Spring Batch 的启动器                                   |
| `spring-boot-starter-cache`                   | 使用 Spring Framework 的缓存支持的 Starter                   |
| `spring-boot-starter-data-cassandra`          | 使用 Cassandra 分布式数据库和 Spring Data Cassandra 的 Starter |
| `spring-boot-starter-data-cassandra-reactive` | 使用 Cassandra 分布式数据库和 Spring Data Cassandra Reactive 的 Starter |
| `spring-boot-starter-data-couchbase`          | 使用 Couchbase 面向文档的数据库和 Spring Data Couchbase 的启动器 |
| `spring-boot-starter-data-couchbase-reactive` | 使用 Couchbase 面向文档的数据库和 Spring Data Couchbase Reactive 的 Starter |
| `spring-boot-starter-data-elasticsearch`      | 使用 Elasticsearch 搜索和分析引擎以及 Spring Data Elasticsearch 的 Starter |
| `spring-boot-starter-data-jdbc`               | 使用 Spring Data JDBC 的启动器                               |
| `spring-boot-starter-data-jpa`                | 将 Spring Data JPA 与 Hibernate 一起使用的启动器             |
| `spring-boot-starter-data-ldap`               | 使用 Spring Data LDAP 的启动器                               |
| `spring-boot-starter-data-mongodb`            | 使用 MongoDB 面向文档的数据库和 Spring Data MongoDB 的启动器 |
| `spring-boot-starter-data-mongodb-reactive`   | 使用 MongoDB 文档型数据库和 Spring Data MongoDB Reactive 的 Starter |
| `spring-boot-starter-data-neo4j`              | 使用 Neo4j 图形数据库和 Spring Data Neo4j 的启动器           |
| `spring-boot-starter-data-r2dbc`              | 使用 Spring Data R2DBC 的启动器                              |
| `spring-boot-starter-data-redis`              | 用于将 Redis 键值数据存储与 Spring Data Redis 和 Lettuce 客户端一起使用的 Starter |
| `spring-boot-starter-data-redis-reactive`     | 将 Redis 键值数据存储与 Spring Data Redis 反应式和 Lettuce 客户端一起使用的启动器 |
| `spring-boot-starter-data-rest`               | 使用 Spring Data REST 通过 REST 公开 Spring Data 存储库的 Starter |
| `spring-boot-starter-freemarker`              | 使用 FreeMarker 视图构建 MVC Web 应用程序的启动器            |
| `spring-boot-starter-graphql`                 | 使用 Spring GraphQL 构建 GraphQL 应用程序的 Starter          |
| `spring-boot-starter-groovy-templates`        | 使用 Groovy 模板视图构建 MVC web 应用程序的启动器            |
| `spring-boot-starter-hateoas`                 | 使用 Spring MVC 和 Spring HATEOAS 构建基于超媒体的 RESTful Web 应用程序的启动器 |
| `spring-boot-starter-integration`             | 使用 Spring Integration 的启动器                             |
| `spring-boot-starter-jdbc`                    | 将 JDBC 与 HikariCP 连接池一起使用的启动器                   |
| `spring-boot-starter-jersey`                  | 使用 JAX-RS 和 Jersey 构建 RESTful Web 应用程序的启动器。的替代品[`spring-boot-starter-web`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-web) |
| `spring-boot-starter-jooq`                    | 使用 jOOQ 通过 JDBC 访问 SQL 数据库的启动器。替代[`spring-boot-starter-data-jpa`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-data-jpa)或[`spring-boot-starter-jdbc`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-jdbc) |
| `spring-boot-starter-json`                    | 读写json的starter                                            |
| `spring-boot-starter-mail`                    | 使用 Java Mail 和 Spring Framework 的电子邮件发送支持的 Starter |
| `spring-boot-starter-mustache`                | 使用 Mustache 视图构建 Web 应用程序的启动器                  |
| `spring-boot-starter-oauth2-client`           | 使用 Spring Security 的 OAuth2/OpenID Connect 客户端功能的 Starter |
| `spring-boot-starter-oauth2-resource-server`  | 使用 Spring Security 的 OAuth2 资源服务器功能的启动器        |
| `spring-boot-starter-quartz`                  | 使用 Quartz 调度器的启动器                                   |
| `spring-boot-starter-rsocket`                 | 用于构建 RSocket 客户端和服务器的启动器                      |
| `spring-boot-starter-security`                | 使用 Spring Security 的启动器                                |
| `spring-boot-starter-test`                    | 用于使用 JUnit Jupiter、Hamcrest 和 Mockito 等库测试 Spring Boot 应用程序的 Starter |
| `spring-boot-starter-thymeleaf`               | 使用 Thymeleaf 视图构建 MVC Web 应用程序的启动器             |
| `spring-boot-starter-validation`              | 将 Java Bean Validation 与 Hibernate Validator 结合使用的 Starter |
| `spring-boot-starter-web`                     | 用于使用 Spring MVC 构建 Web（包括 RESTful）应用程序的 Starter。使用 Tomcat 作为默认的嵌入式容器 |
| `spring-boot-starter-web-services`            | 使用 Spring Web 服务的启动器                                 |
| `spring-boot-starter-websocket`               | 使用 Spring Framework 的 MVC WebSocket 支持构建 WebSocket 应用程序的 Starter |
| `spring-boot-starter-webflux`                 | 用于使用 Spring Framework 的 Reactive Web 支持构建 WebFlux 应用程序的 Starter |
| `spring-boot-starter-actuator`                | 使用 Spring Boot Actuator 的 Starter，它提供生产就绪功能来帮助您监控和管理您的应用程序 |
| `spring-boot-starter-jetty`                   | 使用 Jetty 作为嵌入式 servlet 容器的启动器。的替代品[`spring-boot-starter-tomcat`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-tomcat) |
| `spring-boot-starter-log4j2`                  | 使用 Log4j2 进行日志记录的启动器。的替代品[`spring-boot-starter-logging`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-logging) |
| `spring-boot-starter-logging`                 | 使用 Logback 进行日志记录的启动器。默认日志记录启动器        |
| `spring-boot-starter-reactor-netty`           | 使用 Reactor Netty 作为嵌入式响应式 HTTP 服务器的启动器。    |
| `spring-boot-starter-tomcat`                  | 将 Tomcat 用作嵌入式 servlet 容器的启动器。使用的默认 servlet 容器启动器[`spring-boot-starter-web`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-web) |
| `spring-boot-starter-undertow`                | 使用 Undertow 作为嵌入式 servlet 容器的启动器。的替代品[`spring-boot-starter-tomcat`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-tomcat) |

## 应用启动

该类`SpringApplication`提供了一种方便的方法来引导从`main()`方法启动的 Spring 应用程序。在许多情况下，您可以委托给静态`SpringApplication.run`方法，如以下示例所示：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

当您的应用程序启动时，输出内容：

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.0.2)

2023-01-20T00:27:31.367Z  INFO 21229 --- [           main] o.s.b.d.f.s.MyApplication                : Starting MyApplication using Java 17.0.6 with PID 21229 (/opt/apps/myapp.jar started by myuser in /opt/apps/)
2023-01-20T00:27:31.385Z  INFO 21229 --- [           main] o.s.b.d.f.s.MyApplication                : No active profile set, falling back to 1 default profile: "default"
2023-01-20T00:27:34.696Z  INFO 21229 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2023-01-20T00:27:34.769Z  INFO 21229 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2023-01-20T00:27:34.770Z  INFO 21229 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.5]
2023-01-20T00:27:35.264Z  INFO 21229 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2023-01-20T00:27:35.266Z  INFO 21229 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3786 ms
2023-01-20T00:27:36.384Z  INFO 21229 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2023-01-20T00:27:36.401Z  INFO 21229 --- [           main] o.s.b.d.f.s.MyApplication                : Started MyApplication in 6.557 seconds (process running for 7.483)
```

### 惰性初始化

`SpringApplication`允许延迟初始化应用程序。当启用惰性初始化时，bean 是在需要时创建的，而不是在应用程序启动期间创建的。因此，启用惰性初始化可以减少应用程序启动所需的时间。在 web 应用程序中，启用惰性初始化将导致许多与 web 相关的 bean 在收到 HTTP 请求之前不会被初始化。

惰性初始化的一个缺点是它可以延迟发现应用程序的问题。如果配置错误的 bean 被懒惰地初始化，则在启动期间将不再发生故障，并且只有在 bean 被初始化时问题才会变得明显。还必须注意确保 JVM 有足够的内存来容纳所有应用程序的 bean，而不仅仅是那些在启动期间初始化的 bean。

`lazyInitialization`可以使用on 方法`SpringApplicationBuilder`或`setLazyInitialization`on方法以编程方式启用延迟初始化`SpringApplication`。或者，可以使用`spring.main.lazy-initialization`以下示例中所示的属性启用它：
```yaml
spring:  
	main:    
		lazy-initialization: true
```

### 自定义banner

`banner.txt`可以通过将文件添加到类路径或将`spring.banner.location`属性设置为此类文件的位置来更改启动时打印的横幅。如果文件的编码不是 UTF-8，可以设置`spring.banner.charset`.在您的`banner.txt`文件中，您可以使用 中可用的任何键`Environment`以及以下任何占位符：

| 变量                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `${application.version}`                                     | 您的应用程序的版本号，如在中声明的那样`MANIFEST.MF`。例如，`Implementation-Version: 1.0`打印为`1.0`. |
| `${application.formatted-version}`                           | 您的应用程序的版本号，在中声明`MANIFEST.MF`并格式化显示（用括号括起来并以 为前缀`v`）。例如`(v1.0)`。 |
| `${spring-boot.version}`                                     | 您正在使用的 Spring Boot 版本。例如`3.0.2`。                 |
| `${spring-boot.formatted-version}`                           | 您正在使用的 Spring Boot 版本，经过格式化以供显示（用方括号括起来并以 为前缀`v`）。例如`(v3.0.2)`。 |
| `${Ansi.NAME}`（或`${AnsiColor.NAME}`，，`${AnsiBackground.NAME}`）`${AnsiStyle.NAME}` | `NAME`ANSI 转义代码的名称在哪里。详情请见[`AnsiPropertySource`](https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java)。 |
| `${application.title}`                                       | 您的应用程序的标题，如中声明的那样`MANIFEST.MF`。例如`Implementation-Title: MyApp`打印为`MyApp`. |

### 自定义 SpringApplication

可以创建一个本地实例并对其进行自定义。例如，要关闭横幅，您可以这样写：

```java
import org.springframework.boot.Banner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(MyApplication.class);
        application.setBannerMode(Banner.Mode.OFF);
        application.run(args);
    }
}
```

### 应用可用性

当部署在平台上时，应用程序可以使用Kubernetes Probes。等基础设施向平台提供有关其可用性的信息。Spring Boot 包括对常用的“活动”和“就绪”可用性状态的开箱即用支持。如果您使用 Spring Boot 的“执行器”支持，那么这些状态将作为健康端点组公开。此外，您还可以通过将`ApplicationAvailability`接口注入到您自己的 bean 中来获取可用性状态。

应用程序的“活动”状态表明它的内部状态是否允许它正常工作，或者如果它当前失败则自行恢复。损坏的“活动”状态意味着应用程序处于无法恢复的状态，基础架构应重新启动应用程序。Spring Boot 应用程序的内部状态主要由 Spring 表示`ApplicationContext`。如果应用程序上下文已成功启动，Spring Boot 会假定应用程序处于有效状态。一旦上下文被刷新，应用程序就被认为是活跃的

应用程序的“就绪”状态表明应用程序是否已准备好处理流量。失败的“就绪”状态告诉平台它现在不应该将流量路由到应用程序。这通常发生在启动期间，同时正在处理`CommandLineRunner`和`ApplicationRunner`组件，或者在应用程序决定它太忙而无法处理额外流量时发生。一旦应用程序和命令行运行程序被调用，应用程序就被认为准备就绪。

应用程序组件可以随时通过注入`ApplicationAvailability`接口和调用方法来检索当前的可用性状态。更多时候，应用程序会想要监听状态更新或更新应用程序的状态。例如，我们可以将应用程序的“Readiness”状态导出到一个文件中，以便 Kubernetes 的“exec Probe”可以查看这个文件：

```java
@Component
public class MyReadinessStateExporter {

    @EventListener
    public void onStateChange(AvailabilityChangeEvent<ReadinessState> event) {
        switch (event.getState()) {
            case ACCEPTING_TRAFFIC:
                // create file /tmp/healthy
                break;
            case REFUSING_TRAFFIC:
                // remove file /tmp/healthy
                break;
        }
    }

}
```

当应用程序中断且无法恢复时，我们还可以更新应用程序的状态：

```java
@Component
public class MyLocalCacheVerifier {

    private final ApplicationEventPublisher eventPublisher;

    public MyLocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    public void checkLocalCache() {
        try {
            // ...
        }
        catch (CacheCompletelyBrokenException ex) {
            AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);
        }
    }

}
```

### 应用程序事件和监听器

除了通常的 Spring Framework 事件（例如 ）之外`ContextRefreshedEvent`，`SpringApplication`还会发送一些额外的应用程序事件。

有些事件实际上`ApplicationContext`是在创建之前触发的，因此您不能将这些事件的侦听器注册为`@Bean`. `SpringApplication.addListeners(…)`您可以使用方法或方法注册它们`SpringApplicationBuilder.listeners(…)`。

自动注册这些侦听器，而不管应用程序的创建方式如何，您可以将`META-INF/spring.factories`文件添加到您的项目并使用`org.springframework.context.ApplicationListener`密钥引用您的侦听器，如以下示例所示：

```
org.springframework.context.ApplicationListener=com.example.project.MyListener
```

当您的应用程序运行时，应用程序事件按以下顺序发送：

1. An`ApplicationStartingEvent`在运行开始时发送，但在任何处理之前发送，除了侦听器和初始化器的注册。
2. 当要在上下文中使用的 已知但在创建上下文之前`ApplicationEnvironmentPreparedEvent`发送An 。`Environment`
3. 准备好并调用 ApplicationContextInitializers 但在加载任何 bean 定义之前`ApplicationContextInitializedEvent`发送An 。`ApplicationContext`
4. 就在`ApplicationPreparedEvent`刷新开始之前但在加载 bean 定义之后发送。
5. `ApplicationStartedEvent`在刷新上下文之后但在调用任何应用程序和命令行运行程序之前发送An 。
6. `AvailabilityChangeEvent`在 with 之后立即发送An`LivenessState.CORRECT`以指示该应用程序被认为是实时的。
7. `ApplicationReadyEvent`在调用任何应用[程序和命令行运行程序](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.command-line-runner)后发送。
8. `AvailabilityChangeEvent`在 with 之后立即发送An`ReadinessState.ACCEPTING_TRAFFIC`以指示应用程序已准备好服务请求。
9. `ApplicationFailedEvent`如果启动时出现异常，则发送An 。

上面的列表只包括`SpringApplicationEvent`绑定到 a 的 s `SpringApplication`。除了这些之外，以下事件也在之后`ApplicationPreparedEvent`和之前发布`ApplicationStartedEvent`：

- A在准备就绪`WebServerInitializedEvent`后发送`WebServer`。 `ServletWebServerInitializedEvent`和`ReactiveWebServerInitializedEvent`分别是 servlet 和反应式变体。
- 刷新`ContextRefreshedEvent`时发送A。`ApplicationContext`

应用事件通过Spring Framework的事件发布机制发送。该机制的一部分确保发布到子上下文中的侦听器的事件也被发布到任何祖先上下文中的侦听器。因此，如果您的应用程序使用`SpringApplication`实例层次结构，则侦听器可能会收到同一类型应用程序事件的多个实例。

为了让您的侦听器区分其上下文的事件和后代上下文的事件，它应该请求注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现注入上下文，`ApplicationContextAware`或者，如果侦听器是一个 bean，则使用`@Autowired`.

### web调用

A`SpringApplication`尝试`ApplicationContext`代表您创建正确的类型。用于确定 a 的算法`WebApplicationType`如下：

- 如果存在 Spring MVC，`AnnotationConfigServletWebServerApplicationContext`则使用
- 如果 Spring MVC 不存在而 Spring WebFlux 存在，`AnnotationConfigReactiveWebServerApplicationContext`则使用
- 否则，`AnnotationConfigApplicationContext`使用

这意味着如果您`WebClient`在同一应用程序中使用 Spring MVC 和 Spring WebFlux 的新功能，则默认情况下将使用 Spring MVC。您可以通过调用轻松覆盖它`setWebApplicationType(WebApplicationType)`。

也可以完全控制`ApplicationContext`调用所使用的类型`setApplicationContextClass(…)`。

### 访问Application参数

如果您需要访问传递给 的应用程序参数`SpringApplication.run(…)`，您可以注入一个`org.springframework.boot.ApplicationArguments`bean。该`ApplicationArguments`接口提供对原始`String[]`参数以及已解析参数`option`和`non-option`参数的访问，如以下示例所示：

```java
@Component
public class MyBean {

    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List<String> files = args.getNonOptionArgs();
        if (debug) {
            System.out.println(files);
        }
        // if run with "--debug logfile.txt" prints ["logfile.txt"]
    }
}
```

### 使用 ApplicationRunner 或 CommandLineRunner

如果您需要在启动后运行一些特定的代码`SpringApplication`，您可以实现`ApplicationRunner`或`CommandLineRunner`接口。这两个接口以相同的方式工作，并提供一个`run`方法，该方法在完成之前被调用`SpringApplication.run(…)`。

这些`CommandLineRunner`接口提供对应用程序参数作为字符串数组的访问，而`ApplicationRunner`使用`ApplicationArguments`前面讨论的接口。以下示例显示了`CommandLineRunner`一个`run`方法：

```java
@Component
public class MyCommandLineRunner implements CommandLineRunner {

    @Override
    public void run(String... args) {
        // Do something...
    }

}
```

### 应用退出

每个都`SpringApplication`向 JVM 注册一个关闭挂钩，以确保`ApplicationContext`在退出时正常关闭。可以使用所有标准的 Spring 生命周期回调（例如`DisposableBean`接口或`@PreDestroy`注释）。

此外，如果 bean希望在被调用`org.springframework.boot.ExitCodeGenerator`时返回特定的退出代码，则它们可以实现该接口。`SpringApplication.exit()`然后可以将此退出代码传递给以将`System.exit()`其作为状态代码返回，如以下示例所示：

```java
@SpringBootApplication
public class MyApplication {

    @Bean
    public ExitCodeGenerator exitCodeGenerator() {
        return () -> 42;
    }

    public static void main(String[] args) {
        System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args)));
    }

}
```

此外，`ExitCodeGenerator`接口可以通过异常来实现。遇到此类异常时，Spring Boot 会返回已实现`getExitCode()`方法提供的退出代码。如果有多个`ExitCodeGenerator`，则使用生成的第一个非零退出代码。

### 应用程序启动跟踪

在应用程序启动期间，`SpringApplication`执行`ApplicationContext`许多与应用程序生命周期、bean 生命周期甚至处理应用程序事件相关的任务。有了[`ApplicationStartup`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html)Spring Framework [，您就可以使用`StartupStep`对象](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/core.html#context-functionality-startup)跟踪应用程序启动顺序。您可以`ApplicationStartup`在设置`SpringApplication`实例时选择一个实现。例如，要使用`BufferingApplicationStartup`：

```java
@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(MyApplication.class);
        application.setApplicationStartup(new BufferingApplicationStartup(2048));
        application.run(args);
    }

}
```

第一个可用的实现`FlightRecorderApplicationStartup`由 Spring Framework 提供。它将特定于 Spring 的启动事件添加到 Java Flight Recorder 会话，旨在分析应用程序并将其 Spring 上下文生命周期与 JVM 事件（例如分配、GC、类加载……）相关联。配置完成后，您可以在启用飞行记录器的情况下运行应用程序来记录数据：

```
$ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar
```

Spring Boot 附带`BufferingApplicationStartup`变体；此实现旨在缓冲启动步骤并将它们排入外部指标系统。`BufferingApplicationStartup`应用程序可以在任何组件中请求类型的 bean 。Spring Boot 还可以配置为公开一个以 JSON 文档形式提供此信息的`startup`端点。

## 外部配置

Spring Boot 允许您外部化您的配置，以便您可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括 Java 属性文件、YAML 文件、环境变量和命令行参数。属性值可以通过注解直接注入 bean `@Value`，通过 Spring 的[抽象](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties)`Environment`访问，或者通过.`@ConfigurationProperties`。Spring Boot 使用一种非常特殊的`PropertySource`顺序，旨在允许合理地覆盖值。后面的属性源可以覆盖前面定义的值。来源按以下顺序考虑：

1. 默认属性（由设置指定`SpringApplication.setDefaultProperties`）。
2. [`@PropertySource`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/context/annotation/PropertySource.html)类上的注释`@Configuration`。请注意，`Environment`在刷新应用程序上下文之前，不会将此类属性源添加到。现在配置某些属性（例如`logging.*`和`spring.main.*`在刷新开始前读取）为时已晚。
3. 配置数据（例如`application.properties`文件）。
4. 仅在`RandomValuePropertySource`中具有属性的`random.*`。
5. 操作系统环境变量。
6. Java 系统属性 ( `System.getProperties()`)。
7. JNDI 属性来自`java:comp/env`.
8. `ServletContext`初始化参数。
9. `ServletConfig`初始化参数。
10. 属性来自`SPRING_APPLICATION_JSON`（嵌入在环境变量或系统属性中的内联 JSON）。
11. 命令行参数。
12. `properties`测试的属性。[`@SpringBootTest`](https://docs.spring.io/spring-boot/docs/3.0.2/api/org/springframework/boot/test/context/SpringBootTest.html)在和测试注释上可用，[用于测试应用程序的特定部分](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests)。
13. [`@TestPropertySource`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/test/context/TestPropertySource.html)测试注释。
14. `$HOME/.config/spring-boot`当 devtools 处于活动状态时，目录中的[Devtools 全局设置属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.globalsettings)

配置数据文件按以下顺序考虑：

1. 打包在 jar 中的[应用程序属性](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files)`application.properties`（和 YAML 变体）。
2. 打包在您的 jar（`application-{profile}.properties`和 YAML 变体）中[的特定于配置文件的应用程序属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.profile-specific)
3. 打包的 jar（`application.properties`和 YAML 变体）之外的[应用程序属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files)
4. 打包的 jar（`application-{profile}.properties`和 YAML 变体）之外的[特定于配置文件的应用程序属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.profile-specific)

### 命令行属性

默认情况下，`SpringApplication`将任何命令行选项参数（即以 开头的参数`--`，例如`--server.port=9000`）转换为 `property`并将它们添加到 Spring`Environment`中。如前所述，命令行属性始终优先于基于文件的属性源。如果您不想将命令行属性添加到 中`Environment`，您可以使用 禁用它们`SpringApplication.setAddCommandLineProperties(false)`。

### JSON 应用程序属性

环境变量和系统属性通常有限制，这意味着某些属性名称不能使用。为了解决这个问题，Spring Boot 允许您将属性块编码为单个 JSON 结构。

当您的应用程序启动时，任何`spring.application.json`或`SPRING_APPLICATION_JSON`属性将被解析并添加到`Environment`.例如，`SPRING_APPLICATION_JSON`可以在 UN*X shell 的命令行中将属性作为环境变量提供：

```shell
$ SPRING_APPLICATION_JSON='{"my":{"name":"test"}}' java -jar myapp.jar
```

在前面的示例中，您最终`my.name=test`在 Spring 中`Environment`。

同样的 JSON 也可以作为系统属性提供：

```shell
$ java -Dspring.application.json='{"my":{"name":"test"}}' -jar myapp.jar
```

或者您可以使用命令行参数提供 JSON：

```shell
$ java -jar myapp.jar --spring.application.json='{"my":{"name":"test"}}'
```

###  外部应用程序属性

当您的应用程序启动时，Spring Boot 将自动从以下位置查找并加载文件`application.properties`：`application.yaml`

1. 从类路径
   1. 类路径根
   2. 类路径`/config`包
2. 从当前目录
   1. 当前目录
   2. 当前目录下的`config/`子目录
   3. 子目录的`config/`直接子目录

该列表按优先级排序（较低项的值覆盖较早的项）。加载文件中的文档被添加`PropertySources`到 Spring`Environment`中。

如果您不喜欢`application`作为配置文件名，您可以通过指定一个`spring.config.name`环境属性来切换到另一个文件名。例如，要查找`myproject.properties`和`myproject.yaml`文件，您可以按如下方式运行您的应用程序：

```shell
$ java -jar myproject.jar --spring.config.name=myproject
```

您还可以使用`spring.config.location`环境属性来引用显式位置。此属性接受一个或多个要检查的位置的逗号分隔列表。

以下示例显示如何指定两个不同的文件：

```shell
$ java -jar myproject.jar --spring.config.location=\
    optional:classpath:/default.properties,\
    optional:classpath:/override.properties
```

`optional:`如果[位置是可选](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.optional-prefix)的并且您不介意它们不存在， 请使用前缀。

如果`spring.config.location`包含目录（而不是文件），它们应该以`/`. 在运行时，它们将附加`spring.config.name`在加载之前生成的名称。中指定的文件`spring.config.location`直接导入。

在大多数情况下，`spring.config.location`您添加的每个项目都将引用一个文件或目录。位置按照它们被定义的顺序处理，后面的可以覆盖前面的值。如果你有一个复杂的位置设置，并且你使用特定于配置文件的配置文件，你可能需要提供进一步的提示，以便 Spring Boot 知道它们应该如何分组。位置组是所有位置都被视为同一级别的位置的集合。例如，您可能希望对所有类路径位置进行分组，然后对所有外部位置进行分组。位置组中的项目应该用 分隔`;`。使用配置的`spring.config.location`位置替换默认位置。例如，如果`spring.config.location`配置了值`optional:classpath:/custom-config/,optional:file:./custom-config/`，则考虑的完整位置集是：

1. `optional:classpath:custom-config/`
2. `optional:file:./custom-config/`

如果您更喜欢添加其他位置，而不是替换它们，您可以使用`spring.config.additional-location`. 从其他位置加载的属性可以覆盖默认位置中的属性。例如，如果`spring.config.additional-location`配置了值`optional:classpath:/custom-config/,optional:file:./custom-config/`，则考虑的完整位置集是：

1. `optional:classpath:/;optional:classpath:/config/`
2. `optional:file:./;optional:file:./config/;optional:file:./config/*/`
3. `optional:classpath:custom-config/`
4. `optional:file:./custom-config/`

注意：

- 如果您使用环境变量而不是系统属性，大多数操作系统不允许使用句点分隔的键名，但您可以使用下划线代替（例如，`SPRING_CONFIG_NAME`代替`spring.config.name`）。
- 如果您的应用程序在 servlet 容器或应用程序服务器中运行，则可以使用 JNDI 属性（在 中`java:comp/env`）或 servlet 上下文初始化参数来代替或同时使用环境变量或系统属性。

#### 可选位置

默认情况下，当指定的配置数据位置不存在时，Spring Boot 将抛出一个`ConfigDataLocationNotFoundException`并且您的应用程序将不会启动。如果你想指定一个位置，但你不介意它并不总是存在，你可以使用`optional:`前缀。您可以将此前缀与`spring.config.location`和`spring.config.additional-location`属性以及[`spring.config.import`](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.importing)声明一起使用。

例如，`spring.config.import`值`optional:file:./myconfig.properties`允许您的应用程序启动，即使`myconfig.properties`文件丢失。如果您想忽略所有`ConfigDataLocationNotFoundExceptions`并始终继续启动您的应用程序，您可以使用该`spring.config.on-not-found`属性。将值设置为`ignore`使用`SpringApplication.setDefaultProperties(…)`或与系统/环境变量一起使用。

#### 通配符

如果配置文件位置包含`*`最后一个路径段的字符，则它被视为通配符位置。加载配置时会扩展通配符，以便也检查直接子目录。当存在多个配置属性源时，通配符位置在 Kubernetes 等环境中特别有用。

例如，如果您有一些 Redis 配置和一些 MySQL 配置，您可能希望将这两部分配置分开，同时要求它们都存在于一个`application.properties`文件中。这可能会导致两个单独的`application.properties`文件安装在不同的位置，例如`/config/redis/application.properties`和`/config/mysql/application.properties`。在这种情况下，具有通配符位置`config/*/`, 将导致同时处理两个文件。默认情况下，Spring Boot 包含`config/*/`在默认搜索位置中。这意味着`/config`将搜索 jar 之外目录的所有子目录。

您可以自己将通配符位置与`spring.config.location`和`spring.config.additional-location`属性一起使用。对于作为目录的搜索位置或作为文件的搜索位置， 通配符位置必须仅包含一个`*`并以结尾。带通配符的位置根据文件名的绝对路径按字母顺序排序。 `*/``*/<filename>`。通配符位置仅适用于外部目录。<span style="color:red">您不能在`classpath:`位置中使用通配符。</span>

#### 特定配置文件

除了`application`属性文件，Spring Boot 还将尝试使用命名约定加载特定于配置文件的文件`application-{profile}`。例如，如果您的应用程序激活一个名为 profile`prod`并使用 YAML 文件，那么`application.yml`和`application-prod.yml`都会被考虑。

特定于配置文件的属性从与标准相同的位置加载，`application.properties`特定于配置文件的文件始终覆盖非特定文件。如果指定了多个配置文件，则应用最后获胜的策略。例如，如果配置文件`prod,live`由`spring.profiles.active`属性指定，则 中的值`application-prod.properties`可以被 中的值覆盖`application-live.properties`。

属性文件只加载一次。如果您已经直接[导入](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.importing)了配置文件特定的属性文件，则不会再次导入它。

#### 导入附加数据

应用程序属性可以使用该属性从其他位置导入更多配置数据`spring.config.import`。进口在发现时进行处理，并被视为紧接在声明进口的文件下方插入的附加文件。例如，您的类路径`application.properties`文件中可能包含以下内容：

```java
spring:
  application:
    name: "myapp"
  config:
    import: "optional:file:./dev.properties"
```

这将触发`dev.properties`当前目录中文件的导入（如果存在这样的文件）。来自导入的值`dev.properties`将优先于触发导入的文件。在上面的示例中，`dev.properties`可以重新定义`spring.application.name`为不同的值。<span style="color:red">一个导入无论声明多少次都只会被导入一次。</span>

Spring Boot 包含可插入的 API，允许支持各种不同的位置地址。默认情况下，您可以导入 Java 属性、YAML 和“[配置树](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.configtree)”。第三方 jar 可以提供对其他技术的支持（不要求文件是本地的）。例如，您可以想象配置数据来自 Consul、Apache ZooKeeper 或 Netflix Archaius 等外部存储。如果您想支持自己的位置，请参阅包中的`ConfigDataLocationResolver`和`ConfigDataLoader`类`org.springframework.boot.context.config`。

#### 导入无扩展名文件

某些云平台无法为卷挂载文件添加文件扩展名。要导入这些没有扩展名的文件，你需要给 Spring Boot 一个提示，让它知道如何加载它们。您可以通过在方括号中放置一个扩展提示来做到这一点。例如，假设您有一个`/etc/config/myconfig`要导入为 yaml 的文件。您可以`application.properties`使用以下方法将其导入：

```yaml
spring:
  config:
    import: "file:/etc/config/myconfig[.yaml]"
```

#### 使用配置树

在云平台（例如 Kubernetes）上运行应用程序时，您经常需要读取平台提供的配置值。出于此类目的使用环境变量并不少见，但这可能有缺点，尤其是在值应该保密的情况下。作为环境变量的替代方案，许多云平台现在允许您将配置映射到已安装的数据卷中。例如，Kubernetes 可以卷挂载[`ConfigMaps`](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap)和[`Secrets`](https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod).

可以使用两种常见的卷安装模式：

1. 单个文件包含一组完整的属性（通常写为 YAML）。
2. 多个文件被写入目录树，文件名成为“键”，内容成为“值”。

对于第一种情况，您可以直接使用[上述](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.importing)`spring.config.import`方法导入 YAML 或 Properties 文件。对于第二种情况，您需要使用前缀，以便 Spring Boot 知道它需要将所有文件公开为属性。`configtree:`。 Kubernetes 已经安装了以下卷：

```
etc/
  config/
    myapp/
      username
      password
```

该`username`文件的内容将是一个配置值，而其内容`password`将是一个秘密。

要导入这些属性，您可以将以下内容添加到您的`application.properties`or`application.yaml`文件中：

```yaml
spring:
  config:
    import: "optional:configtree:/etc/config/"
```

myapp.username`然后，您可以以通常的方式访问或注入`myapp.password`属性。`Environment

如果您有多个配置树要从同一个父文件夹导入，您可以使用通配符快捷方式。`configtree:`以结尾的任何位置`/*/`都将导入所有直接子项作为配置树。例如，给定以下体积：

```
etc/
  config/
    dbconfig/
      db/
        username
        password
    mqconfig/
      mq/
        username
        password
```

您可以`configtree:/etc/config/*/`用作导入位置：

```yaml
spring:
  config:
    import: "optional:configtree:/etc/config/*/"
```

使用通配符加载的目录按字母顺序排序。如果您需要不同的订单，那么您应该将每个位置列为单独的导入

配置树也可用于 Docker 机密。当 Docker swarm 服务被授予访问秘密的权限时，秘密就会被装载到容器中。例如，如果一个名为 secret`db.password`挂载在 location `/run/secrets/`，您可以`db.password`使用以下命令使 Spring 环境可用：

```yaml
spring:
  config:
    import: "optional:configtree:/run/secrets/"
```

#### 属性占位符

`application.properties`和中的值在使用时会`application.yml`通过现有值进行过滤`Environment`，因此您可以参考以前定义的值（例如，来自系统属性或环境变量）。标准`${name}`属性占位符语法可用于值内的任何位置。属性占位符还可以指定一个默认值，使用 a`:`将默认值与属性名称分隔开，例如`${name:default}`。以下示例显示了带默认值和不带默认值的占位符的使用：

```yaml
app:
  name: "MyApp"
  description: "${app.name} is a Spring Boot application written by ${username:Unknown}"
```

假设该`username`属性未在别处设置，`app.description`则值为`MyApp is a Spring Boot application written by Unknown`。您应该始终使用规范形式（仅使用小写字母的 kebab-case）来引用占位符中的属性名称。

#### 多文档文件

Spring Boot 允许您将单个物理文件拆分为多个逻辑文档，每个逻辑文档都是独立添加的。文档按顺序从上到下处理。以后的文档可以覆盖早期文档中定义的属性。对于`application.yml`文件，使用标准的 YAML 多文档语法。三个连续的连字符代表一个文档的结尾和下一个文档的开始。

例如，以下文件有两个逻辑文档：

```yaml
spring:
  application:
    name: "MyApp"
---
spring:
  application:
    name: "MyCloudApp"
  config:
    activate:
      on-cloud-platform: "kubernetes"
```

对于`application.properties`文件，特殊`#---`或`!---`注释用于标记文档拆分：

```properties
spring.application.name=MyApp
#---
spring.application.name=MyCloudApp
spring.config.activate.on-cloud-platform=kubernetes
```

注意：

- 属性文件分隔符不能有任何前导空格，并且必须正好有三个连字符。分隔符前后的行不能是相同的注释前缀。
- 多文档属性文件通常与激活属性结合使用，例如`spring.config.activate.on-profile`。
- 不能使用`@PropertySource`或`@TestPropertySource`注释加载多文档属性文件。

#### 激活属性

有时仅在满足某些条件时才激活一组给定的属性很有用。例如，您可能拥有仅在特定配置文件处于活动状态时才相关的属性。您可以使用 有条件地激活属性文档`spring.config.activate.*`。以下激活属性可用：

| 属性                | 描述                                      |
| :------------------ | :---------------------------------------- |
| `on-profile`        | 必须匹配文档才能激活的配置文件表达式。    |
| `on-cloud-platform` | `CloudPlatform`必须检测到文档才能激活的。 |

例如，以下指定第二个文档仅在 Kubernetes 上运行时才处于活动状态，并且仅当“prod”或“staging”配置文件处于活动状态时：

```yaml
myprop:
  "always-set"
---
spring:
  config:
    activate:
      on-cloud-platform: "kubernetes"
      on-profile: "prod | staging"
myotherprop: "sometimes-set"
```

### 加密属性

Spring Boot 不提供任何对加密属性值的内置支持，但是，它确实提供了修改 Spring 中包含的值所需的挂钩点`Environment`。该`EnvironmentPostProcessor`界面允许您`Environment`在应用程序启动之前操作。如果您需要一种安全的方式来存储凭据和密码，[Spring Cloud Vault](https://cloud.spring.io/spring-cloud-vault/)项目提供了对在[HashiCorp Vault](https://www.vaultproject.io/)中存储外部化配置的支持。

### 使用 YAML

[YAML](https://yaml.org/)是 JSON 的超集，因此是一种用于指定分层配置数据的便捷格式。只要您的类路径上有[SnakeYAML](https://github.com/snakeyaml/snakeyaml)库，`SpringApplication`该类就会自动支持 YAML 作为属性的替代方法。

YAML 文档需要从其分层格式转换为可与 Spring 一起使用的平面结构`Environment`。例如，考虑以下 YAML 文档：

```yaml
environments:
  dev:
    url: "https://dev.example.com"
    name: "Developer Setup"
  prod:
    url: "https://another.example.com"
    name: "My Cool App"
```

为了从 访问这些属性`Environment`，它们将被展平如下：

```properties
environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App
```

同样，YAML 列表也需要扁平化。它们表示为带有`[index]`解引用器的属性键。例如，考虑以下 YAML：

```yaml
my:
 servers:
 - "dev.example.com"
 - "another.example.com"
```

前面的示例将转换为这些属性：

```properties
my.servers[0]=dev.example.com
my.servers[1]=another.example.com
```

Spring 框架提供了两个方便的类，可用于加载 YAML 文档。将`YamlPropertiesFactoryBean`YAML 加载为`Properties`并将`YamlMapFactoryBean`YAML 加载为`Map`.`YamlPropertySourceLoader`如果要将 YAML 作为 Spring 加载，也可以使用该类`PropertySource`。

### 配置随机值

这`RandomValuePropertySource`对于注入随机值很有用（例如，注入秘密或测试用例）。它可以生成整数、长整数、uuid 或字符串，如以下示例所示：

```yaml
my:
  secret: "${random.value}"
  number: "${random.int}"
  bignumber: "${random.long}"
  uuid: "${random.uuid}"
  number-less-than-ten: "${random.int(10)}"
  number-in-range: "${random.int[1024,65536]}"
```

`random.int*`语法是任何`OPEN value (,max) CLOSE`字符`OPEN,CLOSE`和`value,max`整数。如果`max`提供，`value`则为最小值，`max`为最大值（不包括）。

### 配置系统环境属性

Spring Boot 支持为环境属性设置前缀。如果系统环境由具有不同配置要求的多个 Spring Boot 应用程序共享，这将非常有用。系统环境属性的前缀可以直接在`SpringApplication`。例如，如果将前缀设置为，则也将像在系统环境中一样解析`input`诸如 之类的属性。`remote.timeout``input.remote.timeout`

### 类型安全配置属性

使用`@Value("${property}")`注解注入配置属性有时会很麻烦，尤其是当您使用多个属性或您的数据本质上是分层的时。Spring Boot 提供了一种使用属性的替代方法，可以让强类型 bean 管理和验证应用程序的配置。

#### JavaBean 属性绑定

可以绑定声明标准 JavaBean 属性的 bean，如以下示例所示：

```java
@ConfigurationProperties("my.service")
public class MyProperties {

    private boolean enabled;

    private InetAddress remoteAddress;

    private final Security security = new Security();

    // getters / setters...

    public static class Security {

        private String username;

        private String password;

        private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

        // getters / setters...

    }

}
```

前面的 POJO 定义了以下属性：

- `my.service.enabled`，默认值为`false`。
- `my.service.remote-address`, 具有可以从`String`.
- `my.service.security.username`，具有嵌套的“安全”对象，其名称由属性的名称确定。特别是，该类型根本没有在那里使用，可能是`SecurityProperties`.
- `my.service.security.password`.
- `my.service.security.roles`，其中的集合`String`默认为`USER`.

#### 构造函数绑定

上一节中的示例可以以不可变的方式重写，如以下示例所示：

```java
@ConfigurationProperties("my.service")
public class MyProperties {

    // fields...

    public MyProperties(boolean enabled, InetAddress remoteAddress, Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }

    // getters...

    public static class Security {

        // fields...

        public Security(String username, String password, @DefaultValue("USER") List<String> roles) {
            this.username = username;
            this.password = password;
            this.roles = roles;
        }

        // getters...

    }

}
```

在此设置中，单个参数化构造函数的存在意味着应该使用构造函数绑定。这意味着绑定器将找到一个带有您希望绑定的参数的构造函数。如果你的类有多个构造函数，`@ConstructorBinding`注解可以用来指定哪个构造函数用于构造函数绑定。要为具有单个参数化构造函数的类选择退出构造函数绑定，必须使用`@Autowired`. 构造函数绑定可以与记录一起使用。除非您的记录有多个构造函数，否则不需要使用`@ConstructorBinding`.

构造函数绑定类的嵌套成员（如上`Security`例）也将通过其构造函数进行绑定。可以使用`@DefaultValue`构造函数参数和记录组件指定默认值。转换服务将用于将注释的`String`值强制转换为缺失属性的目标类型。如果没有属性绑定到`Security`，则该`MyProperties`实例将包含 的`null`值`security`。要使它包含一个非空的实例，`Security`即使没有属性绑定到它（使用 Kotlin 时，这将需要将 的`username`和`password`参数`Security`声明为可空的，因为它们没有默认值），使用空`@DefaultValue`注释：

```java
public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) {
    this.enabled = enabled;
    this.remoteAddress = remoteAddress;
    this.security = security;
}
```

#### @ConfigurationProperties 注释类型

Spring Boot 提供基础设施来绑定`@ConfigurationProperties`类型并将它们注册为 beans。您可以逐个类地启用配置属性，也可以启用以类似于组件扫描的方式工作的配置属性扫描。

有时，带有注释的类`@ConfigurationProperties`可能不适合扫描，例如，如果您正在开发自己的自动配置或者您希望有条件地启用它们。在这些情况下，使用`@EnableConfigurationProperties`注释指定要处理的类型列表。这可以在任何`@Configuration`类上完成，如以下示例所示：

```java
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(SomeProperties.class)
public class MyConfiguration {

}
```

要使用配置属性扫描，请将`@ConfigurationPropertiesScan`注释添加到您的应用程序。通常，它被添加到带有注释的主应用程序类中，`@SpringBootApplication`但它可以添加到任何`@Configuration`类中。默认情况下，将从声明注释的类的包中进行扫描。如果要定义要扫描的特定包，可以按照以下示例所示进行操作：

```java
@SpringBootApplication
@ConfigurationPropertiesScan({ "com.example.app", "com.example.another" })
public class MyApplication {

}
```

当`@ConfigurationProperties`使用配置属性扫描或通过 注册 bean时`@EnableConfigurationProperties`，bean 有一个约定名称：`<prefix>-<fqn>`，其中`<prefix>`是`@ConfigurationProperties`注释中指定的环境键前缀，`<fqn>`是 bean 的完全限定名称。如果注释不提供任何前缀，则仅使用 bean 的完全限定名称。上面示例中的 bean 名称是`com.example.app-com.example.app.SomeProperties`.

注意：`@ConfigurationProperties`只处理环境，特别是不要从上下文中注入其他 bean。对于极端情况，可以使用 setter 注入或`*Aware`框架提供的任何接口（例如，`EnvironmentAware`如果您需要访问`Environment`）。如果您仍想使用构造函数注入其他 bean，则配置属性 bean 必须注释`@Component`并使用基于 JavaBean 的属性绑定。

#### 第三方配置

除了`@ConfigurationProperties`用于注释类之外，您还可以在公共`@Bean`方法上使用它。当您想要将属性绑定到您无法控制的第三方组件时，这样做会特别有用。要从`Environment`属性配置 bean，请添加`@ConfigurationProperties`到它的 bean 注册中，如以下示例所示：

```java
@Configuration(proxyBeanMethods = false)
public class ThirdPartyConfiguration {

    @Bean
    @ConfigurationProperties(prefix = "another")
    public AnotherComponent anotherComponent() {
        return new AnotherComponent();
    }

}
```

使用前缀定义的任何 JavaBean 属性都以类似于前面示例的方式`another`映射到该bean。`AnotherComponent``SomeProperties`

#### 宽松的规则

Spring Boot 使用一些宽松的规则将`Environment`属性绑定到bean，因此属性名称和 bean 属性名称`@ConfigurationProperties`之间不需要完全匹配。Environment`这有用的常见示例包括破折号分隔的环境属性（例如，`context-path`绑定到`contextPath`）和大写的环境属性（例如，`PORT``port）

```java
@ConfigurationProperties(prefix = "my.main-project.person")
public class MyPersonProperties {

    private String firstName;

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

}
```

通过前面的代码，可以使用以下属性名称：

| 属性                                | 描述                                                      |
| :---------------------------------- | :-------------------------------------------------------- |
| `my.main-project.person.first-name` | 推荐用于`.properties`和`.yml`文件。                       |
| `my.main-project.person.firstName`  | 标准的驼峰式大小写语法。                                  |
| `my.main-project.person.first_name` | 下划线符号，这是用于`.properties`和`.yml`文件的替代格式。 |
| `MY_MAINPROJECT_PERSON_FIRSTNAME`   | 大写格式，在使用系统环境变量时推荐使用。                  |

<span style="color: red">`prefix`注释 的值*必须*采用 kebab 大小写（小写并以 分隔`-`，例如`my.main-project.person`）。</span>

| 属性来源  | 单个写法                                                     | 列表写法                                                     |
| :-------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 属性文件  | 骆驼大小写、烤肉串大小写或下划线符号                         | `[ ]`使用或逗号分隔值的标准列表语法                          |
| YAML 文件 | 骆驼大小写、烤肉串大小写或下划线符号                         | 标准 YAML 列表语法或逗号分隔值                               |
| 环境变量  | 下划线作为分隔符的大写格式（请参阅[从环境变量绑定](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables)）。 | 下划线包围的数值（请参阅[从环境变量绑定](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables)） |
| 系统属性  | 骆驼大小写、烤肉串大小写或下划线符号                         | `[ ]`使用或逗号分隔值的标准列表语法                          |

绑定到`Map`属性时，您可能需要使用特殊的括号表示法，以便`key`保留原始值。如果键未被 包围`[]`，则任何非字母数字字符`-`或`.`将被删除。将以下属性绑定到 a `Map<String,String>` （对于 YAML 文件，括号需要用引号引起来才能正确解析键）：

```yaml
my:
  map:
    "[/key1]": "value1"
    "[/key2]": "value2"
    "/key3": "value3"
```

上面的属性将绑定到一个`Map`with `/key1`, `/key2`and`key3`作为地图中的键。斜线已被删除，`key3`因为它没有被方括号包围。绑定到标量值时，其中带有`.`的键不需要用`[]`. 标量值包括枚举和`java.lang`包中除`Object`. 绑定`a.b=c`到`Map<String, String>`将保留`.`键中的并返回一个包含条目的映射`{"a.b"="c"}`。对于任何其他类型，如果您`key`包含一个`.`. 例如，绑定`a.b=c`到`Map<String, Object>`将返回一个带有条目的映射，`{"a"={"b"="c"}}`而`[a.b]=c`将返回一个带有条目的映射`{"a.b"="c"}`。

大多数操作系统对可用于环境变量的名称施加了严格的规则。例如，Linux shell 变量只能包含字母（`a`to`z`或`A`to `Z`）、数字（`0`to `9`）或下划线字符（`_`）。按照惯例，Unix shell 变量的名称也将以大写形式显示。Spring Boot 宽松的绑定规则，就是为了尽可能兼容这些命名限制而设计的。要将规范形式的属性名称转换为环境变量名称，您可以遵循以下规则：

- 将点 ( `.`) 替换为下划线 ( `_`)。

- 删除任何破折号 ( `-`)。

- 转换为大写。

- 例如，配置属性`spring.main.log-startup-info`将是一个名为 的环境变量`SPRING_MAIN_LOGSTARTUPINFO`。

  绑定到对象列表时也可以使用环境变量。要绑定到 a `List`，元素编号应在变量名称中用下划线括起来。

  例如，配置属性`my.service[0].other`将使用名为 的环境变量`MY_SERVICE_0_OTHER`。

#### 合并复杂类型

当列表在多个位置配置时，覆盖通过替换整个列表来工作。假设一个`MyPojo`对象具有默认的`name`属性`description`。以下示例公开了`MyPojo`来自 的对象列表`MyProperties`：

```java
@ConfigurationProperties("my")
public class MyProperties {

    private final List<MyPojo> list = new ArrayList<>();

    public List<MyPojo> getList() {
        return this.list;
    }

}
```

考虑以下配置：	

```yaml
my:
  list:
  - name: "my name"
    description: "my description"
  - name: "another name"
    description: "another description"
---
spring:
  config:
    activate:
      on-profile: "dev"
my:
  list:
  - name: "my another name"
```

在前面的示例中，如果`dev`配置文件处于活动状态，则`MyProperties.list`包含*一个* `MyPojo`条目（名称为`my another name`，描述为`null`）。对于 YAML，逗号分隔列表和 YAML 列表都可用于完全覆盖列表的内容。

对于`Map`属性，您可以绑定从多个来源提取的属性值。但是，对于多个来源中的同一属性，将使用优先级最高的那个。以下示例公开了一个`Map<String, MyPojo>`from `MyProperties`：

```java
@ConfigurationProperties("my")
public class MyProperties {

    private final Map<String, MyPojo> map = new LinkedHashMap<>();

    public Map<String, MyPojo> getMap() {
        return this.map;
    }

}
```

考虑以下配置：

```yaml
my:
  map:
    key1:
      name: "my name 1"
      description: "my description 1"
---
spring:
  config:
    activate:
      on-profile: "dev"
my:
  map:
    key1:
      name: "dev name 1"
    key2:
      name: "dev name 2"
      description: "dev description 2"
```

如果`dev`配置文件未激活，则`MyProperties.map`包含一个带键`key1`的条目（名称为`my name 1`，描述为`my description 1`）。但是，如果`dev`配置文件已启用，则`map`包含两个条目，其中的键`key1`（名称`dev name 1`和描述为`my description 1`）和`key2`（名称`dev name 2`和描述为`dev description 2`）。

#### 属性转换

Spring Boot 尝试在绑定到`@ConfigurationProperties`bean 时将外部应用程序属性强制转换为正确的类型。如果您需要自定义类型转换，您可以提供一个`ConversionService`bean（带有一个名为 的 bean `conversionService`）或自定义属性编辑器（通过一个`CustomEditorConfigurer`bean）或自定义`Converters`（带有注释为 的 bean 定义`@ConfigurationPropertiesBinding`）。

##### 转换持续时间

Spring Boot 专门支持表达持续时间。如果公开`java.time.Duration`属性，则应用程序属性中的以下格式可用：

- 常规`long`表示（使用毫秒作为默认单位，除非`@DurationUnit`已指定 a）
- [使用](https://docs.oracle.com/javase/17/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-)的标准 ISO-8601 格式[`java.time.Duration`](https://docs.oracle.com/javase/17/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-)
- 一种更易读的格式，其中值和单位耦合（`10s`表示 10 秒）

```java
@ConfigurationProperties("my")
public class MyProperties {

    @DurationUnit(ChronoUnit.SECONDS)
    private Duration sessionTimeout = Duration.ofSeconds(30);

    private Duration readTimeout = Duration.ofMillis(1000);

    // getters / setters...

}
```

要指定 30 秒的会话超时`30`，`PT30S`和`30s`都是等效的。可以使用以下任何形式指定 500 毫秒的读取超时：`500`,`PT0.5S`和`500ms`。您还可以使用任何受支持的单位。这些都是：

- `ns`纳秒
- `us`微秒
- `ms`几毫秒
- `s`几秒钟
- `m`几分钟
- `h`用了几个小时
- `d`好几天

默认单位是毫秒，可以使用`@DurationUnit`上面示例中所示的方法覆盖。如果您更喜欢使用构造函数绑定，则可以公开相同的属性，如以下示例所示：

```java
@ConfigurationProperties("my")
public class MyProperties {

    // fields...

    public MyProperties(@DurationUnit(ChronoUnit.SECONDS) @DefaultValue("30s") Duration sessionTimeout,
            @DefaultValue("1000ms") Duration readTimeout) {
        this.sessionTimeout = sessionTimeout;
        this.readTimeout = readTimeout;
    }

    // getters...

}
```

##### 转换周期

除了持续时间之外，Spring Boot 还可以使用`java.time.Period`类型。应用程序属性中可以使用以下格式：

- 常规`int`表示（使用天作为默认单位，除非`@PeriodUnit`已指定 a）
- [使用](https://docs.oracle.com/javase/17/docs/api/java/time/Period.html#parse-java.lang.CharSequence-)的标准 ISO-8601 格式[`java.time.Period`](https://docs.oracle.com/javase/17/docs/api/java/time/Period.html#parse-java.lang.CharSequence-)
- 一种更简单的格式，其中值和单位对耦合（`1y3d`表示 1 年零 3 天）

简单格式支持以下单位：

- `y`多年
- `m`几个月
- `w`数周
- `d`好几天

该`java.time.Period`类型从不实际存储周数，它是表示“7 天”的快捷方式。

##### 转换数据大小

Spring Framework 有一个`DataSize`以字节为单位表示大小的值类型。如果公开`DataSize`属性，则应用程序属性中的以下格式可用：

- 常规`long`表示（使用字节作为默认单位，除非`@DataSizeUnit`已指定 a）
- 一种更易读的格式，其中值和单位耦合（`10MB`表示 10 兆字节）

```java
@ConfigurationProperties("my")
public class MyProperties {

    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize bufferSize = DataSize.ofMegabytes(2);

    private DataSize sizeThreshold = DataSize.ofBytes(512);

    // getters/setters...

}
```

指定缓冲区大小为 10 兆字节，`10`并且`10MB`是等效的。256 字节的大小阈值可以指定为`256`或`256B`。

您还可以使用任何受支持的单位。这些都是：

- `B`对于字节
- `KB`千字节
- `MB`兆字节
- `GB`千兆字节
- `TB`太字节

默认单位是字节，可以使用`@DataSizeUnit`上面示例中所示的方法覆盖。如果您更喜欢使用构造函数绑定，则可以公开相同的属性，如以下示例所示：

```java
@ConfigurationProperties("my")
public class MyProperties {

    // fields...

    public MyProperties(@DataSizeUnit(DataUnit.MEGABYTES) @DefaultValue("2MB") DataSize bufferSize,
            @DefaultValue("512B") DataSize sizeThreshold) {
        this.bufferSize = bufferSize;
        this.sizeThreshold = sizeThreshold;
    }

    // getters...

}
```

如果要升级`Long`属性，请确保定义单位（使用`@DataSizeUnit`）（如果它不是字节）。这样做提供了一个透明的升级路径，同时支持更丰富的格式。

#### @ConfigurationProperties 验证

`@ConfigurationProperties`每当使用 Spring 的注释对类进行注释时， Spring Boot 都会尝试验证类`@Validated`。`jakarta.validation`您可以直接在配置类上使用 JSR-303约束注释。为此，请确保您的类路径上有一个兼容的 JSR-303 实现，然后将约束注释添加到您的字段，如以下示例所示：

```java
@ConfigurationProperties("my.service")
@Validated
public class MyProperties {

    @NotNull
    private InetAddress remoteAddress;

    // getters/setters...

}
```

为确保始终为嵌套属性触发验证，即使未找到任何属性，关联的字段也必须用 注释`@Valid`。以下示例建立在前面的示例之上`MyProperties`：

```java
@ConfigurationProperties("my.service")
@Validated
public class MyProperties {

    @NotNull
    private InetAddress remoteAddress;

    @Valid
    private final Security security = new Security();

    // getters/setters...

    public static class Security {

        @NotEmpty
        private String username;

        // getters/setters...

    }

}
```

您还可以`Validator`通过创建一个名为`configurationPropertiesValidator`. `@Bean`应声明该方法`static`。配置属性验证器是在应用程序生命周期的早期创建的，将`@Bean`方法声明为静态可以创建 bean，而无需实例化`@Configuration`类。这样做可以避免早期实例化可能导致的任何问题。

#### @ConfigurationProperties 与@Value

`@Value`注解是一个核心容器特性，它不提供与类型安全配置属性相同的特性。下表总结了`@ConfigurationProperties`和支持的功能`@Value`：

| 特征       | `@ConfigurationProperties` | `@Value` |
| :--------- | :------------------------- | :------- |
| 宽松的绑定 | 是的                       | 有限     |
| 元数据支持 | 是的                       | 不       |
| `SpEL`评估 | 不                         | 是的     |

如果您确实想使用`@Value`，我们建议您使用规范形式（仅使用小写字母的 kebab-case）来引用属性名称。[这将允许 Spring Boot 使用与放松绑定](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) 时相同的逻辑`@ConfigurationProperties`。

例如，`@Value("${demo.item-price}")`将从文件以及系统环境中获取`demo.item-price`和`demo.itemPrice`形成表格。如果你改用了，就不会考虑了。`application.properties``DEMO_ITEMPRICE``@Value("${demo.itemPrice}")``demo.item-price``DEMO_ITEMPRICE`

如果您为自己的组件定义一组配置键，我们建议您将它们分组在一个 POJO 注释中`@ConfigurationProperties`。这样做将为您提供结构化的、类型安全的对象，您可以将其注入到您自己的 bean 中。

`SpEL`在解析这些文件和填充环境时，不会处理来自[应用程序属性文件](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files)的表达式 。但是，可以`SpEL`在`@Value`. 如果应用程序属性文件中的属性值是一个`SpEL`表达式，则在通过`@Value`.

## 配置文件环境隔离

Spring Profiles 提供了一种方法来隔离应用程序配置的各个部分，并使其仅在特定环境中可用。任何`@Component`, `@Configuration`or`@ConfigurationProperties`都可以`@Profile`在加载时标上限制，如下例所示：

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

``` java
@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {

    // ...

}
```

如果`@ConfigurationProperties`bean 是通过`@EnableConfigurationProperties`而不是自动扫描注册的，则`@Profile`需要在`@Configuration`具有注解的类上指定`@EnableConfigurationProperties`注解。`@ConfigurationProperties`在扫描的情况下，`@Profile`可以在`@ConfigurationProperties`类本身上指定。

可以使用`spring.profiles.active` `Environment`属性来指定哪些配置文件处于活动状态。您可以使用本章前面描述的任何方式指定属性：

``` java
spring:
  profiles:
    active: "dev,hsqldb"
```

````shell
--spring.profiles.active=dev,hsqldb`
````
spring.profiles.active`并且`spring.profiles.default`只能用于非配置文件特定的文档。这意味着它们不能包含在配置或由.`spring.config.activate.on-profile。例如第二个文件配置无效：

```yaml
# this document is valid
spring:
  profiles:
    active: "prod"
---
# this document is invalid
spring:
  config:
    activate:
      on-profile: "prod"
  profiles:
    active: "metrics"
```

### 添加活动配置文件

该`spring.profiles.active`属性遵循与其他属性相同的排序规则：最高者`PropertySource`获胜。这意味着您可以在其中指定活动配置文件，`application.properties`然后使用命令行开关**替换它们。**该`spring.profiles.include`属性可用于在属性激活的配置文件之上添加活动配置文件`spring.profiles.active`。入口`SpringApplication`点还有一个 Java API 用于设置额外的配置文件。请参阅[SpringApplication](https://docs.spring.io/spring-boot/docs/3.0.2/api/org/springframework/boot/SpringApplication.html)`setAdditionalProfiles()`中的方法。当运行具有以下属性的应用程序时，即使使用`--spring.profiles.active`开关运行，公共配置文件和本地配置文件也会被激活：

```yaml
spring:
  profiles:
    include:
      - "common"
      - "local"
```

###  配置文件组

有时，在应用程序中定义和使用的配置文件过于细化，使用起来很麻烦。例如，您可能拥有用于独立启用数据库和消息传递功能的配置文件`proddb`。`prodmq`为此，Spring Boot 允许您定义配置文件组。配置文件组允许您为相关的配置文件组定义逻辑名称。例如，可以创建一个`production`由我们的`proddb`和`prodmq`配置文件组成的组。

```yaml
spring:
  profiles:
    group:
      production:
      - "proddb"
      - "prodmq"
```

现在可以开始使用我们的应用程序`--spring.profiles.active=production`来一次激活`production`,`proddb`和`prodmq`配置文件。

### 以编程方式设置配置文件

`SpringApplication.setAdditionalProfiles(…)`您可以通过在应用程序运行之前调用以编程方式设置活动配置文件。也可以通过使用 Spring 的`ConfigurableEnvironment`接口来激活配置文件。

### 配置文件特定的配置文件

`application.properties`通过引用的(或`application.yml`) 和文件的特定配置文件变体`@ConfigurationProperties`被视为文件并加载。

## 日志记录

Spring Boot 将[Commons Logging](https://commons.apache.org/logging)用于所有内部日志记录，但将底层日志实现保持打开状态。[为Java Util Logging](https://docs.oracle.com/javase/17/docs/api/java/util/logging/package-summary.html)、[Log4j2](https://logging.apache.org/log4j/2.x/)和[Logback](https://logback.qos.ch/)提供了默认配置。在每种情况下，记录器都预先配置为使用控制台输出，同时还提供可选的文件输出。默认情况下，如果您使用“Starters”，Logback 用于日志记录。还包括适当的 Logback 路由，以确保使用 Java Util Logging、Commons Logging、Log4J 或 SLF4J 的依赖库都能正常工作。

### 日志格式

Spring Boot 的默认日志输出类似于以下示例：

```
2023-01-20T00:26:14.338Z INFO 19468 --- [main] osbdfsMyApplication：使用 PID 为 19468 的 Java 17.0.6 启动 MyApplication（/opt/apps/myapp.jar 由 myuser 在 /opt/apps/ 中启动）
2023 -01-20T00:26:14.352Z INFO 19468 --- [main] osbdfsMyApplication：未设置活动配置文件，回落到 1 个默认配置文件：“默认” 
2023-01-20T00:26:20.158Z INFO 19468 --- [ main] osbwembedded.tomcat.TomcatWebServer：Tomcat 初始化端口：8080 (http) 
2023-01-20T00:26:20.196Z INFO 19468 --- [main] o.apache.catalina.core.StandardService：启动服务[雄猫]
2023-01-20T00:26:20.197Z INFO 19468 --- [main] o.apache.catalina.core.StandardEngine：启动 Servlet 引擎：[Apache Tomcat/10.1.5] 
2023-01-20T00:26:20.416Z INFO 19468 --- [main] oaccC[Tomcat].[localhost].[/]：初始化 Spring 嵌入式 WebApplicationContext 
2023-01-20T00:26:20.419Z INFO 19468 --- [main] wscServletWebServerApplicationContext：Root WebApplicationContext：初始化完成在 5536 ms 
2023-01-20T00:26:21.337Z INFO 19468 --- [main] osbwembedded.tomcat.TomcatWebServer 中：Tomcat 在端口上启动：8080 (http) 上下文路径 ''
2023-01-20T00:26:21.351Z INFO 19468 --- [main] osbdfsMyApplication：在 8.52 秒内启动 MyApplication（进程运行时间为 9.752）
```

输出以下项目：

- 日期和时间：毫秒精度且易于排序。
- 日志级别：`ERROR`、`WARN`、`INFO`、`DEBUG`或`TRACE`。
- 进程标识。
- `---`用于区分实际日志消息开始的分隔符。
- 线程名称：括在方括号中（对于控制台输出可能会被截断）。
- 记录器名称：这通常是源类名称（通常缩写）。
- 日志消息。

Logback 没有`FATAL`级别。它映射到`ERROR`。

### 控制台输出

默认日志配置在写入消息时将消息回显到控制台。默认情况下，记录`ERROR`-level、`WARN`-level 和`INFO`-level 消息。`--debug`您还可以通过使用标志启动应用程序来启用“调试”模式。

```shell
$ java -jar myapp.jar --debug
```

当启用调试模式时，选择的核心记录器（嵌入式容器、Hibernate 和 Spring Boot）被配置为输出更多信息。启用调试模式不会*将*您的应用程序配置为记录所有`DEBUG`级别的消息。`--trace`或者，您可以通过使用标志（或`trace=true`在您的）中启动您的应用程序来启用“跟踪”模式`application.properties`。这样做可以为选定的核心记录器（嵌入式容器、Hibernate 模式生成和整个 Spring 产品组合）启用跟踪日志记录。

如果您的终端支持 ANSI，则使用颜色输出来提高可读性。您可以设置`spring.output.ansi.enabled`为[受支持的值](https://docs.spring.io/spring-boot/docs/3.0.2/api/org/springframework/boot/ansi/AnsiOutput.Enabled.html)以覆盖自动检测。颜色编码是使用`%clr`转换字配置的。在其最简单的形式中，转换器根据日志级别为输出着色，如以下示例所示：

```
%clr(%5p)
```

下表描述了日志级别到颜色的映射：

| 等级    | 颜色   |
| :------ | :----- |
| `FATAL` | 红色的 |
| `ERROR` | 红色的 |
| `WARN`  | 黄色的 |
| `INFO`  | 绿色的 |
| `DEBUG` | 绿色的 |
| `TRACE` | 绿色的 |

或者，您可以通过将其作为转换选项提供来指定应使用的颜色或样式。例如，要使文本变为黄色，请使用以下设置：

```
%clr(%d{yyyy-MM-dd'T'HH:mm:ss.SSSXXX}){yellow}
```

支持以下颜色和样式：

- `blue`
- `cyan`
- `faint`
- `green`
- `magenta`
- `red`
- `yellow`

### 文件输出

默认情况下，Spring Boot 只记录到控制台，不写入日志文件。如果除了控制台输出之外还想写入日志文件，则需要设置一个`logging.file.name`或`logging.file.path`属性（例如，在您的`application.properties`.下表显示了如何`logging.*`一起使用这些属性：

| `logging.file.name` | `logging.file.path` | 例子       | 描述                                                         |
| :------------------ | :------------------ | :--------- | :----------------------------------------------------------- |
| *（没有任何）*      | *（没有任何）*      |            | 仅控制台日志记录。                                           |
| 具体文件            | *（没有任何）*      | `my.log`   | 写入指定的日志文件。名称可以是确切位置或相对于当前目录。     |
| *（没有任何）*      | 具体目录            | `/var/log` | 写入`spring.log`指定目录。名称可以是确切位置或相对于当前目录。 |

日志文件在达到 10 MB 时会轮换，并且与控制台输出一样，默认情况下会记录`ERROR`-level、`WARN`-level 和`INFO`-level 消息。日志记录属性独立于实际的日志记录基础设施。因此，特定的配置键（例如`logback.configurationFile`Logback）不由 spring Boot 管理。

### 文件轮换

`application.properties`如果您使用的是 Logback，则可以使用您的或`application.yaml`文件微调日志轮换设置。对于所有其他日志系统，您将需要自己直接配置轮换设置（例如，如果您使用 Log4j2，那么您可以添加一个`log4j2.xml`或`log4j2-spring.xml`文件）。支持以下旋转策略属性：

| 名称                                                   | 描述                                         |
| :----------------------------------------------------- | :------------------------------------------- |
| `logging.logback.rollingpolicy.file-name-pattern`      | 用于创建日志存档的文件名模式。               |
| `logging.logback.rollingpolicy.clean-history-on-start` | 应用程序启动时是否应进行日志归档清理。       |
| `logging.logback.rollingpolicy.max-file-size`          | 归档前日志文件的最大大小。                   |
| `logging.logback.rollingpolicy.total-size-cap`         | 日志存档在被删除之前可以占用的最大大小。     |
| `logging.logback.rollingpolicy.max-history`            | 要保留的归档日志文件的最大数量（默认为 7）。 |

### 日志级别

所有支持的日志记录系统都可以在 Spring 中设置记录器级别`Environment`（例如，在 中`application.properties`），方法是使用`logging.level.<logger-name>=<level>`TRACE `level`、DEBUG、INFO、WARN、ERROR、FATAL 或 OFF 之一。记录器`root`可以通过使用来配置`logging.level.root`。以下示例显示了潜在的日志记录设置`application.properties`：

```properties
logging:
  level:
    root: "warn"
    org.springframework.web: "debug"
    org.hibernate: "error"
```

也可以使用环境变量设置日志级别。例如，`LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG`将设置`org.springframework.web`为`DEBUG`。

### 日志组

将相关的记录器分组在一起通常很有用，这样它们就可以同时配置。例如，您可能经常更改*所有*与 Tomcat 相关的记录器的日志记录级别，但您不能轻易记住顶级包。

为了解决这个问题，Spring Boot 允许您在 Spring 中定义日志记录组`Environment`。例如，您可以通过将“tomcat”组添加到您的 来定义它`application.properties`：

```yaml
logging:
  group:
    tomcat: "org.apache.catalina,org.apache.coyote,org.apache.tomcat"
```

定义后，您可以使用一行更改组中所有记录器的级别：

```yaml
logging:
  level:
    tomcat: "trace"
```

Spring Boot 包括以下可以开箱即用的预定义日志记录组：

| 名称   | 包名                                                         |
| :----- | :----------------------------------------------------------- |
| 网络   | `org.springframework.core.codec`, `org.springframework.http`, `org.springframework.web`, `org.springframework.boot.actuate.endpoint.web`,`org.springframework.boot.web.servlet.ServletContextInitializerBeans` |
| 数据库 | `org.springframework.jdbc.core`, `org.hibernate.SQL`,`org.jooq.tools.LoggerListener` |

### 使用日志关闭挂钩

为了在您的应用程序终止时释放日志记录资源，提供了一个关闭挂钩，该挂钩将在 JVM 退出时触发日志系统清理。除非您的应用程序部署为 war 文件，否则此关闭挂钩会自动注册。如果您的应用程序具有复杂的上下文层次结构，则关闭挂钩可能无法满足您的需求。如果没有，请禁用关闭挂钩并调查底层日志系统直接提供的选项。例如，Logback 提供[上下文选择器](https://logback.qos.ch/manual/loggingSeparation.html)，允许每个 Logger 在其自己的上下文中创建。您可以使用该`logging.register-shutdown-hook`属性来禁用关闭挂钩。将其设置为`false`将禁用注册。您可以在您的`application.properties`或`application.yaml`文件中设置属性：

```yaml
logging:
  register-shutdown-hook: false
```

### 自定义日志配置

可以通过在类路径中包含适当的库来激活各种日志记录系统，并且可以通过在类路径的根目录或以下 Spring`Environment`属性指定的位置提供合适的配置文件来进一步自定义：`logging.config`。`org.springframework.boot.logging.LoggingSystem`您可以通过使用系统属性强制 Spring Boot 使用特定的日志记录系统。该值应该是实现的完全限定类名`LoggingSystem`。您还可以使用 . 值完全禁用 Spring Boot 的日志记录配置`none`。

<span style="color: red">**由于日志记录是在创建之前** 初始化的`ApplicationContext`，因此无法从`@PropertySources`Spring`@Configuration`文件中控制日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。</span>

根据您的日志系统，将加载以下文件：

| 记录系统                  | 自定义                                                       |
| :------------------------ | :----------------------------------------------------------- |
| 登录                      | `logback-spring.xml`、`logback-spring.groovy`、`logback.xml`或`logback.groovy` |
| Log4j2                    | `log4j2-spring.xml`或者`log4j2.xml`                          |
| JDK（Java Util 日志记录） | `logging.properties`                                         |

为了自定义，一些其他属性从 Spring 转移`Environment`到系统属性，如下表所述：

| spring环境                          | 系统属性                        | 描述                                                         |
| :---------------------------------- | :------------------------------ | :----------------------------------------------------------- |
| `logging.exception-conversion-word` | `LOG_EXCEPTION_CONVERSION_WORD` | 记录异常时使用的转换词。                                     |
| `logging.file.name`                 | `LOG_FILE`                      | 如果已定义，它将用于默认日志配置。                           |
| `logging.file.path`                 | `LOG_PATH`                      | 如果已定义，它将用于默认日志配置。                           |
| `logging.pattern.console`           | `CONSOLE_LOG_PATTERN`           | 在控制台 (stdout) 上使用的日志模式。                         |
| `logging.pattern.dateformat`        | `LOG_DATEFORMAT_PATTERN`        | 日志日期格式的附加程序模式。                                 |
| `logging.charset.console`           | `CONSOLE_LOG_CHARSET`           | 用于控制台日志记录的字符集。                                 |
| `logging.pattern.file`              | `FILE_LOG_PATTERN`              | 在文件中使用的日志模式（如果`LOG_FILE`启用）。               |
| `logging.charset.file`              | `FILE_LOG_CHARSET`              | 用于文件日志记录的字符集（如果`LOG_FILE`启用）。             |
| `logging.pattern.level`             | `LOG_LEVEL_PATTERN`             | 呈现日志级别时使用的格式（默认值`%5p`）。                    |
| `PID`                               | `PID`                           | 当前进程 ID（如果可能并且在尚未定义为操作系统环境变量时发现）。 |

使用 Logback，还会传输以下属性：

| spring环境                                             | 系统属性                                       | 描述                                                         |
| :----------------------------------------------------- | :--------------------------------------------- | :----------------------------------------------------------- |
| `logging.logback.rollingpolicy.file-name-pattern`      | `LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN`      | 滚动日志文件名的模式（默认`${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz`）。 |
| `logging.logback.rollingpolicy.clean-history-on-start` | `LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START` | 是否在启动时清理归档日志文件。                               |
| `logging.logback.rollingpolicy.max-file-size`          | `LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE`          | 最大日志文件大小。                                           |
| `logging.logback.rollingpolicy.total-size-cap`         | `LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP`         | 要保留的日志备份的总大小。                                   |
| `logging.logback.rollingpolicy.max-history`            | `LOGBACK_ROLLINGPOLICY_MAX_HISTORY`            | 要保留的归档日志文件的最大数量。                             |

> 如果你想在日志属性中使用占位符，你应该使用[Spring Boot 的语法](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.property-placeholders)而不是底层框架的语法。值得注意的是，如果你使用 Logback，你应该使用`:`作为属性名称和它的默认值之间的分隔符，而不是使用`:-`。

> `LOG_LEVEL_PATTERN`您可以通过仅覆盖（或`logging.pattern.level`使用 Logback）将 MDC 和其他临时内容添加到日志行。例如，如果您使用`logging.pattern.level=user:%X{user} %5p`，则默认日志格式包含“用户”的 MDC 条目（如果存在），如以下示例所示。
>
> ```
> 2019-08-30 12:30:04.031 user:someone INFO 22174 --- [nio-8080-exec-0] demo.Controller
> 处理经过身份验证的请求
> ```

### 登录扩展

Spring Boot 包含许多对 Logback 的扩展，可以帮助进行高级配置。您可以在`logback-spring.xml`配置文件中使用这些扩展。因为标准`logback.xml`配置文件加载的太早，你不能在里面使用扩展。您需要使用`logback-spring.xml`或定义`logging.config`属性。

这些扩展不能与 Logback 的[配置扫描](https://logback.qos.ch/manual/configuration.html#autoScan)一起使用。如果您尝试这样做，对配置文件进行更改会导致记录类似于以下内容之一的错误：

```
ch.qos.logback.core.joran.spi.Interpreter@4中的错误：71 - [springProperty] 没有适用的操作，当前 ElementPath 是 [[configuration][springProperty]] ch.qos.logback.core.joran
中的错误.spi.Interpreter@4 :71 - [springProfile] 没有适用的操作，当前 ElementPath 是 [[configuration][springProfile]]
```

`<springProfile>`标记允许您根据活动的 Spring 配置文件选择性地包含或排除配置部分。元素内的任何位置都支持配置文件部分`<configuration>`。使用该`name`属性指定哪个配置文件接受配置。标记可以包含配置`<springProfile>`文件名称（例如`staging`）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如`production & (eu-central | eu-west)`。

```xml
<springProfile name="staging">
    <!-- configuration to be enabled when the "staging" profile is active -->
</springProfile>

<springProfile name="dev | staging">
    <!-- configuration to be enabled when the "dev" or "staging" profiles are active -->
</springProfile>

<springProfile name="!production">
    <!-- configuration to be enabled when the "production" profile is not active -->
</springProfile>
```

`<springProperty>`标记允许您公开 Spring`Environment`的属性以在 Logback 中使用。`application.properties`如果您想在 Logback 配置中访问文件中的值，这样做会很有用。该标签的工作方式与 Logback 的标准`<property>`标签类似。但是，不是直接指定 ，而是指定`value`属性`source`的 （来自`Environment`）。如果您需要将属性存储在`local`作用域之外的其他地方，您可以使用`scope`属性。如果您需要一个回退值（以防该属性未在 中设置`Environment`），可以使用该`defaultValue`属性。

```
<springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
        defaultValue="localhost"/>
<appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender">
    <remoteHost>${fluentHost}</remoteHost>
    ...
</appender>
```

### Log4j2 扩展

Spring Boot 包含许多对 Log4j2 的扩展，可以帮助进行高级配置。`log4j2-spring.xml`可以在任何配置文件中使用这些扩展。因为标准`log4j2.xml`配置文件加载的太早，你不能在里面使用扩展。您需要使用`log4j2-spring.xml`或定义`logging.config`属性。这些扩展取代了Log4J 提供的Spring Boot 支持。应该确保不要`org.apache.logging.log4j:log4j-spring-boot`在构建中包含该模块。

## 国际化

Spring Boot 支持本地化消息，因此您的应用程序可以迎合不同语言偏好的用户。默认情况下，Spring Boot`messages`在类路径的根目录中查找资源包是否存在。当已配置资源包的默认属性文件可用时（`messages.properties`默认情况下），自动配置适用。如果您的资源包仅包含特定于语言的属性文件，则您需要添加默认值。如果找不到与任何配置的基本名称匹配的属性文件，则不会有自动配置的`MessageSource`.以下示例所示：

```yaml
spring:
  messages:
    basename: "messages,config.i18n.messages"
    fallback-to-system-locale: false
```

## JSON

Spring Boot 提供与三个 JSON 映射库的集成：

- Gson
- Jackson
- JSON-B

Jackson是首选的默认库。

### Jackson

提供了 Jackson 的自动配置，Jackson 是`spring-boot-starter-json`. 当 Jackson 在类路径上时，`ObjectMapper`会自动配置一个 bean。提供了几个配置属性来自[定义`ObjectMapper`](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.spring-mvc.customize-jackson-objectmapper).

如果您使用 Jackson 序列化和反序列化 JSON 数据，您可能想要编写自己的`JsonSerializer`和`JsonDeserializer`类。自定义序列化器通常[通过模块向 Jackson 注册](https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers)，但 Spring Boot 提供了另一种`@JsonComponent`注解，可以更轻松地直接注册 Spring Beans。您可以直接在或实现上使用`@JsonComponent`注解。您还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：`JsonSerializer``JsonDeserializer``KeyDeserializer`

```java
@JsonComponent
public class MyJsonComponent {

    public static class Serializer extends JsonSerializer<MyObject> {

        @Override
        public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException {
            jgen.writeStartObject();
            jgen.writeStringField("name", value.getName());
            jgen.writeNumberField("age", value.getAge());
            jgen.writeEndObject();
        }

    }

    public static class Deserializer extends JsonDeserializer<MyObject> {

        @Override
        public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException {
            ObjectCodec codec = jsonParser.getCodec();
            JsonNode tree = codec.readTree(jsonParser);
            String name = tree.get("name").textValue();
            int age = tree.get("age").intValue();
            return new MyObject(name, age);
        }

    }
}
```

中的所有`@JsonComponent`bean 都会`ApplicationContext`自动向 Jackson 注册。因为`@JsonComponent`是元注释的`@Component`，所以适用通常的组件扫描规则。	Spring Boot 还提供[`JsonObjectSerializer`](https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java)和[`JsonObjectDeserializer`](https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java)基类，这些类在序列化对象时提供标准 Jackson 版本的有用替代方案。

Jackson 支持 mixin，可用于将附加注释混合到已在目标类上声明的注释中。Spring Boot 的 Jackson 自动配置将扫描您的应用程序包以查找带有注释的类，`@JsonMixin`并将它们注册到自动配置的`ObjectMapper`. 注册由 Spring Boot 执行`JsonMixinModule`。

### Gson

提供了 Gson 的自动配置。当 Gson 在类路径上时，`Gson`会自动配置一个 bean。提供了几个`spring.gson.*`配置属性用于自定义配置。要获得更多控制，`GsonBuilderCustomizer`可以使用一个或多个 bean。

### JSON-B

提供了 JSON-B 的自动配置。当 JSON-B API 和实现在类路径上时，`Jsonb`将自动配置一个 bean。首选的 JSON-B 实现是 Eclipse Yasson，它提供了依赖管理。

## 任务执行与调度

在上下文中没有`Executor`bean 的情况下，Spring Boot 会自动配置一个`ThreadPoolTaskExecutor`合理的默认值，这些默认值可以自动关联到异步任务执行 ( `@EnableAsync`) 和 Spring MVC 异步请求处理。

> 如果您在上下文中定义了自定义`Executor`项，常规任务执行（即`@EnableAsync`）将透明地使用它，但不会配置 Spring MVC 支持，因为它需要一个`AsyncTaskExecutor`实现（名为`applicationTaskExecutor`）。根据您的目标安排，您可以将您的更改`Executor`为 a`ThreadPoolTaskExecutor`或同时定义 a`ThreadPoolTaskExecutor`和 an来`AsyncConfigurer`包装您的自定义`Executor`.
>
> 自动配置`TaskExecutorBuilder`允许您轻松创建实例来重现默认情况下自动配置的功能。

线程池使用8个核心线程，可以根据负载增长和收缩。可以使用命名空间对这些默认设置进行微调`spring.task.execution`，如以下示例所示：

```yaml
spring:
  task:
    execution:
      pool:
        max-size: 16
        queue-capacity: 100
        keep-alive: "10s"
```

这会将线程池更改为使用有界队列，以便当队列已满（100 个任务）时，线程池增加到最多 16 个线程。当线程空闲 10 秒（而不是默认情况下的 60 秒）时，线程会被回收，因此池的收缩更为激进。

如果`ThreadPoolTaskScheduler`需要关联到计划任务执行（`@EnableScheduling`例如使用），也可以自动配置。线程池默认使用一个线程，其设置可以使用命名空间进行微调`spring.task.scheduling`，如下例所示：

```yaml
spring:
  task:
    scheduling:
      thread-name-prefix: "scheduling-"
      pool:
        size: 2
```

如果需要创建自定义执行程序或调度程序，`TaskExecutorBuilder`bean 和bean都可以在上下文中使用。`TaskSchedulerBuilder`

## 测试

Spring Boot 提供了许多实用程序和注释来帮助测试您的应用程序。测试支持由两个模块提供：`spring-boot-test`包含核心项目，并`spring-boot-test-autoconfigure`支持测试的自动配置。大多数开发人员使用`spring-boot-starter-test`“Starter”，它导入 Spring Boot 测试模块以及 JUnit Jupiter、AssertJ、Hamcrest 和许多其他有用的库。

> 如果您有使用 JUnit 4 的测试，则可以使用 JUnit 5 的老式引擎来运行它们。要使用 vintage 引擎，请添加对 的依赖项`junit-vintage-engine`，如以下示例所示：
> 
```xml
<dependency>
    <groupId>org.junit.vintage</groupId>
    <artifactId>junit-vintage-engine</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.hamcrest</groupId>
            <artifactId>hamcrest-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```
 `spring-boot-starter-test`（在 中`test` `scope`）包含以下提供的库：

- [JUnit 5](https://junit.org/junit5/)：单元测试 Java 应用程序的实际标准。
- [Spring Test](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/testing.html#integration-testing) & Spring Boot Test：对 Spring Boot 应用程序的实用程序和集成测试支持。
- [AssertJ](https://assertj.github.io/doc/)：一个流畅的断言库。
- [Hamcrest](https://github.com/hamcrest/JavaHamcrest)：匹配器对象库（也称为约束或谓词）。
- [Mockito](https://site.mockito.org/)：一个 Java 模拟框架。
- [JSONassert](https://github.com/skyscreamer/JSONassert)：JSON 的断言库。
- [JsonPath](https://github.com/jayway/JsonPath)：JSON 的 XPath。

## 创建自己的自动配置

自动配置可以与提供自动配置代码以及您将使用它的典型库的“启动器”相关联。

### 自动配置的 Bean

实现自动配置的类用`@AutoConfiguration`. 这个注解本身是用元注解的`@Configuration`，使自动配置成为标准`@Configuration`类。附加`@Conditional`注释用于限制何时应应用自动配置。通常，自动配置类使用`@ConditionalOnClass`和`@ConditionalOnMissingBean`注解。这确保自动配置仅在找到相关类且您尚未声明自己的`@Configuration`.

### 定位自动配置

pring Boot 检查已发布的 jar中是否存在文件。该文件应列出您的配置类，每行一个类名，如以下示例所示：

```properties
com.mycorp.libx.autoconfigure.LibXAutoConfiguration 
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration
```

> 必须*仅*通过在导入文件中命名来加载自动配置。确保它们是在特定的包空间中定义的，并且它们永远不是组件扫描的目标。此外，自动配置类不应启用组件扫描来查找其他组件。`@Import`应改用 特定注释。

如果您的配置需要按特定顺序应用，您可以在注释或专用和注释上使用`before`、`beforeName`和属性。例如，如果您提供特定于 Web 的配置，则您的类可能需要在.`after``afterName`[`@AutoConfiguration`](https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfiguration.java)[`@AutoConfigureBefore`](https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java)[`@AutoConfigureAfter`](https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java)`WebMvcAutoConfiguration`。

如果你想订购某些相互之间不应该有任何直接知识的自动配置，你也可以使用`@AutoConfigureOrder`. 该注释与常规注释具有相同的语义，`@Order`但为自动配置类提供了专用顺序。

与标准`@Configuration`类一样，应用自动配置类的顺序只会影响定义它们的 bean 的顺序。随后创建这些 bean 的顺序不受影响，并由每个 bean 的依赖关系和任何`@DependsOn`关系决定。

### 条件注解

您几乎总是希望`@Conditional`在您的自动配置类中包含一个或多个注释。注释是一个常见的`@ConditionalOnMissingBean`示例，用于允许开发人员在对您的默认设置不满意时覆盖自动配置。

Spring Boot 包含许多注释，您可以通过注释类或单个方法`@Conditional`在自己的代码中重用这些注释。这些注释包括：

- Class Conditions
- Bean Conditions
- Property Conditions
- Resource Conditions
- Web Application Conditions
- SpEL Expression Conditions

#### Class Conditions

`@ConditionalOnClass`和`@ConditionalOnMissingClass`注释允许根据`@Configuration`特定类的存在或不存在来包含类。由于注释元数据是使用[ASM](https://asm.ow2.io/)解析的，因此您可以使用该`value`属性来引用真实的类，即使该类实际上可能不会出现在正在运行的应用程序类路径中。`name`如果您更喜欢使用值来指定类名，也可以使用该属性`String`。

这种机制不适用于`@Bean`通常返回类型是条件目标的方法：在方法的条件应用之前，JVM 将加载类和可能处理的方法引用，如果类不是展示。@Configuration`为了处理这种情况，可以使用一个单独的类来隔离这种情况，如以下示例所示：

```java
@AutoConfiguration
// Some conditions ...
public class MyAutoConfiguration {

    // Auto-configured beans ...

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(SomeService.class)
    public static class SomeServiceConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public SomeService someService() {
            return new SomeService();
        }

    }

}
```

#### Bean Conditions

`@ConditionalOnBean`和注释允许根据`@ConditionalOnMissingBean`特定 bean 的存在或不存在来包含 bean。您可以使用该`value`属性按类型`name`指定 beans 或按名称指定 beans。该`search`属性允许您限制`ApplicationContext`在搜索 bean 时应考虑的层次结构。

当放置在`@Bean`方法上时，目标类型默认为方法的返回类型，如以下示例所示：

``` java
@AutoConfiguration
public class MyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public SomeService someService() {
        return new SomeService();
    }

}
```

如果 .bean 中尚未包含`someService`任何类型的 bean，则将创建该 bean 。`SomeService``ApplicationContext`

> 您需要非常注意添加 bean 定义的顺序，因为这些条件是根据目前已处理的内容进行评估的。出于这个原因，我们建议在自动配置类上只使用`@ConditionalOnBean`和`@ConditionalOnMissingBean`注释（因为这些可以保证在添加任何用户定义的 bean 定义后加载）。
>
> @ConditionalOnBean`并且`@ConditionalOnMissingBean`不要阻止`@Configuration`创建类。在类级别使用这些条件与使用注释标记每个包含的方法之间的唯一区别是，如果条件不匹配 `@Bean`，前者会阻止将类注册为 bean。`@Configuration

#### Property Conditions

`@ConditionalOnProperty`注释允许基于 Spring Environment 属性包含配置。使用`prefix`和`name`属性指定应检查的属性。`false`默认情况下，匹配任何存在且不等于的属性。还可以使用`havingValue`和`matchIfMissing`属性创建更高级的检查。

#### Resource Conditions

仅当存在特定资源时，`@ConditionalOnResource`注释才允许包含配置。可以使用常用的 Spring 约定来指定资源，如以下示例所示`file:/home/user/test.dat`：

#### Web Application Conditions

`@ConditionalOnWebApplication`和注释根据`@ConditionalOnNotWebApplication`应用程序是否为“Web 应用程序”来包含配置。基于 servlet 的 Web 应用程序是任何使用 Spring `WebApplicationContext`、定义`session`范围或具有`ConfigurableWebEnvironment`. 反应式 Web 应用程序是任何`ReactiveWebApplicationContext`使用`ConfigurableReactiveWebEnvironment`.

注释允许包含配置，`@ConditionalOnWarDeployment`具体取决于应用程序是否是部署到容器的传统 WAR 应用程序。此条件与使用嵌入式服务器运行的应用程序不匹配。

#### SpEL Expression Conditions

注释允许根据[SpEL 表达式](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/core.html#expressions)`@ConditionalOnExpression`的结果包含配置。

> 在表达式中引用一个 bean 将导致该 bean 在上下文刷新处理中很早就被初始化。因此，bean 将不符合后处理（例如配置属性绑定）的条件，并且其状态可能不完整。

# 网络

## Servlet Web 应用程序

Spring Boot 非常适合 Web 应用程序开发。您可以使用嵌入式 Tomcat、Jetty、Undertow 或 Netty 创建独立的 HTTP 服务器。

### Spring Web MVC 框架

Spring Web MVC 框架（通常称为“Spring MVC”）是一个丰富的“模型视图控制器”Web 框架。Spring MVC 允许您创建特殊bean`@Controller`或`@RestController`bean 来处理传入的 HTTP 请求。控制器中的方法通过使用`@RequestMapping`注释映射到 HTTP。

```java
@RestController
@RequestMapping("/users")
public class MyRestController {

    private final UserRepository userRepository;

    private final CustomerRepository customerRepository;

    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{userId}")
    public User getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId).get();
    }

    @GetMapping("/{userId}/customers")
    public List<Customer> getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();
    }

    @DeleteMapping("/{userId}")
    public void deleteUser(@PathVariable Long userId) {
        this.userRepository.deleteById(userId);
    }

}
```

功能变体“WebMvc.fn”将路由配置与请求的实际处理分开，如下例所示：

```java
@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {

    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);

    @Bean
    public RouterFunction<ServerResponse> routerFunction(MyUserHandler userHandler) {
        return route()
                .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
                .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
                .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
                .build();
    }

}

@Component
public class MyUserHandler {

    public ServerResponse getUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse getUserCustomers(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse deleteUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

}
```

#### 自动配置

Spring Boot 为 Spring MVC 提供自动配置，适用于大多数应用程序。

自动配置在 Spring 的默认设置之上添加了以下功能：

- 夹杂`ContentNegotiatingViewResolver`和`BeanNameViewResolver` beans。
- 支持提供静态资源，包括对 WebJars 的支持。
- `Converter`、`GenericConverter`和`Formatter`bean的自动注册。
- 支持`HttpMessageConverters`。
- 自动注册`MessageCodesResolver`。
- 静态`index.html`支持。
- 自动使用`ConfigurableWebBindingInitializer`bean。

如果保留那些 Spring Boot MVC 定制并进行更多[MVC 定制](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/web.html#mvc)（拦截器、格式化程序、视图控制器和其他功能），您可以添加自己`@Configuration`的类型类，`WebMvcConfigurer`但**不** `@EnableWebMvc`添加。

如果提供、 或的自定义实例`RequestMappingHandlerMapping`，并且仍然保留 Spring Boot MVC 自定义，您可以声明一个类型的 bean并使用它来提供这些组件的自定义实例。`RequestMappingHandlerAdapter``ExceptionHandlerExceptionResolver``WebMvcRegistrations`。

如果完全控制 Spring MVC，你可以添加你自己的`@Configuration`注释`@EnableWebMvc`，或者添加你自己的`@Configuration`注释，`DelegatingWebMvcConfiguration`如`@EnableWebMvc`。

> Spring MVC 使用一种不同于`ConversionService`用于从您的`application.properties`或`application.yaml`文件转换值的方法。这意味着`Period`, `Duration`and`DataSize`转换器不可用， @DurationUnit`and`@DataSizeUnit`注释将被忽略。
>
> 如果你想自定义`ConversionService`Spring MVC 使用的方法，你可以提供一个`WebMvcConfigurer`带有`addFormatters`方法的 bean。从这个方法中，您可以注册任何您喜欢的转换器，或者您可以委托给`ApplicationConversionService`.

#### HttpMessageConverters

Spring MVC 使用`HttpMessageConverter`接口来转换 HTTP 请求和响应。开箱即用的合理默认值。例如，对象可以自动转换为 JSON（通过使用 Jackson 库）或 XML（通过使用 Jackson XML 扩展，如果可用，或者如果 Jackson XML 扩展不可用，则使用 JAXB）。默认情况下，字符串以`UTF-8`.如果需要添加或自定义转换器，可以使用 Spring Boot 的`HttpMessageConverters`类，如以下清单所示：

```java
@Configuration(proxyBeanMethods = false)
public class MyHttpMessageConvertersConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter<?> additional = new AdditionalHttpMessageConverter();
        HttpMessageConverter<?> another = new AnotherHttpMessageConverter();
        return new HttpMessageConverters(additional, another);
    }

}
```

`HttpMessageConverter`上下文中存在的任何bean 都会添加到转换器列表中。您也可以以相同的方式覆盖默认转换器。HttpMessageConverter<T> 接口定义的方法：

- Boolean canRead(Class<?> clazz, MediaType mediaType)：指定转换器可以读取的对象类型，即转换器是否可将请求信息转换为 clazz 类型的对象，同时指定支持 MIME 类型（text/html; application/json 等）
-  Boolean canWriter(Class<?> clazz, MediaType mediaType)：指定转换器是否可将 clazz 类型的对象写到响应流中，响应流支持的媒体类型在 MediaType 中定义；
-  List<MediaType> getSupportMediaTypes()：该转化器支持的媒体类型；
-  T read(Class<? extends T> clazz, **HttpInputMessage** inputMessage )：将请求信息转换为 T 类型的对象；
- void write(T t, MediaType contentType, **HttpOutputMessage** outputMessage)：将 T 类型的对象写到响应流中，同时指定相应的媒体类型为 contentType。  

#### 消息代码解析器

Spring MVC 有一个生成错误代码的策略，用于从绑定错误中呈现错误消息：`MessageCodesResolver`。如果您设置`spring.mvc.message-codes-resolver-format`属性`PREFIX_ERROR_CODE`or `POSTFIX_ERROR_CODE`，Spring Boot 会为您创建一个错误代码。

#### 静态内容

默认情况下，Spring Boot 从类路径中名为`/static`(or `/public`or ) 的目录`/resources`或. 它使用来自 Spring MVC 的方法，因此您可以通过添加自己的方法并覆盖该方法来修改该行为。`/META-INF/resources``ServletContext``ResourceHttpRequestHandler``WebMvcConfigurer``addResourceHandlers`。在独立的 Web 应用程序中，容器中的默认 servlet 未启用。可以使用该`server.servlet.register-default-servlet`属性启用它。

默认情况下，资源映射到`/**`，但您可以使用`spring.mvc.static-path-pattern`属性对其进行调整。例如，将所有资源重新定位到`/resources/**`可以实现如下：

```properties
spring.mvc.static-path-pattern=/resources/**
```

您还可以使用该`spring.web.resources.static-locations`属性自定义静态资源位置（用目录位置列表替换默认值）。根 servlet 上下文路径`"/"`也会自动添加为一个位置。默认情况下，如果资源以`/webjars/**`Webjars 格式打包，则路径为 的任何资源都由 jar 文件提供。可以使用`spring.mvc.webjars-path-pattern`属性自定义路径。

要使用缓存清除，以下配置为所有静态资源配置缓存清除解决方案，有效地在 URL 中添加内容哈希，例如`<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`：

```properties
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
```

当使用例如 JavaScript 模块加载器动态加载资源时，重命名文件不是一个选项。这就是为什么其他策略也受到支持并可以组合的原因。“固定”策略在不更改文件名的情况下在 URL 中添加静态版本字符串，如以下示例所示：

```properties
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
spring.web.resources.chain.strategy.fixed.enabled=true
spring.web.resources.chain.strategy.fixed.paths=/js/lib/
spring.web.resources.chain.strategy.fixed.version=v12
```

使用此配置，位于下方的 JavaScript 模块`"/js/lib/"`使用固定的版本控制策略 ( `"/v12/js/lib/mymodule.js"`)，而其他资源仍使用内容一 ( `<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`)。

#### 路径匹配和内容协商

Spring MVC 可以通过查看请求路径并将其与应用程序中定义的映射（例如，`@GetMapping`控制器方法上的注释）相匹配，将传入的 HTTP 请求映射到处理程序。Spring Boot 默认选择禁用后缀模式匹配，这意味着像这样的请求`"GET /projects/spring-boot.json"`不会匹配到`@GetMapping("/projects/spring-boot")`映射。这被认为是Spring MVC 应用程序的最佳实践。此功能过去主要用于未发送正确“接受”请求标头的 HTTP 客户端；我们需要确保向客户端发送正确的内容类型。

还有其他方法可以处理不能始终如一地发送正确的“接受”请求标头的 HTTP 客户端。除了使用后缀匹配，我们还可以使用一个查询参数来确保像这样的请求`"GET /projects/spring-boot?format=json"`将被映射到`@GetMapping("/projects/spring-boot")`：

```yaml
spring:
  mvc:
    contentnegotiation:
      favor-parameter: true
```

从 Spring Framework 5.3 开始，Spring MVC 支持多种用于将请求路径与控制器处理程序匹配的实现策略。它以前只是支持`AntPathMatcher`策略，但现在也提供了`PathPatternParser`。Spring Boot 现在提供了一个配置属性来选择和选择新策略：

```yaml
spring:
  mvc:
    pathmatch:
      matching-strategy: "path-pattern-parser"
```

PathPatternParser是一个优化的实现，但限制了某些路径模式变体的使用。它与后缀模式匹配或将DispatcherServlet映射为servlet前缀（spring.mvc.servlet.path）不兼容。

#### ConfigurableWebBindingInitializer

Spring MVC使用WebBindingInitializer为特定请求初始化WebDataBinder。如果您创建自己的ConfigurationWebBindingInitializer@Bean，Spring Boot会自动配置Spring MVC以使用它。

#### 模板引擎

除了RESTWeb服务，您还可以使用SpringMVC来提供动态HTML内容。Spring MVC支持多种模板技术，包括Thymelaf、FreeMarker和JSP。Spring Boot包括对以下模板引擎的自动配置支持：

- [FreeMarker](https://freemarker.apache.org/docs/)
- [Groovy](https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine)
- [Thymeleaf](https://www.thymeleaf.org/)
- [Mustache](https://mustache.github.io/)

当您使用其中一个具有默认配置的模板引擎时，您的模板将自动从src/main/resources/templates中获取。

#### 错误处理

默认情况下，Spring Boot 提供了一个`/error`以合理方式处理所有错误的映射，它在 servlet 容器中注册为“全局”错误页面。对于机器客户端，它会生成一个包含错误详细信息、HTTP 状态和异常消息的 JSON 响应。对于浏览器客户端，有一个“whitelabel”错误视图，它以 HTML 格式呈现相同的数据（要自定义它，添加一个`View`解析为`error`）。`server.error`如果您想自定义默认的错误处理行为，可以设置许多属性。要完全替换默认行为，您可以实现`ErrorController`并注册该类型的 bean 定义，或者添加一个类型的 bean`ErrorAttributes`以使用现有机制但替换内容。

还可以定义一个注释的类`@ControllerAdvice`来自定义 JSON 文档以返回特定的控制器和/或异常类型，如以下示例所示：

```java
@ControllerAdvice(basePackageClasses = SomeController.class)
public class MyControllerAdvice extends ResponseEntityExceptionHandler {

    @ResponseBody
    @ExceptionHandler(MyException.class)
    public ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity<>(new MyErrorBody(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        HttpStatus status = HttpStatus.resolve(code);
        return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR;
    }

}
```

#### CORS支持

[跨源资源共享](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)(CORS) 是[大多数浏览器](https://caniuse.com/#feat=cors)实现的[W3C 规范](https://www.w3.org/TR/cors/)，它允许您以灵活的方式指定授权什么样的跨域请求，而不是使用一些不太安全和不太强大的方法，如 IFRAME 或 JSONP。

从 4.2 版开始，Spring MVC[支持 CORS](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/web.html#mvc-cors)。在 Spring Boot 应用程序中使用带有注释的[控制器方法 CORS 配置](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/web.html#mvc-cors-controller)[`@CrossOrigin`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html)不需要任何特定配置。 可以通过使用自定义方法注册 bean来定义[全局 CORS 配置](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/web.html#mvc-cors-global)，如以下示例所示：`WebMvcConfigurer``addCorsMappings(CorsRegistry)`

```java
@Configuration(proxyBeanMethods = false)
public class MyCorsConfiguration {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {

            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }

        };
    }

}
```

###  JAX-RS and Jersey

可以使用一种可用的实现来代替 Spring MVC，REST 端点的 JAX-RS 编程模型。 [Jersey](https://jersey.github.io/)和[Apache CXF](https://cxf.apache.org/)开箱即用。CXF 要求您在您的应用程序上下文中注册它`Servlet`或`Filter`作为。`@Bean`Jersey 有一些原生的 Spring 支持，所以我们也在 Spring Boot 中为它提供自动配置支持，连同一个启动器。

要开始使用 Jersey，请将其`spring-boot-starter-jersey`作为依赖项包含在内，然后您需要一种`@Bean`类型`ResourceConfig`来注册所有端点，如以下示例所示：

```java
@Component
public class MyJerseyConfig extends ResourceConfig {

    public MyJerseyConfig() {
        register(MyEndpoint.class);
    }

}
```

对于更高级的自定义，您还可以注册任意数量的 bean，这些 bean 实现了`ResourceConfigCustomizer`.

所有已注册的端点都应`@Components`带有 HTTP 资源注释（`@GET`和其他），如以下示例所示：

```java
@Component
@Path("/hello")
public class MyEndpoint {

    @GET
    public String message() {
        return "Hello";
    }

}
```

由于`Endpoint`是 Spring `@Component`，它的生命周期由 Spring 管理，您可以使用`@Autowired`注解注入依赖项并使用`@Value`注解注入外部配置。默认情况下，Jersey servlet 已注册并映射到`/*`. 您可以通过添加`@ApplicationPath`到您的`ResourceConfig`.

## 响应式 Web 应用程序

Spring Boot 通过为 Spring Webflux 提供自动配置来简化反应式 Web 应用程序的开发。

### Spring WebFlux 框架

Spring WebFlux 是 Spring Framework 5.0 中引入的新的反应式 Web 框架。与Spring MVC不同，它不需要servlet API，完全异步非阻塞，通过[Reactor项目实现了](https://projectreactor.io/)[Reactive Streams](https://www.reactive-streams.org/)规范。Spring WebFlux 有两种风格：函数式和基于注解的。基于注释的模型非常接近 Spring MVC 模型，如以下示例所示：

```java
@RestController
@RequestMapping("/users")
public class MyRestController {

    private final UserRepository userRepository;

    private final CustomerRepository customerRepository;

    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{userId}")
    public Mono<User> getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId);
    }

    @GetMapping("/{userId}/customers")
    public Flux<Customer> getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).flatMapMany(this.customerRepository::findByUser);
    }

    @DeleteMapping("/{userId}")
    public Mono<Void> deleteUser(@PathVariable Long userId) {
        return this.userRepository.deleteById(userId);
    }

}
```

> 在您的应用程序中同时添加`spring-boot-starter-web`和`spring-boot-starter-webflux`模块会导致 Spring Boot 自动配置 Spring MVC，而不是 WebFlux。选择此行为是因为许多 Spring 开发人员将其添加`spring-boot-starter-webflux`到他们的 Spring MVC 应用程序中以使用响应式`WebClient`. 您仍然可以通过将所选应用程序类型设置为 来强制执行您的选择`SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)`。

#### Spring WebFlux 自动配置

Spring Boot 为 Spring WebFlux 提供自动配置，适用于大多数应用程序。

自动配置在 Spring 的默认设置之上添加了以下功能：

- `HttpMessageReader`为和`HttpMessageWriter`实例配置编解码器。
- 支持提供静态资源，包括对 WebJars 的支持。

- 如果保留 Spring Boot WebFlux 特性并且你想添加额外的 WebFlux 配置，你可以添加你自己`@Configuration`的类型类`WebFluxConfigurer`但**没有** `@EnableWebFlux`.
- 如果你想完全控制 Spring WebFlux，你可以添加你自己的`@Configuration`带有`@EnableWebFlux`.

#### 带有 HttpMessageReaders 和 HttpMessageWriters 的 HTTP 编解码器

Spring WebFlux 使用`HttpMessageReader`和`HttpMessageWriter`接口来转换 HTTP 请求和响应。`CodecConfigurer`通过查看类路径中可用的库，它们被配置为具有合理的默认值。Spring Boot 为编解码器提供专用配置属性，`spring.codec.*`. 它还通过使用`CodecCustomizer`实例应用进一步的定制。例如，`spring.jackson.*`配置密钥应用于 Jackson 编解码器。如果您需要添加或自定义编解码器，您可以创建一个自定义`CodecCustomizer`组件，如以下示例所示：

```java
@Configuration(proxyBeanMethods = false)
public class MyCodecsConfiguration {

    @Bean
    public CodecCustomizer myCodecCustomizer() {
        return (configurer) -> {
            configurer.registerDefaults(false);
            configurer.customCodecs().register(new ServerSentEventHttpMessageReader());
            // ...
        };
    }

}
```

#### 静态资源

默认情况下，Spring Boot 从类路径中名为`/static`(or or `/public`)的目录提供静态内容。它使用来自 Spring WebFlux 的，因此您可以通过添加自己的方法并覆盖该方法来修改该行为。默认情况下，资源映射到 上`/**`，但您可以通过设置`spring.webflux.static-path-pattern`属性来调整它。例如，将所有资源重新定位到`/resources/**`可以实现如下：

```yaml
spring:
  webflux:
    static-path-pattern: "/resources/**"
```

您还可以使用自定义静态资源位置`spring.web.resources.static-locations`。这样做会将默认值替换为目录位置列表。如果您这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果`index.html`启动时您的任何位置中有 ，它就是应用程序的主页。

> Spring WebFlux应用不严格依赖servlet API，所以不能部署为war文件，不使用`src/main/webapp`目录。

#### 网页过滤器

Spring WebFlux 提供了一个`WebFilter`可以实现过滤 HTTP 请求-响应交换的接口。 `WebFilter`在应用程序上下文中找到的 beans 将自动用于过滤每个交换。在过滤器的顺序很重要的地方，它们可以实现`Ordered`或用 注释`@Order`。Spring Boot 自动配置可以为您配置 Web 过滤器。执行此操作时，将使用下表中显示的命令：

| 网页过滤器                    | 命令                             |
| :---------------------------- | :------------------------------- |
| `ServerHttpObservationFilter` | `Ordered.HIGHEST_PRECEDENCE + 1` |
| `WebFilterChainProxy`         | `-100`                           |
| `HttpExchangesWebFilter`      | `Ordered.LOWEST_PRECEDENCE - 10` |

### 嵌入式反应服务器支持

Spring Boot 包括对以下嵌入式响应式 Web 服务器的支持：Reactor Netty、Tomcat、Jetty 和 Undertow。大多数开发人员使用适当的“Starter”来获得完全配置的实例。默认情况下，嵌入式服务器在端口 8080 上侦听 HTTP 请求。

### 反应式服务器资源配置

当自动配置 Reactor Netty 或 Jetty 服务器时，Spring Boot 将创建特定的 bean，为服务器实例提供 HTTP 资源：`ReactorResourceFactory`或`JettyResourceFactory`.默认情况下，这些资源也将与 Reactor Netty 和 Jetty 客户端共享以获得最佳性能，前提是：

- 服务器和客户端使用相同的技术
- 客户端实例是使用`WebClient.Builder`Spring Boot 自动配置的 bean构建的

开发人员可以通过提供自定义`ReactorResourceFactory`或`JettyResourceFactory`bean 来覆盖 Jetty 和 Reactor Netty 的资源配置——这将应用于客户端和服务器。

## 正常关闭

所有四种嵌入式 Web 服务器（Jetty、Reactor Netty、Tomcat 和 Undertow）以及反应式和基于 servlet 的 Web 应用程序都支持正常关闭。它作为关闭应用程序上下文的一部分出现，并在停止`SmartLifecyclebean` 的最早阶段执行。此停止处理使用超时提供宽限期，在此期间允许完成现有请求但不允许新请求。不允许新请求的确切方式因所使用的 Web 服务器而异。Jetty、Reactor Netty 和 Tomcat 将停止在网络层接受请求。Undertow 将接受请求，但会立即响应服务不可用 (503) 响应。

要启用正常关机，请配置该`server.shutdown`属性，如以下示例所示：

```yaml
server:
  shutdown: "graceful"
```

要配置超时时间，请配置`spring.lifecycle.timeout-per-shutdown-phase`属性，如以下示例所示：

```yaml
spring:
  lifecycle:
    timeout-per-shutdown-phase: "20s"
```

# Spring Security





# Spring Session

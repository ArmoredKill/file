# 概述

使用适配的开发环境：

- **Build systems:** [Maven] | [Gradle] | [Ant] | [Starters]
- **Best practices:** [Code Structure] | [@Configuration] | [@EnableAutoConfiguration] | [Beans and Dependency Injection]
- **Running your code:** [IDE] | [Packaged] | [Maven] | [Gradle]
- **Packaging your app:** [Production jars]
- **Spring Boot CLI:** [Using the CLI]

web应用相关部分：

- **Servlet Web Applications:** [Spring MVC, Jersey, Embedded Servlet Containers]
- **Reactive Web Applications:** [Spring Webflux, Embedded Servlet Containers]
- **Graceful Shutdown:** [Graceful Shutdown]
- **Spring Security:** [Default Security Configuration, Auto-configuration for OAuth2, SAML]
- **Spring Session:** [Auto-configuration for Spring Session]
- **Spring HATEOAS:** [Auto-configuration for Spring HATEOAS]

数据应用处理存储相关：

- **SQL:** [Configuring a SQL Datastore, Embedded Database support, Connection pools, and more.]
- **NOSQL:** [Auto-configuration for NOSQL stores such as Redis, MongoDB, Neo4j, and others.]

消息组件部分：

- **JMS:** [Auto-configuration for ActiveMQ and Artemis, Sending and Receiving messages through JMS]
- **AMQP:** [Auto-configuration for RabbitMQ]
- **Kafka:** [Auto-configuration for Spring Kafka]
- **RSocket:** [Auto-configuration for Spring Framework’s RSocket Support]
- **Spring Integration:** [Auto-configuration for Spring Integration]

应用IO的功能相关：

- **Caching:** [Caching support with EhCache, Hazelcast, Infinispan, and more]
- **Quartz:** [Quartz Scheduling]
- **Mail:** [Sending Email
- **Validation:** [JSR-303 Validation]
- **REST Clients:** [Calling REST Services with RestTemplate and WebClient
- **Webservices:** [Auto-configuration for Spring Web Services]
- **JTA:** [Distributed Transactions with JTA]

# 基础使用

## 系统构建

Spring Boot 的每个版本都提供了它支持的依赖项的精选列表。不需要在构建配置中为任何这些依赖项提供版本，因为 Spring Boot 会进行管理。当您升级 Spring Boot 本身时，这些依赖项也会以一致的方式升级。

Starters 是一组方便的依赖描述符，您可以将它们包含在您的应用程序中。您可以获得所需的所有 Spring 和相关技术的一站式服务，而无需搜索示例代码和复制粘贴大量依赖项描述符。所有**官方**启动器都遵循类似的命名模式；`spring-boot-starter-*`，其中`*`是特定类型的应用程序。此命名结构旨在在您需要查找启动器时提供帮助。Spring Boot 组下提供了以下应用启动器`org.springframework.boot`：

| 名称                                          | 描述                                                         |
| :-------------------------------------------- | :----------------------------------------------------------- |
| `spring-boot-starter`                         | Core starter，包括自动配置支持、日志记录和 YAML              |
| `spring-boot-starter-amqp`                    | 使用 Spring AMQP 和 Rabbit MQ 的启动器                       |
| `spring-boot-starter-aop`                     | 使用 Spring AOP 和 AspectJ 进行面向方面编程的入门            |
| `spring-boot-starter-artemis`                 | 使用 Apache Artemis 的 JMS 消息传递启动器                    |
| `spring-boot-starter-batch`                   | 使用 Spring Batch 的启动器                                   |
| `spring-boot-starter-cache`                   | 使用 Spring Framework 的缓存支持的 Starter                   |
| `spring-boot-starter-data-cassandra`          | 使用 Cassandra 分布式数据库和 Spring Data Cassandra 的 Starter |
| `spring-boot-starter-data-cassandra-reactive` | 使用 Cassandra 分布式数据库和 Spring Data Cassandra Reactive 的 Starter |
| `spring-boot-starter-data-couchbase`          | 使用 Couchbase 面向文档的数据库和 Spring Data Couchbase 的启动器 |
| `spring-boot-starter-data-couchbase-reactive` | 使用 Couchbase 面向文档的数据库和 Spring Data Couchbase Reactive 的 Starter |
| `spring-boot-starter-data-elasticsearch`      | 使用 Elasticsearch 搜索和分析引擎以及 Spring Data Elasticsearch 的 Starter |
| `spring-boot-starter-data-jdbc`               | 使用 Spring Data JDBC 的启动器                               |
| `spring-boot-starter-data-jpa`                | 将 Spring Data JPA 与 Hibernate 一起使用的启动器             |
| `spring-boot-starter-data-ldap`               | 使用 Spring Data LDAP 的启动器                               |
| `spring-boot-starter-data-mongodb`            | 使用 MongoDB 面向文档的数据库和 Spring Data MongoDB 的启动器 |
| `spring-boot-starter-data-mongodb-reactive`   | 使用 MongoDB 文档型数据库和 Spring Data MongoDB Reactive 的 Starter |
| `spring-boot-starter-data-neo4j`              | 使用 Neo4j 图形数据库和 Spring Data Neo4j 的启动器           |
| `spring-boot-starter-data-r2dbc`              | 使用 Spring Data R2DBC 的启动器                              |
| `spring-boot-starter-data-redis`              | 用于将 Redis 键值数据存储与 Spring Data Redis 和 Lettuce 客户端一起使用的 Starter |
| `spring-boot-starter-data-redis-reactive`     | 将 Redis 键值数据存储与 Spring Data Redis 反应式和 Lettuce 客户端一起使用的启动器 |
| `spring-boot-starter-data-rest`               | 使用 Spring Data REST 通过 REST 公开 Spring Data 存储库的 Starter |
| `spring-boot-starter-freemarker`              | 使用 FreeMarker 视图构建 MVC Web 应用程序的启动器            |
| `spring-boot-starter-graphql`                 | 使用 Spring GraphQL 构建 GraphQL 应用程序的 Starter          |
| `spring-boot-starter-groovy-templates`        | 使用 Groovy 模板视图构建 MVC web 应用程序的启动器            |
| `spring-boot-starter-hateoas`                 | 使用 Spring MVC 和 Spring HATEOAS 构建基于超媒体的 RESTful Web 应用程序的启动器 |
| `spring-boot-starter-integration`             | 使用 Spring Integration 的启动器                             |
| `spring-boot-starter-jdbc`                    | 将 JDBC 与 HikariCP 连接池一起使用的启动器                   |
| `spring-boot-starter-jersey`                  | 使用 JAX-RS 和 Jersey 构建 RESTful Web 应用程序的启动器。的替代品[`spring-boot-starter-web`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-web) |
| `spring-boot-starter-jooq`                    | 使用 jOOQ 通过 JDBC 访问 SQL 数据库的启动器。替代[`spring-boot-starter-data-jpa`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-data-jpa)或[`spring-boot-starter-jdbc`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-jdbc) |
| `spring-boot-starter-json`                    | 读写json的starter                                            |
| `spring-boot-starter-mail`                    | 使用 Java Mail 和 Spring Framework 的电子邮件发送支持的 Starter |
| `spring-boot-starter-mustache`                | 使用 Mustache 视图构建 Web 应用程序的启动器                  |
| `spring-boot-starter-oauth2-client`           | 使用 Spring Security 的 OAuth2/OpenID Connect 客户端功能的 Starter |
| `spring-boot-starter-oauth2-resource-server`  | 使用 Spring Security 的 OAuth2 资源服务器功能的启动器        |
| `spring-boot-starter-quartz`                  | 使用 Quartz 调度器的启动器                                   |
| `spring-boot-starter-rsocket`                 | 用于构建 RSocket 客户端和服务器的启动器                      |
| `spring-boot-starter-security`                | 使用 Spring Security 的启动器                                |
| `spring-boot-starter-test`                    | 用于使用 JUnit Jupiter、Hamcrest 和 Mockito 等库测试 Spring Boot 应用程序的 Starter |
| `spring-boot-starter-thymeleaf`               | 使用 Thymeleaf 视图构建 MVC Web 应用程序的启动器             |
| `spring-boot-starter-validation`              | 将 Java Bean Validation 与 Hibernate Validator 结合使用的 Starter |
| `spring-boot-starter-web`                     | 用于使用 Spring MVC 构建 Web（包括 RESTful）应用程序的 Starter。使用 Tomcat 作为默认的嵌入式容器 |
| `spring-boot-starter-web-services`            | 使用 Spring Web 服务的启动器                                 |
| `spring-boot-starter-websocket`               | 使用 Spring Framework 的 MVC WebSocket 支持构建 WebSocket 应用程序的 Starter |
| `spring-boot-starter-webflux`                 | 用于使用 Spring Framework 的 Reactive Web 支持构建 WebFlux 应用程序的 Starter |
| `spring-boot-starter-actuator`                | 使用 Spring Boot Actuator 的 Starter，它提供生产就绪功能来帮助您监控和管理您的应用程序 |
| `spring-boot-starter-jetty`                   | 使用 Jetty 作为嵌入式 servlet 容器的启动器。的替代品[`spring-boot-starter-tomcat`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-tomcat) |
| `spring-boot-starter-log4j2`                  | 使用 Log4j2 进行日志记录的启动器。的替代品[`spring-boot-starter-logging`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-logging) |
| `spring-boot-starter-logging`                 | 使用 Logback 进行日志记录的启动器。默认日志记录启动器        |
| `spring-boot-starter-reactor-netty`           | 使用 Reactor Netty 作为嵌入式响应式 HTTP 服务器的启动器。    |
| `spring-boot-starter-tomcat`                  | 将 Tomcat 用作嵌入式 servlet 容器的启动器。使用的默认 servlet 容器启动器[`spring-boot-starter-web`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-web) |
| `spring-boot-starter-undertow`                | 使用 Undertow 作为嵌入式 servlet 容器的启动器。的替代品[`spring-boot-starter-tomcat`](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-tomcat) |

## 应用启动

该类`SpringApplication`提供了一种方便的方法来引导从`main()`方法启动的 Spring 应用程序。在许多情况下，您可以委托给静态`SpringApplication.run`方法，如以下示例所示：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

当您的应用程序启动时，输出内容：

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.0.2)

2023-01-20T00:27:31.367Z  INFO 21229 --- [           main] o.s.b.d.f.s.MyApplication                : Starting MyApplication using Java 17.0.6 with PID 21229 (/opt/apps/myapp.jar started by myuser in /opt/apps/)
2023-01-20T00:27:31.385Z  INFO 21229 --- [           main] o.s.b.d.f.s.MyApplication                : No active profile set, falling back to 1 default profile: "default"
2023-01-20T00:27:34.696Z  INFO 21229 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2023-01-20T00:27:34.769Z  INFO 21229 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2023-01-20T00:27:34.770Z  INFO 21229 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.5]
2023-01-20T00:27:35.264Z  INFO 21229 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2023-01-20T00:27:35.266Z  INFO 21229 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3786 ms
2023-01-20T00:27:36.384Z  INFO 21229 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2023-01-20T00:27:36.401Z  INFO 21229 --- [           main] o.s.b.d.f.s.MyApplication                : Started MyApplication in 6.557 seconds (process running for 7.483)
```

### 惰性初始化

`SpringApplication`允许延迟初始化应用程序。当启用惰性初始化时，bean 是在需要时创建的，而不是在应用程序启动期间创建的。因此，启用惰性初始化可以减少应用程序启动所需的时间。在 web 应用程序中，启用惰性初始化将导致许多与 web 相关的 bean 在收到 HTTP 请求之前不会被初始化。

惰性初始化的一个缺点是它可以延迟发现应用程序的问题。如果配置错误的 bean 被懒惰地初始化，则在启动期间将不再发生故障，并且只有在 bean 被初始化时问题才会变得明显。还必须注意确保 JVM 有足够的内存来容纳所有应用程序的 bean，而不仅仅是那些在启动期间初始化的 bean。

`lazyInitialization`可以使用on 方法`SpringApplicationBuilder`或`setLazyInitialization`on方法以编程方式启用延迟初始化`SpringApplication`。或者，可以使用`spring.main.lazy-initialization`以下示例中所示的属性启用它：
```yaml
spring:  
	main:    
		lazy-initialization: true
```

### 自定义banner

`banner.txt`可以通过将文件添加到类路径或将`spring.banner.location`属性设置为此类文件的位置来更改启动时打印的横幅。如果文件的编码不是 UTF-8，可以设置`spring.banner.charset`.在您的`banner.txt`文件中，您可以使用 中可用的任何键`Environment`以及以下任何占位符：

| 变量                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `${application.version}`                                     | 您的应用程序的版本号，如在中声明的那样`MANIFEST.MF`。例如，`Implementation-Version: 1.0`打印为`1.0`. |
| `${application.formatted-version}`                           | 您的应用程序的版本号，在中声明`MANIFEST.MF`并格式化显示（用括号括起来并以 为前缀`v`）。例如`(v1.0)`。 |
| `${spring-boot.version}`                                     | 您正在使用的 Spring Boot 版本。例如`3.0.2`。                 |
| `${spring-boot.formatted-version}`                           | 您正在使用的 Spring Boot 版本，经过格式化以供显示（用方括号括起来并以 为前缀`v`）。例如`(v3.0.2)`。 |
| `${Ansi.NAME}`（或`${AnsiColor.NAME}`，，`${AnsiBackground.NAME}`）`${AnsiStyle.NAME}` | `NAME`ANSI 转义代码的名称在哪里。详情请见[`AnsiPropertySource`](https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java)。 |
| `${application.title}`                                       | 您的应用程序的标题，如中声明的那样`MANIFEST.MF`。例如`Implementation-Title: MyApp`打印为`MyApp`. |

### 自定义 SpringApplication

可以创建一个本地实例并对其进行自定义。例如，要关闭横幅，您可以这样写：

```java
import org.springframework.boot.Banner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(MyApplication.class);
        application.setBannerMode(Banner.Mode.OFF);
        application.run(args);
    }
}
```

### 应用可用性

当部署在平台上时，应用程序可以使用Kubernetes Probes。等基础设施向平台提供有关其可用性的信息。Spring Boot 包括对常用的“活动”和“就绪”可用性状态的开箱即用支持。如果您使用 Spring Boot 的“执行器”支持，那么这些状态将作为健康端点组公开。此外，您还可以通过将`ApplicationAvailability`接口注入到您自己的 bean 中来获取可用性状态。

应用程序的“活动”状态表明它的内部状态是否允许它正常工作，或者如果它当前失败则自行恢复。损坏的“活动”状态意味着应用程序处于无法恢复的状态，基础架构应重新启动应用程序。Spring Boot 应用程序的内部状态主要由 Spring 表示`ApplicationContext`。如果应用程序上下文已成功启动，Spring Boot 会假定应用程序处于有效状态。一旦上下文被刷新，应用程序就被认为是活跃的

应用程序的“就绪”状态表明应用程序是否已准备好处理流量。失败的“就绪”状态告诉平台它现在不应该将流量路由到应用程序。这通常发生在启动期间，同时正在处理`CommandLineRunner`和`ApplicationRunner`组件，或者在应用程序决定它太忙而无法处理额外流量时发生。一旦应用程序和命令行运行程序被调用，应用程序就被认为准备就绪。

应用程序组件可以随时通过注入`ApplicationAvailability`接口和调用方法来检索当前的可用性状态。更多时候，应用程序会想要监听状态更新或更新应用程序的状态。例如，我们可以将应用程序的“Readiness”状态导出到一个文件中，以便 Kubernetes 的“exec Probe”可以查看这个文件：

```java
@Component
public class MyReadinessStateExporter {

    @EventListener
    public void onStateChange(AvailabilityChangeEvent<ReadinessState> event) {
        switch (event.getState()) {
            case ACCEPTING_TRAFFIC:
                // create file /tmp/healthy
                break;
            case REFUSING_TRAFFIC:
                // remove file /tmp/healthy
                break;
        }
    }

}
```

当应用程序中断且无法恢复时，我们还可以更新应用程序的状态：

```java
@Component
public class MyLocalCacheVerifier {

    private final ApplicationEventPublisher eventPublisher;

    public MyLocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    public void checkLocalCache() {
        try {
            // ...
        }
        catch (CacheCompletelyBrokenException ex) {
            AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);
        }
    }

}
```

### 应用程序事件和监听器

除了通常的 Spring Framework 事件（例如 ）之外`ContextRefreshedEvent`，`SpringApplication`还会发送一些额外的应用程序事件。

有些事件实际上`ApplicationContext`是在创建之前触发的，因此您不能将这些事件的侦听器注册为`@Bean`. `SpringApplication.addListeners(…)`您可以使用方法或方法注册它们`SpringApplicationBuilder.listeners(…)`。

自动注册这些侦听器，而不管应用程序的创建方式如何，您可以将`META-INF/spring.factories`文件添加到您的项目并使用`org.springframework.context.ApplicationListener`密钥引用您的侦听器，如以下示例所示：

```
org.springframework.context.ApplicationListener=com.example.project.MyListener
```

当您的应用程序运行时，应用程序事件按以下顺序发送：

1. An`ApplicationStartingEvent`在运行开始时发送，但在任何处理之前发送，除了侦听器和初始化器的注册。
2. 当要在上下文中使用的 已知但在创建上下文之前`ApplicationEnvironmentPreparedEvent`发送An 。`Environment`
3. 准备好并调用 ApplicationContextInitializers 但在加载任何 bean 定义之前`ApplicationContextInitializedEvent`发送An 。`ApplicationContext`
4. 就在`ApplicationPreparedEvent`刷新开始之前但在加载 bean 定义之后发送。
5. `ApplicationStartedEvent`在刷新上下文之后但在调用任何应用程序和命令行运行程序之前发送An 。
6. `AvailabilityChangeEvent`在 with 之后立即发送An`LivenessState.CORRECT`以指示该应用程序被认为是实时的。
7. `ApplicationReadyEvent`在调用任何应用[程序和命令行运行程序](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.command-line-runner)后发送。
8. `AvailabilityChangeEvent`在 with 之后立即发送An`ReadinessState.ACCEPTING_TRAFFIC`以指示应用程序已准备好服务请求。
9. `ApplicationFailedEvent`如果启动时出现异常，则发送An 。

上面的列表只包括`SpringApplicationEvent`绑定到 a 的 s `SpringApplication`。除了这些之外，以下事件也在之后`ApplicationPreparedEvent`和之前发布`ApplicationStartedEvent`：

- A在准备就绪`WebServerInitializedEvent`后发送`WebServer`。 `ServletWebServerInitializedEvent`和`ReactiveWebServerInitializedEvent`分别是 servlet 和反应式变体。
- 刷新`ContextRefreshedEvent`时发送A。`ApplicationContext`

应用事件通过Spring Framework的事件发布机制发送。该机制的一部分确保发布到子上下文中的侦听器的事件也被发布到任何祖先上下文中的侦听器。因此，如果您的应用程序使用`SpringApplication`实例层次结构，则侦听器可能会收到同一类型应用程序事件的多个实例。

为了让您的侦听器区分其上下文的事件和后代上下文的事件，它应该请求注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现注入上下文，`ApplicationContextAware`或者，如果侦听器是一个 bean，则使用`@Autowired`.

### web调用

A`SpringApplication`尝试`ApplicationContext`代表您创建正确的类型。用于确定 a 的算法`WebApplicationType`如下：

- 如果存在 Spring MVC，`AnnotationConfigServletWebServerApplicationContext`则使用
- 如果 Spring MVC 不存在而 Spring WebFlux 存在，`AnnotationConfigReactiveWebServerApplicationContext`则使用
- 否则，`AnnotationConfigApplicationContext`使用

这意味着如果您`WebClient`在同一应用程序中使用 Spring MVC 和 Spring WebFlux 的新功能，则默认情况下将使用 Spring MVC。您可以通过调用轻松覆盖它`setWebApplicationType(WebApplicationType)`。

也可以完全控制`ApplicationContext`调用所使用的类型`setApplicationContextClass(…)`。

### 访问Application参数

如果您需要访问传递给 的应用程序参数`SpringApplication.run(…)`，您可以注入一个`org.springframework.boot.ApplicationArguments`bean。该`ApplicationArguments`接口提供对原始`String[]`参数以及已解析参数`option`和`non-option`参数的访问，如以下示例所示：

```java
@Component
public class MyBean {

    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List<String> files = args.getNonOptionArgs();
        if (debug) {
            System.out.println(files);
        }
        // if run with "--debug logfile.txt" prints ["logfile.txt"]
    }
}
```

### 使用 ApplicationRunner 或 CommandLineRunner

如果您需要在启动后运行一些特定的代码`SpringApplication`，您可以实现`ApplicationRunner`或`CommandLineRunner`接口。这两个接口以相同的方式工作，并提供一个`run`方法，该方法在完成之前被调用`SpringApplication.run(…)`。

这些`CommandLineRunner`接口提供对应用程序参数作为字符串数组的访问，而`ApplicationRunner`使用`ApplicationArguments`前面讨论的接口。以下示例显示了`CommandLineRunner`一个`run`方法：

```java
@Component
public class MyCommandLineRunner implements CommandLineRunner {

    @Override
    public void run(String... args) {
        // Do something...
    }

}
```

### 应用退出

每个都`SpringApplication`向 JVM 注册一个关闭挂钩，以确保`ApplicationContext`在退出时正常关闭。可以使用所有标准的 Spring 生命周期回调（例如`DisposableBean`接口或`@PreDestroy`注释）。

此外，如果 bean希望在被调用`org.springframework.boot.ExitCodeGenerator`时返回特定的退出代码，则它们可以实现该接口。`SpringApplication.exit()`然后可以将此退出代码传递给以将`System.exit()`其作为状态代码返回，如以下示例所示：

```java
@SpringBootApplication
public class MyApplication {

    @Bean
    public ExitCodeGenerator exitCodeGenerator() {
        return () -> 42;
    }

    public static void main(String[] args) {
        System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args)));
    }

}
```

此外，`ExitCodeGenerator`接口可以通过异常来实现。遇到此类异常时，Spring Boot 会返回已实现`getExitCode()`方法提供的退出代码。如果有多个`ExitCodeGenerator`，则使用生成的第一个非零退出代码。

### 应用程序启动跟踪

在应用程序启动期间，`SpringApplication`执行`ApplicationContext`许多与应用程序生命周期、bean 生命周期甚至处理应用程序事件相关的任务。有了[`ApplicationStartup`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html)Spring Framework [，您就可以使用`StartupStep`对象](https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/core.html#context-functionality-startup)跟踪应用程序启动顺序。您可以`ApplicationStartup`在设置`SpringApplication`实例时选择一个实现。例如，要使用`BufferingApplicationStartup`：

```java
@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(MyApplication.class);
        application.setApplicationStartup(new BufferingApplicationStartup(2048));
        application.run(args);
    }

}
```

第一个可用的实现`FlightRecorderApplicationStartup`由 Spring Framework 提供。它将特定于 Spring 的启动事件添加到 Java Flight Recorder 会话，旨在分析应用程序并将其 Spring 上下文生命周期与 JVM 事件（例如分配、GC、类加载……）相关联。配置完成后，您可以在启用飞行记录器的情况下运行应用程序来记录数据：

```
$ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar
```

Spring Boot 附带`BufferingApplicationStartup`变体；此实现旨在缓冲启动步骤并将它们排入外部指标系统。`BufferingApplicationStartup`应用程序可以在任何组件中请求类型的 bean 。Spring Boot 还可以配置为公开一个以 JSON 文档形式提供此信息的`startup`端点。

## 外部配置

Spring Boot 允许您外部化您的配置，以便您可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括 Java 属性文件、YAML 文件、环境变量和命令行参数。属性值可以通过注解直接注入 bean `@Value`，通过 Spring 的[抽象](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties)`Environment`访问，或者通过.`@ConfigurationProperties`。Spring Boot 使用一种非常特殊的`PropertySource`顺序，旨在允许合理地覆盖值。后面的属性源可以覆盖前面定义的值。来源按以下顺序考虑：

1. 默认属性（由设置指定`SpringApplication.setDefaultProperties`）。
2. [`@PropertySource`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/context/annotation/PropertySource.html)类上的注释`@Configuration`。请注意，`Environment`在刷新应用程序上下文之前，不会将此类属性源添加到。现在配置某些属性（例如`logging.*`和`spring.main.*`在刷新开始前读取）为时已晚。
3. 配置数据（例如`application.properties`文件）。
4. 仅在`RandomValuePropertySource`中具有属性的`random.*`。
5. 操作系统环境变量。
6. Java 系统属性 ( `System.getProperties()`)。
7. JNDI 属性来自`java:comp/env`.
8. `ServletContext`初始化参数。
9. `ServletConfig`初始化参数。
10. 属性来自`SPRING_APPLICATION_JSON`（嵌入在环境变量或系统属性中的内联 JSON）。
11. 命令行参数。
12. `properties`测试的属性。[`@SpringBootTest`](https://docs.spring.io/spring-boot/docs/3.0.2/api/org/springframework/boot/test/context/SpringBootTest.html)在和测试注释上可用，[用于测试应用程序的特定部分](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests)。
13. [`@TestPropertySource`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/test/context/TestPropertySource.html)测试注释。
14. `$HOME/.config/spring-boot`当 devtools 处于活动状态时，目录中的[Devtools 全局设置属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.globalsettings)

配置数据文件按以下顺序考虑：

1. 打包在 jar 中的[应用程序属性](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files)`application.properties`（和 YAML 变体）。
2. 打包在您的 jar（`application-{profile}.properties`和 YAML 变体）中[的特定于配置文件的应用程序属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.profile-specific)
3. 打包的 jar（`application.properties`和 YAML 变体）之外的[应用程序属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files)
4. 打包的 jar（`application-{profile}.properties`和 YAML 变体）之外的[特定于配置文件的应用程序属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.profile-specific)

### 命令行属性

默认情况下，`SpringApplication`将任何命令行选项参数（即以 开头的参数`--`，例如`--server.port=9000`）转换为 `property`并将它们添加到 Spring`Environment`中。如前所述，命令行属性始终优先于基于文件的属性源。如果您不想将命令行属性添加到 中`Environment`，您可以使用 禁用它们`SpringApplication.setAddCommandLineProperties(false)`。

### JSON 应用程序属性

环境变量和系统属性通常有限制，这意味着某些属性名称不能使用。为了解决这个问题，Spring Boot 允许您将属性块编码为单个 JSON 结构。

当您的应用程序启动时，任何`spring.application.json`或`SPRING_APPLICATION_JSON`属性将被解析并添加到`Environment`.例如，`SPRING_APPLICATION_JSON`可以在 UN*X shell 的命令行中将属性作为环境变量提供：

```shell
$ SPRING_APPLICATION_JSON='{"my":{"name":"test"}}' java -jar myapp.jar
```

在前面的示例中，您最终`my.name=test`在 Spring 中`Environment`。

同样的 JSON 也可以作为系统属性提供：

```shell
$ java -Dspring.application.json='{"my":{"name":"test"}}' -jar myapp.jar
```

或者您可以使用命令行参数提供 JSON：

```shell
$ java -jar myapp.jar --spring.application.json='{"my":{"name":"test"}}'
```

###  外部应用程序属性

当您的应用程序启动时，Spring Boot 将自动从以下位置查找并加载文件`application.properties`：`application.yaml`

1. 从类路径
   1. 类路径根
   2. 类路径`/config`包
2. 从当前目录
   1. 当前目录
   2. 当前目录下的`config/`子目录
   3. 子目录的`config/`直接子目录

该列表按优先级排序（较低项的值覆盖较早的项）。加载文件中的文档被添加`PropertySources`到 Spring`Environment`中。

如果您不喜欢`application`作为配置文件名，您可以通过指定一个`spring.config.name`环境属性来切换到另一个文件名。例如，要查找`myproject.properties`和`myproject.yaml`文件，您可以按如下方式运行您的应用程序：

```shell
$ java -jar myproject.jar --spring.config.name=myproject
```

您还可以使用`spring.config.location`环境属性来引用显式位置。此属性接受一个或多个要检查的位置的逗号分隔列表。

以下示例显示如何指定两个不同的文件：

```shell
$ java -jar myproject.jar --spring.config.location=\
    optional:classpath:/default.properties,\
    optional:classpath:/override.properties
```

`optional:`如果[位置是可选](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.optional-prefix)的并且您不介意它们不存在， 请使用前缀。

如果`spring.config.location`包含目录（而不是文件），它们应该以`/`. 在运行时，它们将附加`spring.config.name`在加载之前生成的名称。中指定的文件`spring.config.location`直接导入。

在大多数情况下，`spring.config.location`您添加的每个项目都将引用一个文件或目录。位置按照它们被定义的顺序处理，后面的可以覆盖前面的值。如果你有一个复杂的位置设置，并且你使用特定于配置文件的配置文件，你可能需要提供进一步的提示，以便 Spring Boot 知道它们应该如何分组。位置组是所有位置都被视为同一级别的位置的集合。例如，您可能希望对所有类路径位置进行分组，然后对所有外部位置进行分组。位置组中的项目应该用 分隔`;`。使用配置的`spring.config.location`位置替换默认位置。例如，如果`spring.config.location`配置了值`optional:classpath:/custom-config/,optional:file:./custom-config/`，则考虑的完整位置集是：

1. `optional:classpath:custom-config/`
2. `optional:file:./custom-config/`

如果您更喜欢添加其他位置，而不是替换它们，您可以使用`spring.config.additional-location`. 从其他位置加载的属性可以覆盖默认位置中的属性。例如，如果`spring.config.additional-location`配置了值`optional:classpath:/custom-config/,optional:file:./custom-config/`，则考虑的完整位置集是：

1. `optional:classpath:/;optional:classpath:/config/`
2. `optional:file:./;optional:file:./config/;optional:file:./config/*/`
3. `optional:classpath:custom-config/`
4. `optional:file:./custom-config/`

注意：

- 如果您使用环境变量而不是系统属性，大多数操作系统不允许使用句点分隔的键名，但您可以使用下划线代替（例如，`SPRING_CONFIG_NAME`代替`spring.config.name`）。
- 如果您的应用程序在 servlet 容器或应用程序服务器中运行，则可以使用 JNDI 属性（在 中`java:comp/env`）或 servlet 上下文初始化参数来代替或同时使用环境变量或系统属性。

#### 可选位置

默认情况下，当指定的配置数据位置不存在时，Spring Boot 将抛出一个`ConfigDataLocationNotFoundException`并且您的应用程序将不会启动。如果你想指定一个位置，但你不介意它并不总是存在，你可以使用`optional:`前缀。您可以将此前缀与`spring.config.location`和`spring.config.additional-location`属性以及[`spring.config.import`](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.importing)声明一起使用。

例如，`spring.config.import`值`optional:file:./myconfig.properties`允许您的应用程序启动，即使`myconfig.properties`文件丢失。如果您想忽略所有`ConfigDataLocationNotFoundExceptions`并始终继续启动您的应用程序，您可以使用该`spring.config.on-not-found`属性。将值设置为`ignore`使用`SpringApplication.setDefaultProperties(…)`或与系统/环境变量一起使用。

#### 通配符

如果配置文件位置包含`*`最后一个路径段的字符，则它被视为通配符位置。加载配置时会扩展通配符，以便也检查直接子目录。当存在多个配置属性源时，通配符位置在 Kubernetes 等环境中特别有用。

例如，如果您有一些 Redis 配置和一些 MySQL 配置，您可能希望将这两部分配置分开，同时要求它们都存在于一个`application.properties`文件中。这可能会导致两个单独的`application.properties`文件安装在不同的位置，例如`/config/redis/application.properties`和`/config/mysql/application.properties`。在这种情况下，具有通配符位置`config/*/`, 将导致同时处理两个文件。默认情况下，Spring Boot 包含`config/*/`在默认搜索位置中。这意味着`/config`将搜索 jar 之外目录的所有子目录。

您可以自己将通配符位置与`spring.config.location`和`spring.config.additional-location`属性一起使用。对于作为目录的搜索位置或作为文件的搜索位置， 通配符位置必须仅包含一个`*`并以结尾。带通配符的位置根据文件名的绝对路径按字母顺序排序。 `*/``*/<filename>`。通配符位置仅适用于外部目录。<span style="color:red">您不能在`classpath:`位置中使用通配符。</span>

#### 特定配置文件

除了`application`属性文件，Spring Boot 还将尝试使用命名约定加载特定于配置文件的文件`application-{profile}`。例如，如果您的应用程序激活一个名为 profile`prod`并使用 YAML 文件，那么`application.yml`和`application-prod.yml`都会被考虑。

特定于配置文件的属性从与标准相同的位置加载，`application.properties`特定于配置文件的文件始终覆盖非特定文件。如果指定了多个配置文件，则应用最后获胜的策略。例如，如果配置文件`prod,live`由`spring.profiles.active`属性指定，则 中的值`application-prod.properties`可以被 中的值覆盖`application-live.properties`。

属性文件只加载一次。如果您已经直接[导入](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.importing)了配置文件特定的属性文件，则不会再次导入它。

#### 导入附加数据

应用程序属性可以使用该属性从其他位置导入更多配置数据`spring.config.import`。进口在发现时进行处理，并被视为紧接在声明进口的文件下方插入的附加文件。例如，您的类路径`application.properties`文件中可能包含以下内容：

```java
spring:
  application:
    name: "myapp"
  config:
    import: "optional:file:./dev.properties"
```

这将触发`dev.properties`当前目录中文件的导入（如果存在这样的文件）。来自导入的值`dev.properties`将优先于触发导入的文件。在上面的示例中，`dev.properties`可以重新定义`spring.application.name`为不同的值。<span style="color:red">一个导入无论声明多少次都只会被导入一次。</span>

Spring Boot 包含可插入的 API，允许支持各种不同的位置地址。默认情况下，您可以导入 Java 属性、YAML 和“[配置树](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.configtree)”。第三方 jar 可以提供对其他技术的支持（不要求文件是本地的）。例如，您可以想象配置数据来自 Consul、Apache ZooKeeper 或 Netflix Archaius 等外部存储。如果您想支持自己的位置，请参阅包中的`ConfigDataLocationResolver`和`ConfigDataLoader`类`org.springframework.boot.context.config`。

#### 导入无扩展名文件

某些云平台无法为卷挂载文件添加文件扩展名。要导入这些没有扩展名的文件，你需要给 Spring Boot 一个提示，让它知道如何加载它们。您可以通过在方括号中放置一个扩展提示来做到这一点。例如，假设您有一个`/etc/config/myconfig`要导入为 yaml 的文件。您可以`application.properties`使用以下方法将其导入：

```yaml
spring:
  config:
    import: "file:/etc/config/myconfig[.yaml]"
```

#### 使用配置树

在云平台（例如 Kubernetes）上运行应用程序时，您经常需要读取平台提供的配置值。出于此类目的使用环境变量并不少见，但这可能有缺点，尤其是在值应该保密的情况下。作为环境变量的替代方案，许多云平台现在允许您将配置映射到已安装的数据卷中。例如，Kubernetes 可以卷挂载[`ConfigMaps`](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap)和[`Secrets`](https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod).

可以使用两种常见的卷安装模式：

1. 单个文件包含一组完整的属性（通常写为 YAML）。
2. 多个文件被写入目录树，文件名成为“键”，内容成为“值”。

对于第一种情况，您可以直接使用[上述](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.importing)`spring.config.import`方法导入 YAML 或 Properties 文件。对于第二种情况，您需要使用前缀，以便 Spring Boot 知道它需要将所有文件公开为属性。`configtree:`。 Kubernetes 已经安装了以下卷：

```
etc/
  config/
    myapp/
      username
      password
```

该`username`文件的内容将是一个配置值，而其内容`password`将是一个秘密。

要导入这些属性，您可以将以下内容添加到您的`application.properties`or`application.yaml`文件中：

```yaml
spring:
  config:
    import: "optional:configtree:/etc/config/"
```

myapp.username`然后，您可以以通常的方式访问或注入`myapp.password`属性。`Environment

如果您有多个配置树要从同一个父文件夹导入，您可以使用通配符快捷方式。`configtree:`以结尾的任何位置`/*/`都将导入所有直接子项作为配置树。例如，给定以下体积：

```
etc/
  config/
    dbconfig/
      db/
        username
        password
    mqconfig/
      mq/
        username
        password
```

您可以`configtree:/etc/config/*/`用作导入位置：

```yaml
spring:
  config:
    import: "optional:configtree:/etc/config/*/"
```

使用通配符加载的目录按字母顺序排序。如果您需要不同的订单，那么您应该将每个位置列为单独的导入

配置树也可用于 Docker 机密。当 Docker swarm 服务被授予访问秘密的权限时，秘密就会被装载到容器中。例如，如果一个名为 secret`db.password`挂载在 location `/run/secrets/`，您可以`db.password`使用以下命令使 Spring 环境可用：

```yaml
spring:
  config:
    import: "optional:configtree:/run/secrets/"
```

#### 属性占位符

`application.properties`和中的值在使用时会`application.yml`通过现有值进行过滤`Environment`，因此您可以参考以前定义的值（例如，来自系统属性或环境变量）。标准`${name}`属性占位符语法可用于值内的任何位置。属性占位符还可以指定一个默认值，使用 a`:`将默认值与属性名称分隔开，例如`${name:default}`。以下示例显示了带默认值和不带默认值的占位符的使用：

```yaml
app:
  name: "MyApp"
  description: "${app.name} is a Spring Boot application written by ${username:Unknown}"
```

假设该`username`属性未在别处设置，`app.description`则值为`MyApp is a Spring Boot application written by Unknown`。您应该始终使用规范形式（仅使用小写字母的 kebab-case）来引用占位符中的属性名称。

#### 多文档文件

Spring Boot 允许您将单个物理文件拆分为多个逻辑文档，每个逻辑文档都是独立添加的。文档按顺序从上到下处理。以后的文档可以覆盖早期文档中定义的属性。对于`application.yml`文件，使用标准的 YAML 多文档语法。三个连续的连字符代表一个文档的结尾和下一个文档的开始。

例如，以下文件有两个逻辑文档：

```yaml
spring:
  application:
    name: "MyApp"
---
spring:
  application:
    name: "MyCloudApp"
  config:
    activate:
      on-cloud-platform: "kubernetes"
```

对于`application.properties`文件，特殊`#---`或`!---`注释用于标记文档拆分：

```properties
spring.application.name=MyApp
#---
spring.application.name=MyCloudApp
spring.config.activate.on-cloud-platform=kubernetes
```

注意：

- 属性文件分隔符不能有任何前导空格，并且必须正好有三个连字符。分隔符前后的行不能是相同的注释前缀。
- 多文档属性文件通常与激活属性结合使用，例如`spring.config.activate.on-profile`。
- 不能使用`@PropertySource`或`@TestPropertySource`注释加载多文档属性文件。

#### 激活属性

有时仅在满足某些条件时才激活一组给定的属性很有用。例如，您可能拥有仅在特定配置文件处于活动状态时才相关的属性。您可以使用 有条件地激活属性文档`spring.config.activate.*`。以下激活属性可用：

| 属性                | 描述                                      |
| :------------------ | :---------------------------------------- |
| `on-profile`        | 必须匹配文档才能激活的配置文件表达式。    |
| `on-cloud-platform` | `CloudPlatform`必须检测到文档才能激活的。 |

例如，以下指定第二个文档仅在 Kubernetes 上运行时才处于活动状态，并且仅当“prod”或“staging”配置文件处于活动状态时：

```yaml
myprop:
  "always-set"
---
spring:
  config:
    activate:
      on-cloud-platform: "kubernetes"
      on-profile: "prod | staging"
myotherprop: "sometimes-set"
```

### 加密属性

Spring Boot 不提供任何对加密属性值的内置支持，但是，它确实提供了修改 Spring 中包含的值所需的挂钩点`Environment`。该`EnvironmentPostProcessor`界面允许您`Environment`在应用程序启动之前操作。如果您需要一种安全的方式来存储凭据和密码，[Spring Cloud Vault](https://cloud.spring.io/spring-cloud-vault/)项目提供了对在[HashiCorp Vault](https://www.vaultproject.io/)中存储外部化配置的支持。

### 使用 YAML

[YAML](https://yaml.org/)是 JSON 的超集，因此是一种用于指定分层配置数据的便捷格式。只要您的类路径上有[SnakeYAML](https://github.com/snakeyaml/snakeyaml)库，`SpringApplication`该类就会自动支持 YAML 作为属性的替代方法。

YAML 文档需要从其分层格式转换为可与 Spring 一起使用的平面结构`Environment`。例如，考虑以下 YAML 文档：

```yaml
environments:
  dev:
    url: "https://dev.example.com"
    name: "Developer Setup"
  prod:
    url: "https://another.example.com"
    name: "My Cool App"
```

为了从 访问这些属性`Environment`，它们将被展平如下：

```properties
environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App
```

同样，YAML 列表也需要扁平化。它们表示为带有`[index]`解引用器的属性键。例如，考虑以下 YAML：

```yaml
my:
 servers:
 - "dev.example.com"
 - "another.example.com"
```

前面的示例将转换为这些属性：

```properties
my.servers[0]=dev.example.com
my.servers[1]=another.example.com
```

Spring 框架提供了两个方便的类，可用于加载 YAML 文档。将`YamlPropertiesFactoryBean`YAML 加载为`Properties`并将`YamlMapFactoryBean`YAML 加载为`Map`.`YamlPropertySourceLoader`如果要将 YAML 作为 Spring 加载，也可以使用该类`PropertySource`。

### 配置随机值

这`RandomValuePropertySource`对于注入随机值很有用（例如，注入秘密或测试用例）。它可以生成整数、长整数、uuid 或字符串，如以下示例所示：

```yaml
my:
  secret: "${random.value}"
  number: "${random.int}"
  bignumber: "${random.long}"
  uuid: "${random.uuid}"
  number-less-than-ten: "${random.int(10)}"
  number-in-range: "${random.int[1024,65536]}"
```

`random.int*`语法是任何`OPEN value (,max) CLOSE`字符`OPEN,CLOSE`和`value,max`整数。如果`max`提供，`value`则为最小值，`max`为最大值（不包括）。

### 配置系统环境属性

Spring Boot 支持为环境属性设置前缀。如果系统环境由具有不同配置要求的多个 Spring Boot 应用程序共享，这将非常有用。系统环境属性的前缀可以直接在`SpringApplication`。例如，如果将前缀设置为，则也将像在系统环境中一样解析`input`诸如 之类的属性。`remote.timeout``input.remote.timeout`

### 类型安全配置属性

使用`@Value("${property}")`注解注入配置属性有时会很麻烦，尤其是当您使用多个属性或您的数据本质上是分层的时。Spring Boot 提供了一种使用属性的替代方法，可以让强类型 bean 管理和验证应用程序的配置。

#### JavaBean 属性绑定

可以绑定声明标准 JavaBean 属性的 bean，如以下示例所示：

```java
@ConfigurationProperties("my.service")
public class MyProperties {

    private boolean enabled;

    private InetAddress remoteAddress;

    private final Security security = new Security();

    // getters / setters...

    public static class Security {

        private String username;

        private String password;

        private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

        // getters / setters...

    }

}
```

前面的 POJO 定义了以下属性：

- `my.service.enabled`，默认值为`false`。
- `my.service.remote-address`, 具有可以从`String`.
- `my.service.security.username`，具有嵌套的“安全”对象，其名称由属性的名称确定。特别是，该类型根本没有在那里使用，可能是`SecurityProperties`.
- `my.service.security.password`.
- `my.service.security.roles`，其中的集合`String`默认为`USER`.

#### 构造函数绑定

上一节中的示例可以以不可变的方式重写，如以下示例所示：

```java
@ConfigurationProperties("my.service")
public class MyProperties {

    // fields...

    public MyProperties(boolean enabled, InetAddress remoteAddress, Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }

    // getters...

    public static class Security {

        // fields...

        public Security(String username, String password, @DefaultValue("USER") List<String> roles) {
            this.username = username;
            this.password = password;
            this.roles = roles;
        }

        // getters...

    }

}
```

在此设置中，单个参数化构造函数的存在意味着应该使用构造函数绑定。这意味着绑定器将找到一个带有您希望绑定的参数的构造函数。如果你的类有多个构造函数，`@ConstructorBinding`注解可以用来指定哪个构造函数用于构造函数绑定。要为具有单个参数化构造函数的类选择退出构造函数绑定，必须使用`@Autowired`. 构造函数绑定可以与记录一起使用。除非您的记录有多个构造函数，否则不需要使用`@ConstructorBinding`.

构造函数绑定类的嵌套成员（如上`Security`例）也将通过其构造函数进行绑定。可以使用`@DefaultValue`构造函数参数和记录组件指定默认值。转换服务将用于将注释的`String`值强制转换为缺失属性的目标类型。如果没有属性绑定到`Security`，则该`MyProperties`实例将包含 的`null`值`security`。要使它包含一个非空的实例，`Security`即使没有属性绑定到它（使用 Kotlin 时，这将需要将 的`username`和`password`参数`Security`声明为可空的，因为它们没有默认值），使用空`@DefaultValue`注释：

```java
public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) {
    this.enabled = enabled;
    this.remoteAddress = remoteAddress;
    this.security = security;
}
```

#### @ConfigurationProperties 注释类型

Spring Boot 提供基础设施来绑定`@ConfigurationProperties`类型并将它们注册为 beans。您可以逐个类地启用配置属性，也可以启用以类似于组件扫描的方式工作的配置属性扫描。

有时，带有注释的类`@ConfigurationProperties`可能不适合扫描，例如，如果您正在开发自己的自动配置或者您希望有条件地启用它们。在这些情况下，使用`@EnableConfigurationProperties`注释指定要处理的类型列表。这可以在任何`@Configuration`类上完成，如以下示例所示：

```java
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(SomeProperties.class)
public class MyConfiguration {

}
```

要使用配置属性扫描，请将`@ConfigurationPropertiesScan`注释添加到您的应用程序。通常，它被添加到带有注释的主应用程序类中，`@SpringBootApplication`但它可以添加到任何`@Configuration`类中。默认情况下，将从声明注释的类的包中进行扫描。如果要定义要扫描的特定包，可以按照以下示例所示进行操作：

```java
@SpringBootApplication
@ConfigurationPropertiesScan({ "com.example.app", "com.example.another" })
public class MyApplication {

}
```

当`@ConfigurationProperties`使用配置属性扫描或通过 注册 bean时`@EnableConfigurationProperties`，bean 有一个约定名称：`<prefix>-<fqn>`，其中`<prefix>`是`@ConfigurationProperties`注释中指定的环境键前缀，`<fqn>`是 bean 的完全限定名称。如果注释不提供任何前缀，则仅使用 bean 的完全限定名称。上面示例中的 bean 名称是`com.example.app-com.example.app.SomeProperties`.

注意：`@ConfigurationProperties`只处理环境，特别是不要从上下文中注入其他 bean。对于极端情况，可以使用 setter 注入或`*Aware`框架提供的任何接口（例如，`EnvironmentAware`如果您需要访问`Environment`）。如果您仍想使用构造函数注入其他 bean，则配置属性 bean 必须注释`@Component`并使用基于 JavaBean 的属性绑定。

### 第三方配置

除了`@ConfigurationProperties`用于注释类之外，您还可以在公共`@Bean`方法上使用它。当您想要将属性绑定到您无法控制的第三方组件时，这样做会特别有用。要从`Environment`属性配置 bean，请添加`@ConfigurationProperties`到它的 bean 注册中，如以下示例所示：

```java
@Configuration(proxyBeanMethods = false)
public class ThirdPartyConfiguration {

    @Bean
    @ConfigurationProperties(prefix = "another")
    public AnotherComponent anotherComponent() {
        return new AnotherComponent();
    }

}
```

使用前缀定义的任何 JavaBean 属性都以类似于前面示例的方式`another`映射到该bean。`AnotherComponent``SomeProperties`

https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding